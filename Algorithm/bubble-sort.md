## 거품 정렬
- 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
  - 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/Algorithm/image/bubble-sort.png" width = 500/>

<br/>

### 버블 정렬의 원리
1. 버블 정렬(bubble sort)는 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환하는 비교-교환 과정을 리스트의 왼쪽 끝에서 시작하여 오른쪽 끝까지 진행한다.
2. 이러한 비교-교환 과정(스캔)이 한 번 완료 되면 가장 큰(혹은 가장 작은) 레코드가 리스트의 오른쪽 끝으로 이동한다.
3. 스캔은 전체 숫자가 전부 정렬될 때까지 계속된다.
4. 결과적으로 정렬이 안 된 오른쪽 리스트를 한 번 스캔하면 오른쪽 리스트의 오른쪽 끝에 가장 큰(혹은 가장 작은) 레코드가 위치하게 되고, 오른쪽 리스트는 추가된 레코드를 포함하여 정렬된 상태가 된다.

<br/>

### 버블 정렬 구현
```java
public class Bubble_Sort {
	public static void bubble_sort(int[] a) {
		bubble_sort(a, a.length);
	}
		
	private static void bubble_sort(int[] a, int size) {	
		// round는 배열 크기 - 1 만큼 진행됨 
		for(int i = 1; i < size; i++) {
					
		// 각 라운드별 비교횟수는 배열 크기의 현재 라운드를 뺀 만큼 비교함
		    for(int j = 0; j < size - i; j++) {
							
				/*
				 *  현재 원소가 다음 원소보다 클 경우
				 *  서로 원소의 위치를 교환한다. 
				 */
				if(a[j] > a [j + 1]) {
					swap(a, j, j + 1);
				}
			}
		}
	}
		
	private static void swap(int[] a, int i, int j) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
}
```

<br/>

### 버블 정렬의 복잡도 분석
- 버블 정렬은 어떠한 경우에도 시간 복잡도가 $O(n^2)$로 일정하다.

<br/>

### 버블 정렬의 특징
- 가장 큰 문제점은 순서에 맞지 않은 요소를 인접한 요소와 교환한다는 것이다.
    - 하나의 요소가 가장 왼쪽에서 가장 오른쪽에서 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
    - 특히 특정 요소가 최종 정렬 위치에 있는 경우라도 교환되는 일이 일어난다.
- 일반적으로 자료의 교환(swap) 작업이 자료의 이동(move) 작업보다 더 복잡하기 때문에 버블 정렬은 그 단순성에도 불구하고 거의 쓰이지 않고 있다.

<br/>
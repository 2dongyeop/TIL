## 삽입 정렬
- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.
    - 정렬되어 있는 리스트에 새로운 레코드를 적절한 위치에 삽입하는 과정을 반복한다.
    - 선택 정렬과 마찬가지로 입력 배열을 선택 정렬과 유사하게 정렬된 부분과 정렬되지 않은 부분으로 나누어 사용한다.

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/Algorithm/image/insertion-sort.png" width = 500/>

<br/>

### 삽입 정렬의 원리
1. 정렬되어 있지 않은 부분의 첫 번째 숫자가 정렬된 부분의 어느 위치에 삽입될 것인지 판단 후, 해당 위치에 숫자를 삽입하면 된다.
2. 이렇게 하면 정렬된 부분의 크기는 하나 커지게 되고, 정렬되지 않은 부분의 크기는 하나 줄어들게 된다.

<br/>

### 삽입 정렬의 특징
- 장점
  - 안정한 정렬 방법이다.
  - 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하다.
  - 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.
- 단점
  - 비교적 많은 레코드들의 이동을 포함한다.
  - 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.

<br/>

### 삽입 정렬 구현
```java
public class Insertion_Sort {
	public static void insertion_sort(int[] a) {
		insertion_sort(a, a.length);
	}
		
	private static void insertion_sort(int[] a, int size) {
		for (int i = 1; i < size; i++) {
			//타겟 넘버
			int target = a[i];

			int j = i - 1;

			//타겟이 이전 원소보다 크기 전까지 반복
			while (j >= 0 && target < a[j]) {
				a[j + 1] = a[j];      //이전 원소를 한 칸씩 뒤로 미룬다.
				j--;
			}
						
			//위 반복문에서 탈출하는 경우이면 앞의 원소가 타겟보다 작다는 의미
			//따라서 타겟은 j+1번째에 위치하게 된다.

			a[j + 1] = target;
	    }
	}
}
```

<br/>

### 삽입 정렬 복잡도 분석
- 삽입 정렬의 복잡도는 입력 자료의 구성에 따라서 달라진다.
    - 최적의 복잡도 : 이미 정렬되어 있는 경우
        - 시간 복잡도 : $O(1)$
    
    - 최악의 복잡도 : 입력 자료가 역순으로 정렬되어 있는 경우
        - 시간 복잡도 : $O(n^2)$

- 결과적으로 삽입 정렬은 레코드 양이 많고, 레코드 크기가 클 경우 적합하지 않다.
- 안전한 정렬 방법이기도 하며, 알고리즘 자체가 매우 간단하여 다른 알고리즘보다 레코드 수가 적을 경우 유리하다.
# 배열리스트과 연결리스트

## 배열(Array)과 리스트(List)
- 배열은 메모리 공간에 할당할 사이즈를 미리 정해놓고 사용하는 자료구조다.
  - 따라서 계속 데이터가 늘어날 때, 최대 사이즈를 알 수 없을 때는 사용하기에 부적합하다.
  - 또한 중간에 데이터를 삽입하거나 삭제할 때도 매우 비효율적이다.

<br/>

> 이를 해결하기 위해 나온 것이 리스트(List)이다.

<br/>

- 리스트는 배열처럼 크기를 정해주지 않아도 된다. 
  - 대신 array에서 index가 중요했다면, List에서는 순서가 중요하다.
  - 크기가 정해져있지 않기 때문에, 중간에 데이터를 추가하거나 삭제하더라도 array에서 갖고 있던 문제점을 해결 가능하다. 
  - 또한, index를 가지고 있으므로 검색도 빠르다.
  - 하지만, 중간에 데이터를 추가 및 삭제할 때 시간이 오래걸리는 단점이 존재한다. (더하거나 뺄때마다 줄줄이 당겨지거나 밀려날 때 진행되는 연산이 추가, 메모리도 낭비 등)


<br/>

## 배열 리스트(ArrayList)이란?
- 이름처럼 내부적으로 배열을 사용하여 데이터를 관리한다.
- 인덱스를 가지고 있어 데이터 **검색에 적합하고 속도가 빠르다.**
  - 이때, `O(1)`의 시간 복잡도를 가진다.
- 데이터의 삽입, 삭제 시 해당 데이터를 제외한 모든 데이터를 임시 배열을 생성해 복사하므로 **삽입, 삭제가 빈번할 경우 속도가 느리며 부적합하다.**
  - 이때, `O(n)`의 시간 복잡도를 가진다.
- 동기화를 지원하지 않아 Vector보다 빠르다.


<br/>

## 연결 리스트(LinkedList)란?
- 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있으면 된다.
- 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 오래 걸리며 성능상 좋지 않다.
  - 이때, `O(n)`의 시간 복잡도를 가진다.
- 데이터의 삽입, 삭제시 불필요한 데이터의 복사가 없어 데이터의 **삽입, 삭제 시 유리하다.**
  - 중간 요소의 삽입, 삭제가 없고 맨 앞과 뒤 요소의 삽입, 삭제만 한다면 `O(1)`의 시간 복잡도를 가지고, 그렇지 않으면 `O(n)`의 시간 복잡도를 가진다..




<br/>

## 마무리
> 따라서 데이터의 검색이 주가 되는 경우에는 ArrayList를 사용하는 게 좋다.
>
> 데이터의 삽입, 삭제가 빈번하다면 ArrayList보다는 LinkedList를 사용하는 편이 낫다.
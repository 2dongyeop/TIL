# 람다식

- 본 내용은 [이것이 자바다 - 신용권]을 참고하여 정리하였습니다.
- [소스 코드 레퍼지토리](https://github.com/2dongyeop/thisisjava)로 이동하기

<br/>

> 1절. 람다식이란?
> 
> 2절. 람다식 기본 문법
>
> 3절. 타겟 타입과 함수적 인터페이스
> 
> 4절. 클래스 멤버와 로컬 변수 사용
>
> 5절. 표준 API의 함수적 인터페이스
>
> 6절. 메소드 참조

<br/>

## 0. 개요
- 자바는 객체 지향 프로그래밍이 소프트웨어 개발의 주요 패러다임이였던 시대에 디자인되었다.
- 최근 들어 함수적 프로그래밍이 다시 부각되고 있는데, 이는 <span style="color:orange">병렬 처리와 이벤트 지향 프로그래밍에 적합</span>하기 때문이다.
- 따라서 객체지향 프로그래밍과 함수적 프로그래밍을 혼합함으로써 더욱 효율적인 프로그래밍이 될 수 있도록 프로그래밍 개발 언어가 변하고 있다.

<br/>

> 자바는 <span style="color:orange">함수적 프로그래밍을 위해 람다식을 지원</span>함으로써 기존 코드 패턴이 많이 달라졌다.

<br/>

## 1. 람다식이란?
### 람다식
- 람다식은 익명 함수를 생성하기 위한 식으로, 객체 지향 언어보다는 함수 지향 언어에 가깝다.
- 람다식을 수용하는 이유는 자바 코드가 매우 간결해지고, 컬렉션의 요소를 필터링하거나 매핑해서 원하는 결과를 쉽게 집계할 수 있기 때문이다.

<br/>

### 사용 예시 비교
`Runnable` 인터페이스의 익명 구현 객체를 생성하는 전형적인 코드
```java
Runnable runnable = new Runnable() {
	public void run() {...}
};
```

<br/>

람다식을 사용할 경우
```java
Runnable runnable = () -> {...};
```
- 람다식의 형태는 매개 변수를 가진 코드 블록이지만, 런타임 시에 익명 구현 객체를 생성한다.
- 람다식은 위와 같이 "(매개변수) -> {실행코드}" 형태로 작성된다.
- 함수 정의 형태를 띠고 있지만, 런타임 시에 인터페이스의 익명 구현 객체로 생성된다.
    - 어떤 인터페이스를 구현할 것인가는 대입되는 인터페이스가 무엇이냐에 달려있다.

<br/>

## 2. 람다식 기본 문법
### 기본 형태
```java
(타입 매개변수, ...) -> {실행문; ...}
(int a) -> {System. out.println(a);}
```
- 소괄호() 안에는 중괄호{} 블록을 실행하기 위해 필요한 값을 제공한다.
    - 매개 변수의 이름은 개발자가 자유롭게 줄 수 있다.
    - `->` 기호는 매개 변수를 이용해 중괄호{} 블록을 실행한다는 뜻이다.

<br/>

### 기본 문법
```java
(a) -> {System. out.println(a);}
a -> System. out.println(a);
() -> { 실행문; }
```
- 람다식에서는 매개 변수의 타입을 일반적으로 언급하지 않는다.
    - 매개 변수 타입은 런타임 시에 대입되는 값에 따라 자동으로 인식될 수 있기 때문이다.
- 하나의 매개변수만 있다면 ()를 생략할 수 있고, 실행문도 하나이면 {}를 생략할 수 있다.
- 만약 매개변수가 없다면 람다식에서 매개 변수 자리가 없어지므로 빈 괄호를 반드시 사용해야 한다.

<br/>

## 3. 타겟 타입과 함수적 인터페이스
### 기본 형태
```java
인터페이스 변수 = 람다식;
```
- 자바는 메소드를 단독으로 선언할 수 없고, 항상 클래스의 구성 멤버로 선언한다.
    - 따라서 람다식은 메소드를 단순히 선언하는 것이 아닌, 메소드를 가지고 있는 객체를 생성한다.
- 람다식은 인터페이스 변수에 대입되어, 인터페이스의 익명 구현 객체를 생성한다.
    - 인터페이스는 객체화 할 수 없어 구현 클래스가 필요하고, 람다식은 이를 구현한다.

<br/>

> 대입될 인터페이스의 종류에 따라 작성 방법이 달라지기 때문에, 람다식은 인터페이스를 람다식의 타겟타입(target type)이라고 한다.

<br/>

### 함수적 인터페이스(@FuntionalInterface)
- 모든 인터페이스를 람다식의 타겟 타입으로 사용할 수는 없다.
    - 하나의 추상 메소드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있다.
    - 이를 함수적 인터페이스(funtional interface)라고 한다.

<br/>

```java
@FunctionalInterface
public interface MyFunctionalInterface {
	public void method();
	public void otherMethod(); //컴파일 오류
}
```
- `@FunctionalInterface` 어노테이션은 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체크해주는 기능이 있어, 두 개 이상의 추상 메소드가 선언되면 컴파일 오류를 발생시킨다.
- 이 어노테이션이 없더라도 하나의 추상 메소드만 있다면 모두 함수적 인터페이스이다.

<br/>

## 4. 클래스 멤버와 로컬 변수 사용
### 클래스의 멤버 사용
- 람다식 실행 블록에는 클래스의 멤버 및 로컬 변수를 사용할 수 있다.
- 다만 `this` 키워드를 사용할 때에는 주의가 필요하다.
    - 일반적으로 익명 객체 내부에서 `this`는 익명 객체의 참조이지만,
    - 람다식에서는 `this`는 람다식을 실행한 객체의 참조이다.

<br/>

### 클래스의 로컬 변수 사용
- 람다식은 메소드 내부에서 주로 작성되기 때문에 로컬 익명 구현 객체를 생성시킨다고 본다.
- 람다식에서 바깥 클래스의 필드나 메소드는 제한 없이 사용할 수 있다.
    - **단, 메소드의 매개 변수 또는 로컬 변수를 사용하면 이 두 변수는 final 특성을 가져야 한다.**
    - 따라서 매개 변수나 로컬 변수를 람다식에서 **읽는 것은 허용되지만, 변경할 수는 없다.**

## 5. 표준 API의 함수적 인터페이스
### 개요
- 자바에서 제공되는 표준 API에서 한 개의 추상 메소드를 가지는 인터페이스들은 모두 람다식을 이용해 익명 구현 객체로 표현이 가능하다. 
- 🌰 자바 8부터는 함수적 인터페이스를 java.util.funtion 표준 API 패키지로 제공하는데,
    - 이는 메소드 또는 생성자의 매개 타입으로 사용되어 람다식을 대입할 수 있도록 하기 위함이다.


### java.util.function 패키지의 함수적 인터페이스 종류
- 구분 기준은 인터페이스에 선언된 추상 메소드의 매개값과 리턴값의 유무이다.

|종류|추상메소드 특징|동작 방식|
|:-:|:---------:|:-----:|
|Consumer|매개값은 있고, 리턴값은 없음|매개값 → Consumer → x|
|Supplier| 매개값은 없고, 리턴값은 있음|x → Suppiler  → 리턴값|
|Function| 매개값도 있고, 리턴값도 있음 <br/> 주로 매개값을 리턴값으로 매핑(타입 변환))|매개값 → Funcion → 리턴값|
|Operator| 매개값도 있고, 리턴값도 있음 <br/> 주로 매개값을 연산하고 결과를 리턴|매개값 → Operator → 리턴값|
|Predicate| 매개값은 있고, 리턴 타입은 boolean <br/> 매개값을 조사해서 true/false를 리턴|매개값 → Predicate → boolean|


<br/>

> 자세한 사용 방법은 생략하여 [링크](https://leedongyeop.notion.site/ch14-23f77d87ff9a4fef9bb61d8f4e733387)를 통해 자세히 볼 수 있습니다.


<br/>

## 6. 메소드 참조
### 메소드 참조란?
- 메소드를 참조해서 매개 변수의 정보 및 리턴 타입을 알아낸다.
- 람다식에서 불필요한 매개 변수를 제거하는 것이 목적이다.

<br/>

### 사용 예시 비교
```java
(left, right) -> Math.max(left,right);
```
- 위 경우, 단순히 기존 메소드를 호출만 하는 경우이다.
    - 람다식이 메소드의 매개값으로 전달하는 역할만 하기 때문에 다소 불편하다.

<br/>

```java
IntBinaryOperator operator = Math :: max;
```
- 이는 메소드 참조도 람다식과 마찬가지로 인터페이스의 익명 구현 객체로 생성된다.
    - 따라서 타겟 타입인 인터페이스의 추상 메소드의 타입과 리턴 타입에 따라 달라진다.

### 정적 메소드와 인스턴스 메소드 참조
#### 정적 메소드 참조
```java
클래스 :: 메소드
```
- 정적 메소드를 참조할 경우, 클래스 이름 뒤에 :: 기호를 붙이고, 메소드 이름을 기술한다.

<br/>

#### 인스턴스 메소드 참조
```java
참조변수 :: 메소드
```
- 인스턴스 메소드를 참조할 경우 먼저 객체를 생성하고, 참조 변수 뒤에 기호를 붙인다.

<br/>

### 매개 변수의 메소드 참조
- 메소드는 람다식 외부의 클래스 멤버일 수도 있고, 람다식에서 제공되는 매개변수의 멤버일 수도 있다.

<br/>

```java
(a, b) -> { a.instanceMethod(b); }
```
- 이는 람다식에서 제공되는 a 매개 변수의 메소드를 호출해서 b 매개 변수를 매개값으로 쓴다.

<br/>

### 생성자 참조
- 메소드 참조는 생성자 참조도 포함한다.
    - 생성자를 참조한다는 것은 객체 생성을 의미한다.
    - 단순히 객체를 생성하고 리턴하도록 구성된 람다식은 생성자 참조로 대치할 수 있다.

<br/>

```java
(a, b) -> { return new 클래스(a,b); }

클래스 :: new
```
- 생성자 참조 표현은 클래스 이름 뒤에 :: 를 붙이고 new 연산자를 기술한다.

## 마무리
글을 간략하게 작성하다보니 생략된 코드들이 있으니, 자세히 보려면 [링크](https://github.com/2dongyeop/thisisjava/tree/main/src/newCode/thisisjavaExercise/chapter14)를 클릭해주세요.
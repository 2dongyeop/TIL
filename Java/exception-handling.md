# 예외 처리

- 본 내용은 [이것이 자바다 - 신용권]을 참고하여 정리하였습니다.
- [소스 코드 레퍼지토리](https://github.com/2dongyeop/thisisjava)로 이동하기

<br/>

> 1절. 예외와 예외 클래스 
> 
> 2절. 실행 예외
>
> 3절. 예외 처리 코드
> 
> 4절. 예외 종류에 따른 처리 코드
>
> 5절. 자동 리소스 닫기
>
> 6절. 예외 떠넘기기
> 
> 7절. 사용자 정의 예외와 예외 발생
> 
> 8절. 예외 정보 얻기

<br/>


## 1. 예외와 예외 클래스
### 에러(error)
- 응용프로그램에서 실행 오류가 발생하는 것

<br/>

### 예외(exception)
- **사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류**이다.
- 자바에서는 예외를 클래스로 관리하여, 모든 클래스들은 java.lang.Exception을 상속받는다. 
    - 일반 예외 : 자바 소스를 컴파일하는 과정에서 예외 처리 코드가 필요한지 검사한다.
    - 실행 예외 : 컴파일 과정에서 예외 처리 코드를 검사하지 않는 예외를 말한다.

<br/>

> 예외가 발생되면 프로그램이 종료된다는 점에서 에러와 동일하지만, 예외는 **예외 처리를 통해 프로그램을 종료하지 않고 정상 실행 상태가 유지**되도록 할 수 있다.

<br/>

## 2. 실행 예외
### 실행 예외는 오로지 개발자의 경험에 의해서 예외 처리 코드를 삽입해야 한다. 
- 앞에서 말했듯이, 자바 컴파일러가 체크를 하지 않기 때문이다.

<br/>

### NullPointerException
- 객체 참조가 없는 상태로, null값을 갖는 변수에 객체 접근 연산자인(.)를 사용했을 때 발생한다. 
- 즉, 객체가 없는 상태에서 객체를 사용하려 했으니 예외가 발생한다.

```Java
public class NullPointerExceptionExample {
	public static void main(String[] args) {
		String data = null;
		System.out.println(data.toString());
	}
}
```
<br/>

### ArrayIndexOutOfBoundsException
- 배열에서 인덱스 범위를 초과하여 사용할 경우에 발생한다
- 예를 들어 길이가 3인 `int[] arr = new int[3]` 배열을 선언했을 때, 범위를 초과하여 arr[3]을 사용할 경우 발생한다.

<br/>

### NumberFormatException
- 매개 값에 숫자로 변환될 수 없는 문자가 포함되어 있다면 발생한다.

| 반환 타입 | 메소드명(매개 변수) | 설명 |
| :---: | :---: | :---: |
| int | Integer.parseInt(String s) | 주어진 문자열을 정수로 변환해서 리턴 |
| double | Double.parseDouble(String s) | 주어진 문자열을 실수로 변환해서 리턴 |

- 흔히 Wrapper 클래스의 메서드를 사용할 때 발생하기 쉽다.

<br/>

### ClassCastException
- 타입 변환(Casting)은 클래스 간에 발생하고 구현 클래스와 인터페이스 간에도 발생한다. 
- 상속 관계가 아닌데 억지로 타입 변환을 시도할 경우 발생한다. 

<br/>

## 3. 예외 처리 코드
### 예외 처리 코드
- 프로그램에서 예외가 발생했을 경우 프로그램의 갑작스러운 종료를 막고, 정상 실행을 유지한다.
- `try-catch-finally` 블록에 해당한다.

<br/>

### try - catch - finally 블록
- try 블록에는 예외 발생 가능 코드가 위치한다. 
- 예외 발생 시 catch로 이동하여 예외 처리 코드를 실행한다.
     - 만일 예외가 발생하지 않으면 catch 블록은 실행되지 않는다. 
- 예외 처리 코드가 끝나면 finally 블록의 코드를 실행한다. 
    - 예외 발생 여부와 상관없이 항상 실행할 내용이 있을 경우에만 작성하면 된다. 

<br/>

## 4. 예외 종류에 따른 처리 코드
### 다중 catch문
- try 블록 내부에서 다양한 종류의 예외가 발생할 수 있다. 
- 이 경우, 발생되는 예외별로 예외 처리 코드를 다르게 하려면 다중 catch 블록을 작성해야 한다.
    - 단, try 블록에서 동시 다발적으로 예외가 발생하지 않는다는 점에 주의하자.
    - 하나의 예외가 발생하면 즉시 실행을 멈추고 해당 catch로 이동한다.
    - 따라서 catch 블록이 여러개라 할지라도 단 하나의 catch 블록만 실행된다. 

<br/>

### catch 순서
- 다중 catch 블록에서는 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 한다. 
- 하위 예외는 상위 예외를  상속했기 때문에 상위 예외 타입도 되기 때문에, 하위 예외 클래스의 catch 블록이 실행되지 않기 때문이다.

<br/>

### 멀티 catch
- 하나의 catch 블록에서 여러 개의 예외를 처리할 수 있도록 하기 위한 기능이다.
    - 작성 방법은 catch 괄호 ( )안에 동일하게 처리하고 싶은 예외를 | 로 연결한다. 
```java
    catch(NumberFormatException | NullPointerException e) { ... }
```

<br/>

## 5. 자동 리소스 닫기
### try - with - resource
- 예외 발생 여부와 상관없이 사용했던 리소스 객체의 close() 메소드를 호출한다.
    - 리소스란 여러 가지 의미지만, 여기서는 데이터를 읽고 쓰는 객체로 이해하자.
- AutoCloseable 인터페이스를 구현하고 있어야 한다.


<br/>

## 6. 예외 떠넘기기
### throws
- 메소드 내부에서 예외가 발생할 수 있는 코드를 작성할 때, 경우에 따라 메소드를 호출한 곳으로 예외를 떠넘길 수도 있다. 
- 메소드 선언부 끝에 작성되고, throws 키워드 뒤에는 떠넘길 예외 클래스를 쉼표로 나열해준다.

```java
// 모든 예외를 간단히 떠넘김
리턴타입 메소드명(매개변수, ...) throws Exception { } 
```

<br/>

> main() 메소드에서도 throws 키워드를  사용해 예외를 떠넘길 수 있지만, 결국 JVM이 최종적으로 예외 처리를 하게 된다. JVM은 예외의 내용을 콘솔에 출력하는 것으로 예외처리를 한다. 
>
> 다만 main() 메소드에서 throws Exception을 붙이는 것은 좋지 못한 예외 처리 방법이다.


<br/>

## 7. 사용자 정의 예외와 예외 발생
### 사용자 정의 예외
- 자바 표준 API에서 제공하는 예외 클래스만으로는 다양한 종류의 예외를 표현할 수가 없다. 
- 이런 애플리케이션 서비스와 관련된 예외를 **애플리케이션 예외**(Application Exception)라고 한다. 또는 개발자가 직접 정의해서 만들어야 하므로 **사용자 정의 예외**라고도 한다.

<br/>

### 정의 방법
- 일반 예외로 선언할 경우는 Exception을 상속하고, 실행 예외로 선언할 경우는 RuntimeException을 상속한다.
- 필드, 생성자, 메소드 선언을 포함할 수 있지만 대부분 생성자 선언만 포함한다.
- 생성자는 일반적으로 두 개를 선언한다.
    -  하나는 기본 생성자이고, 하나는 예외 발생 원인을 전달하기 위해 String 타입의 매개 변수를 갖는 생성자이다.
- 클래스 이름은 Exception으로 끝나는 것이 좋다.

<br/>

## 8. 예외 정보 얻기
### getMessage()
- String 타입의 메세지를 갖는 예외 생성자를 이용했을 때, 이 메소드를 통해 예외 코드를 예외 메세지로 전달 받을 수 있다.


<br/>

### printStackTrace()
- 메소드 이름에서도 알 수 있듯이 예외 발생 코드를 추적해서 모두 콘솔에 출력한다. 
- 어떤 예외가 어디서 발생했는지 상세하게 출력해주기 때문에 유용하다.


<br/>

## 키워드 정리
💡 `throw`와 `throws`
- `throw` : 억지로 Exception을 발생시킬 때 사용
- `throws` : 메소드를 정의할 때 사용 

<br/>

> `throws`는 메서드를 호출한 상위 메소드는 에러 처리에 대한 책임을 부여하고, 
> 
> `throw`는 프로그래머가 사용자 정의 exception을 강제로 발생시켜 메서드 내에서 예외처리를 수행하는 것이다. 

<br/>

<br/>

## 예외 던지기 사용 예시 (throw, throws)
### throw 사용 예시
- 위에서 말했듯이 `throw` 는 개발자가 의도적으로 예외를 발생시키는 것.
    - 개발자의 판단에 따른 처리가 가능하다.
    ```java
    public class Test {
    	public static void main(String[] args) {
    		int a = 2;
    		int b = 0;
    		divide(a,b);
    	}
    	
    	private static int divide(int a, int b) {
    		if (b == 0) {
    			throw new ArithmeticException("0으로 나눌 수 없습니다.");
    		}
    		return a / b;
    	}
    }
    ```

<br/>


### throws 사용 예시
- 메서드 내에서 예외처리를 하지 않고, 책임을 전가
- 예외 처리는 해당 메서드를 사용한 곳에서 처리한다.
    ```java
    public class Test {
    	public static void main(String[] args) {
    		int a = 2;
    		int b = 0;
    		try {
        		divide(a,b);
    		} catch (ArithmeticException e) {
    			e.printStackTrace();
    		}
    	}
    	
    	private static int divide(int a, int b) throws ArithmeticException {
    		if (b == 0) {
    			throw new ArithmeticException("0으로 나눌 수 없습니다.");
    		}
    		return a / b;
    	}
    }
    ```
    
<br/>

<br/>

> 이왕이면 `throw`보다는 `throws`를 사용하는게 좋을까?
>
>   → 예외가 발생할 수 있는 코드가 있다는 것을 인지시키고, 예외처리를 강요
>
> 여러번 `throws`를 이용해 호출한 메소드에서 예외처리를 하도록 책임을 전가하면?
>
>   → 지저분한 코드가 만들어지고, 객체지향이 아닌 절차지향이 되어버림.

<br/>


### ‼️ `e.printStackTrace()`의 취약점
예외 처리를 하는 경우에 `catch` 블록에는 아래와 같은 오류 로그를 많이 남긴다.

- `e.getMessage()` : 에러의 원인을 간단하게 출력
- `e.toString()` : 에러의 Exception 내용과 원인을 출력
- `e.printStackTrace()` : 에러의 발생근원지를 찾아 단계별로 에러를 출력

<br/>

이 메소드들은 예외가 발생할 경우 콘솔에 시스템 파일 경로 및 각종 정보들이 확인되게 해주는데,

→ 이는 외부인들로부터 어떤 내부 구조의 실마리를 제공한다.

<br/>

또한, 이 메소드는 Java 리플렉션을 사용하여 추적하는 것이라 많은 오버헤드가 발생할 수 있다.

→ 이는 성능을 중시하는 서비스에서는 영향이 클 수 있다.

<br/>
따라서, 최소한의 정보만 정의하여 로그를 남기도록 메소드를 재정의하거나,

`e.getMessage()`나 `e.toString()`을 이용하는 것이 안전하다.

<br/>

## 트랜잭션(Transaction)
- 트랜잭션은 하나의 작업 단위를 말한다.

<br/>

예를 들어 쇼핑몰의 “상품발송”을 트랜잭션으로 가정할 때,

“상품발송” 이라는 트랜잭션에는 다음과 같은 작업들이 있다고 가정한다.

- 포장
- 영수증 발행
- 발송

<br/>

쇼핑몰 운영자는 이 3가지 작업들 중 하나라도 실패한다면?

→ 3가지 모두 취소하고 “상품발송” 전의 상태로 되돌리고 싶어 한다.

<br/>

> 이때, 작업을 모두 취소하지 않으면 데이터의 정합성이 크게 흔들리는데,
>
> 이렇게 모두 취소하는 행위를 전문 용어로 롤백(Rollback)이라고 한다.

<br/>

- 수도 코드(pseudo code)로 알아보기
    - 아래와 같이 포장, 영수증발행, **발송 메서드에서는 예외를 throw**하고,
    - **상품발송 메서드에서 throw된 예외를 처리하여 모두 취소하는 것**이 완벽한 트랜잭션 처리 방법이다.
    
        ```java
        상품발송() {
                try {
                        포장();
                        영수증발행();
                        발송();
                } catch(예외) {
                        모두 취소(); //하나라도 실패하면 모두 취소
                }
        }
        
        포장() throws 예외 {
                ...
        }
        
        영수증발행() throws 예외 {
                ...
        }
        
        발송() throws 예외 {
                ...
        }
        
        ```

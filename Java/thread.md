# 멀티 스레드

- 본 내용은 [이것이 자바다 - 신용권]을 참고하여 정리하였습니다.
- [소스 코드 레퍼지토리](https://github.com/2dongyeop/thisisjava)로 이동하기

<br/>

> 1절. 멀티 스레드 개념
>
> 2절. 작업 스레드 생성과 실행
>
> 3절. 스레드 우선순위
> 
> 4절. 동기화 메소드와 동기화 블록
>
> 5절. 스레드 상태
>
> 6절. 스레드 상태 제어
> 
> 7절. 데몬 스레드
> 
> 8절. 스레드 그룹
>
> 9절. 스레드풀

<br/>

## 1. 멀티 스레드 개념
### 💡 프로세스와 스레드
- #### 프로세스(`Process`)란?
    - 운영체제에서는 실행 중인 하나의 애플리케이션을 프로세스(process)라고 부른다. 
    - 사용자가 애플리케이션을 실행하면 운영체제로부터 실행에 필요한 메모리를 할당받아 애플리케이션의 코드를 실행하는데 이것이 프로세스이다.

<br/>

- #### 멀티 태스킹(`multi tasking`)이란?
    - 멀티 태스킹은 두 가지 이상의 작업을 동시에 처리하는 것을 말한다.
    - 운영체제는 멀티 태스킹이 가능하도록 CPU와 메모리 자원을 프로세스마다 적절히 할당해주고, 병렬로 실행시킨다. 
        - ex) 워드로 문서 작업을 하면서, 동시에 원도우 미디어 플레이어로 음악을 듣는것

<br/>

> 단, 멀티 태스킹이 무조건 멀티 프로세스를 뜻하는 것은 아니다.
> 
> → 한 프로세스 내에서 멀티 태스킹을 할 수 있도록 만들어진 애플리케이션이 있다.
>
> → ex) 미디어 플레이어: 동영상 재생과 음악 재생이라는 두 작업을 동시에 처리

<br/>

- #### 스레드(`Thread`)란?
    - 하나의 스레드는 하나의 코드 실행 흐름이다.
        -  한 프로세스 내에서 스레드가 두 개라면 두 개의 코드 실행 흐름이 생긴다는 의미이다.

<br/>

- #### 멀티 프로세스와 멀티 스레드
    - 멀티 프로세스
        - 운영체제에서 할당받은 자신의 메모리를 가지고 실행해 독립적이다.
        - 따라서 하나의 프로세스에서 오류가 발생해도 다른 프로세스에 영향이 없다.
        - ex) 워드와 엑셀을 동시에 사용하던 도중 워드에 오류가 생겨서 먹통이 되더라도 엑셀은 사용 가능하다.

    <br/>

    - 멀티 스레드
        - 하나의 프로세스 내부에 생성된다.
            - 따라서 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수가 있어, 다른 스레드에 영향을 미치게 된다.
            - ex) 멀티 스레드로 동작하는 메신저의 경우 파일을 전송하는 스레드에서 예외가 발생되면, 메신저 프로세스 자체가 종료되기 때문에 채팅 스레드도 같이 종료된다.
        - 대용량 데이터의 처리 시간을 줄이기 위해 데이터를 분할해서 병렬로 처리하는 곳에서 사용한다.

<br/>

<br/>

### 💡 메인 스레드
> 모든 자바 애플리케이션은 메인 스레드(`main thread`)가 `main()` 메소드를 실행하면서 시작된다. 
>
> 메인 스레드는 `main()` 메소드의 첫 코드부터 아래로 순차적으로 실행하고, 
> 
> `main()` 메소드의 마지막 코드를 실행하거나, `return`문을 만나면 실행이 종료된다.

<br/>

단, **메인 스레드는 필요에 따라 작업 스레드들을 만들어 병렬로 코드를 작성**할 수 있다. 
- 즉, 멀티 스레드를 생성해 멀티 태스킹을 수행한다.
    - 싱글 스레드 애플리케이션은 메인 스레드가 종료되면 프로세스도 종료된다.
    - 멀티 스레드 애플리케이션은 실행 중인 스레드가 하나라도 있다면, 종료되지 않는다.
        - 메인 스레드가 작업 스레드보다 먼저 종료되어도 작업 스레드가 실행중이면 기다린다.

<br/>

<br/>

## 2. 작업 스레드 생성과 실행
- 멀티 스레드로 실행하는 애플리케이션을 개발하려면?
    - 먼저 몇 개의 작업을 병렬로 실행할지 결정하고 각 작업별로 스레드를 생성하여야 한다.

<br/>

- 자바에서는 작업 스레드도 객체로 생성되기 때문에 클래스가 필요하다. 
    - `java.lang.Thread` 클래스를 직접 객체화해서 생성해도 되지만,
    - `Thread`를 상속해서 하위 클래스를 만들어 낼 수도 있다.

<br/>

<br/>

### 💡 `Thread` 클래스로부터 직접 생성
- `Runnable`을 매개값으로 갖는 생성자를 호출하기
    ```java
    Thread thread = new Thread(Runnable target);
    ```
    - `Runnable`은 작업 스레드가 실행할 수 있는 코드(`run()`)를 가지고 있는 객체로,
    -  인터페이스 타입이기 때문에 구현 객체를 만들어 대입해야 한다.

<br/>

- `Runnable` 구현클래스 작성하기
    ```java
    class Task implements Runnable {
	    public void run() {
		    //스레드가 실행할 코드
	    }
    }
    ```
    - `Runnable`은 작업 내용을 가지고 있는 객체이지 실제 스레드가 아니다.
    - 구현 객체를 생성한 후 매개값으로 Thread 생성자를 호출하면 **작업 스레드가 생성**된다.

<br/>

- 익명 객체를 이용한 방법
    ```java
    Thread thread = new Thread(new Runnable() {  //익명 구현 객체
	    public void run() {
		    //스레드가 실행할 코드
	    }
    });
    ```
    - 코드를 절약하기 위한 방법으로, 이 방법이 주로 사용된다.

<br/>

- 작업스레드 실행하기
    ```java
    thread.start();
    ```
    - 작업 스레드는 생성되는 즉시 실행되는 것이 아니라, `start()` 메소드를 호출해야 비로소 실행된다.

<br/>

<br/>

### 💡 Thread 하위 클래스로부터 생성
> 작업 스레드가 실행할 작업을 `Runnable`로 만들지 않고, 
> 
> `Thread`의 하위 클래스로 작업 스레드를 정의하면서 작업 내용을 포함시키는 방법이다.

<br/>

- 작업 스레드 클래스 정의하기
    ```java
    public class WorkerThread extends Thread{
        @Override
        public void run() {
            //스레드가 실행할 코드
        }
    }

    Thread thread = new WorkerThread();
    ```
<br/>

- `Thread` 익명 객체로 작업 스레드 객체 생성하기
    ```java
    Thread thread = new Thread() {  //익명 객체
        public void run() {
            //스레드가 실행할 코드
        }
    }
    ```
    - 이 방법도 마찬가지로 `start()` 메소드를 호출하면 작업 스레드가 실행된다.

<br/>

<br/>

### 💡 스레드의 이름
> 메인 스레드는 “main”이라는 이름을 가지고 있고, 
>
> 직접 생성할 스레드는 자동적으로 `Thread-n`이라는 이름으로 설정된다. (n은 스레드의 번호)

<br/>

- 스레드 이름을 설정하고 싶을 경우 : `setName()` 메소드 이용
    ```java
    thread.setName("스레드 이름");
    ```

<br/>

- 반대로 스레드의 이름을 알고 싶을 경우
    ```java
    thread.getName();
    ```

<br/>

> 단, 위 두 메소드는 `Thread`의 인스턴스 메소드이므로 스레드 객체의 참조가 필요하다.
>  
> 만약 스레드 객체의 참조를 가지고 있지 않다면?
>
>  `Thread`의 정적 메소드인 `currentThread()`로 현재 스레드의 참조를 얻을 수 있다.

<br/>

<br/>

## 3. 스레드 우선순위

<img src="https://github.com/2dongyeop/TIL/blob/main/Java/image/thread-priority.png" width = 500/>

- 멀티스레드는 동시성(`Concurrency`) 또는 병렬성(`Parallelism`)으로 실행된다.
    - 동시성 : 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질
    - 병렬성 : 멀티 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질

<br/>

→ 싱글 코어 CPU를 이용한 멀티 스레드 작업은 병렬적으로 실행되는 것처럼 보이지만, 사실은 번갈아 실행하는 동시성 작업이다.

<br/>

<br/>

#### 스레드 스케줄링이란?
- 스레드의 개수가 코어의 수보다 많은 경우 스레드를 어떤 순서에 의해 동시성으로 실행할 것인가 결정해야 하는데, 이를 스레드 스케줄링이라고 한다.

<br/>

#### 스레드 스케줄링 방식
- 스레드 스케줄링에는 우선순위(`Priority`) 방식과 순환 할당(`Round-Robin`) 방식이 있다.
    - 우선순위 방식 : 우선순위가 높은 스레드가 실행 상태를 더 많이 갖도록 한다.
        - 이는 객체에 우선순위 번호를 부여할 수 있어 **개발자가 코드로 제어**할 수 있다.

    <br/>

    - 순환 할당 방식 : 시간 할당량을 정해서 정해진 시간만큼 실행한다.
        - 이는 **자바 가상 기계에 의해서** 정해지기 때문에 코드로 제어할 수 없다.

<br/>

<br/>

## 4. 동기화 메소드와 동기화 블록
### 💡 공유 객체를 사용할 때 주의할 점
- 싱글 스레드 프로그램에서는 한 개의 스레드가 객체를 독차지해서 사용하지만,
- 멀티 스레드 프로그램에서는 스레드들이 객체를 공유해서 작업해야 하는 경우가 있다.

<br/>

→ 이 경우, 다른 스레드의 의해 자료의 상태가 변경되어 결과가 의도와 달라질 수 있다.

→ 따라서 동기화(`synchronized`) 작업이 필요하다!!

<br/>

<br/>

### 💡 동기화 메소드 및 동기화 블록
> 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하려면?
>
> → 스레드 작업이 끝날 때까지 객체에 잠금을 걸어서 다른 스레드가 사용할 수 없도록 해야한다.

<br/>

#### 임계구역(`critical section`)이란?
- 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역을 말한다.
- 자바는 임계 영역을 지정하기 위해 동기화(`synchronized`)메소드와 동기화 블록을 제공한다.

<br/>

- 동기화 메소드 만드는 법 : `synchronized` 키워드 붙이기
    ```java
    public synchronized void method() {
        임계 영역; // 단 하나의 스레드만 실행
    }
    ```
    → 메소드 전체가 아닌, 일부 내용만 임계 영역으로 만들고 싶다면 동기화 블록을 이용하자.

<br/>

- 동기화 블록 만들기
    ```java
    public void method() {
        //여러 스레드가 실행 가능 영역
        synchronized(공유객체) { 
            임계 영역 //단 하나의 스레드만 실행
        }
        //여러 스레드가 실행 가능 영역
    }
    ```
<br/>

<br/>

## 5. 스레드 상태

> 스레드 객체를 생성하고, `start()` 메소드를 호출하면 곧바로 스레드가 실행되는 것처럼 보이지만, 사실은 실행 대기 상태가 된다. 아래 그림에서 살펴보자.

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/Java/image/thread-status.png" width = 500/>

- 실행 대기 상태란?
    - 아직 스케줄링이 되지 않아서 실행을 기다리고 있는 상태를 말한다. 
- 실행(Running)상태란?
  - 실행 대기 상태에 있는 스레드 중에서 스레드 스케줄링으로 선택된 스레드가 비로소 CPU를 점유하고  `run()` 메소드를 실행한 상태이다.
  - 단, 실행 상태의 스레드는 스케줄링에 의해 다시 실행 대기 상태로 돌아갈 수 있다. 
  - 또한, 실행 대기 상태에 있는 다른 스레드가 선택되어 실행상태가 된다. 
  
<br/>

> 이렇게 스레드는 실행 대기 상태와 실행 상태를 번갈아가면서 자신의 `run()` 메소드를 조금씩 실행하는 성질을 동시성이라고 한다.

<br/>

- 종료 상태란?
  - 실행 상태에서  `run()` 메소드의 실행문이 종료되면, 스레드가 실행은 멈추게 되는 상태이다.

- 일시 정지 상태란?
  - 스레드가 실행할 수 없는 상태이다.
  - 일시 정지 상태는 `WAITING`, `TIMED_WAITING`, `BLOCKED`가 있다.
  - 스레드가 다시 실행 상태로 가기 위해서는 일시 정지 상태에서 실행 대기 상태로 가야한다.

<br/>

<br/>

## 6. 스레드 상태 제어
- 실행 중인 스레드의 상태를 변경하는 것을 스레드 상태 제어라고 한다. 
- 멀티 스레드 프로그램을 만들기 위해선 정교한 스레드 상태 제어가 필요하다.

<br/>


<img src="https://github.com/2dongyeop/TIL/blob/main/Java/image/thread-status-handling.png" width = 500/>

<br/>

### 💡 주어진 시간동인 일시 정지 : `sleep()`
- 실행 중인 스레드를 일정 시간 멈추게 하고 싶다면 `Thread` 클래스의 정적 메소드인 `sleep()`을 사용한다.
    ```java
    try {
        Thread.sleep(1000);
    } catch(InterruptedException e) {
            // interrupt() 메소드가 호출되면 실행
    }
    ```

<br/>

<br/>

### 💡 다른 스레드에게 실행 양보 : `yield()`
- 무의미한 반복을 하는 것 보다는 다른 스레드에게 실행을 양보하고 자신은 실행 대기 상태로 가는 것이 프로그램 성능에 도움이 된다.
- `yield()` 메소드를 호출한 스레드는 실행 대기 상태로 돌아가고, 다른 스레드가 실행된다.
    ```java
    public void run() {
        while(true) {
            if(work) {
                System.out.println("ThreadA 작업 내용");
            } else {
                Thread.yield();
            }
        }
    }
    ```

<br/>

<br/>

### 💡 다른 스레드의 종료를 기다림 : `join()`
- 스레드는 다른 스레드와 독립적으로 실행하는 것이 기본이지만, 다른 스레드가 종료될 때까지 기다렸다가 실행해야 하는 경우가 발생할 수 있다. 
  - ex) 계산 작업의 결과값을 받아 이용해야 할 경우
    ```java
    @@filename(ThreadA.java)
    threadB.start();  //ThreadB.run() 호출  
    threadB.join();   //ThreadB의 작업이 끝날때까지 대기
    ```

    <br/>

    ```java
    @@filename(ThreadB.java)
    @Override
    public void run() {...} //ThreadA에서 실행시킨 메소드
    ```

<br/>

<br/>

### 💡 스레드 간 협업 : `wait()`, `notify()`, `notifyAll()`
- 경우에 따라서 두 개의 스레드를 교대로 번갈아가며 실행해야 할 경우가 있다. 
- 정확한 교대 작업이 필요한 경우, 자신의 작업이 끝나면 상대방 스레드를 일시 정지 상태에서 풀어주고 자신은 일시 정지 상태로 만드는 것이다.
  - 이 방법의 핵심은 공유 객체에 있다.

<br/>

#### 협업 절차
1. 공유 객체는 두 스레드가 작업할 내용을 각각 동기화 메소드로 구분한다.
2. 한 스레드가 작업이 끝나면 `notify()` 를 호출해 일시 정지 스레드를 실행 대기 상태로 만든다.
    - `notify()`는 `wait()`에 의해 일시 정지된 스레드 중 한 개를 실행 대기 상태로 만들고,
    - `notifyAll()`은 `wait()`에 의해 일시 정지된 모든 스레드들을 실행 대기 상태로 만든다.
3. 그 후 자신은 두 번 작업하지 않도록 `wait()` 메소드로  일시 정지 상태로 만든다.

<br/>

> 이 메소드들은 `Object` 클래스에 선언된 메소드이므로 모든 공유객체에서 호출이 가능하지만,
>
> 주의할 점은 동기화 메소드 또는 동기화 블록 내에서만 사용할 수 있다는 점이다.

<br/>

<br/>

### 💡 스레드의 안전한 종료 : `stop` 플래그, `interrupt()`
- 스레드는 `run()`메소드가 모두 실행되면 자동 종료되지만, 경우에 따라 실행 중인 스레드를 즉시 종료할 필요가 있다. 
  - 이를 위해 Thread는 스레드를 즉시 종료시키는 `stop()` 메소드를 제공하지만, 이는 deprecated 되었다.
  - 이는 스레드를 갑자기 종료하게 되면 스레드가 사용 중이던 자원들이 불안전한 상태로 남겨지기 때문이다.

<br/>

#### `interrupt()` 동작 방식
- 스레드가 일시 정지 상태에 있을 때 `InterruptedException` 예외를 발생시켜 정상종료 시킨다.
  - 주목할 점은 `interrupt()` 메소드가 실행되면 즉시 `InterruptedException` 예외가 발생하지 않고, 스레드가 미래에 일시 정지 상태가 될 때 `InterruptedException` 예외가 발생한다는 것이다.
  - 따라서 스레드가 일시 정지 상태가 되지 않으면 `interrupt()`메소드 호출은 아무런 의미가 없다.

<br/>

<br/>

## 7. 데몬 스레드
- 데몬(`daemon`) 스레드는 주 스레드의 작업을 돋는 보조적인 역할을 수행하는 스레드이다.
  - 주 스레드가 종료되면 데몬 스레드는 강제 자동 종료된다.
  - 이는 주 스레드가 종료되면 존재 의미가 없어지기 때문임.

<br/>

- 데몬 스레드 만들기
    ```java
    public static void main(String[] args) {
        AutoSaveThread thread = new AutoSaveThread();
        thread.setDaemon(true);
        thread.start();
        ...
    }
    ```
    - 데몬으로 만들기 위해서는 스레드의 `setDaemon(true)`를 호출해준다.
      - 단, `start()`가 호출된 후 `setDaemon(true)`를 호출하면 `IllegalThreadStateException`이 발생한다.
  - 현재 실행 중인 스레드가 데몬 스레드인지 구별하기 위해선 `isDaemon()`을 이용한다.

<br/>

<br/>

## 8. 스레드 그룹(`ThreadGroup`)
- 스레드 그룹(ThreadGroup)은 관련된 스레드를 묶어서 관리할 목적으로 이용된다. 

<br/>

#### 스레드 그룹 이용 사례
1. JVM이 실행되면 `system` 스레드 그룹을 만들고 JVM 운영에 필요한 스레드들을 생성해서 `system` 스레드 그룹에 포함시킨다. 
2. 그리고 `system`의 하위 스레드 그룹으로 `main`을 만들고 메인 스레드를 `main` 스레드 그룹에 포함시킨다.
3. 스레드는 반드시 하나의 스레드 그룹에 포함되는데, 명시적으로 스레드 그룹을 포함시키지 않으면 기본적으로 자신을 생성한 스레드와 같은 스레드 그룹에 속하게 된다.

<br/>

<br/>

### 💡 스레드의 일괄 `interrupt()`
- 스레드를 스레드 그룹에 포함시키면 스레드 그룹에서 제공하는 `interrupt()` 메소드를 이용해 그룹 내에 포함된 모든 스레드들은 일괄 `interrupt()`할 수 있다.

<br/>

> 단, 스레드 그룹의 `interrupt()` 메소드는 소속된 스레드의 `interrupt()` 메소드를 호출할 뿐 개별 스레드에서 발생하는 `InterruptException`에 대한 예외 처리를 하지 않는다.
>
> 따라서 안전한 종료를 원하면 개별 스레드가 예외 처리를 해야 한다.

<br/>

<br/>

## 9. 스레드풀

#### 병렬 작업 처리가 많아지면?
- 스레드 개수가 증가
- 스레드 생성과 스케줄링 → 메모리 사용량증가
- 애플리케이션 성능 저하

<br/>

> 병렬 작업의 폭증으로 인해 스레드의 폭증을 막으려면 스레드풀(`ThreadPool`)을 사용해야 한다.
>
> 자바는 스레드풀을 생성하고 사용할 수 있도록 `java.util.concurrent` 패키지에서 `ExecutorService`인터페이스와 `Executors` 클래스를 제공한다.

<br/>

#### 스레드풀 동작 원리
- 스레드풀은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓는다.
  - 이후, 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리한다.
- 작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리한다.
- 작업 처리 요청이 폭증되어도 스레드의 전체 개수가 늘어나지 않으므로 애플리케이션 성능이 급격히 저하되지 않는다.

<br/>

### 💡 스레드풀 생성
- 스레드풀을 생성하는 방법은 2가지가 있다.
    ```java
    // 유동적인 스레드풀 생성
    ExecutorService executorService = Executors.newCachedThreadPool();

    // 고정적인 스레드풀 생성
    ExecutorService executorService = Executors,newFixedThreadPool(int nThreads);
    ```

<br/>

<br/>

### 💡 스레드풀 종료
- 스레드 풀의 스레드는 기본적으로 데몬 스레드가 아니기 때문에 `main` 스레드가 종료되더라도 작업을 처리하기 위해 계속 실행 상태로 남아있다.  
- 그래서 `main()` 메소드가 실행이 끝나도 애플리케이션 프로세스는 종료되지 않는다. 
- 애플리케이션을 종료하려면 스레드풀을 종료시켜 스레드들이 종료 상태가 되도록 처리해주어야 한다.

<br/>

- 스레드풀을 종료하는 방법
    ```java
    executorService.shutdown();       //남은 작업 마무리, 스레드풀 종료(일반적)
    executorService.shutdownNow();    //남은 작업도 강제 종료
    ```

<br/>

<br/>

### 💡 콜백 방식의 작업 완료 통보
- 콜백이란 애플리케이션이 스레드에게 작업 처리를 요청한 후, 스레드가 작업을 완료하면 특정 메소드를 자동 실행하는 기법을 말한다. 
  - 이때 자동 실행되는 메소드를 콜백 메소드이다.

<br/>

> 콜백 방식 사용의 장점
>
> 작업 처리를 요청한 후 결과를 기다릴 필요 없이 다른 기능을 수행할 수 있다는 것!
> 
> 추가로 동기&비동기, 블로킹&논블로킹에 대한 지식을 정리한 [링크](https://github.com/2dongyeop/TIL/blob/main/OS/sync-async-blocking-nonblocking.md)를 첨부합니다.

<br/>


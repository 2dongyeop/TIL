# 교착 상태

> ***교착 상태란?***
> 
> - *프로세스 집합 내의 모든 프로세스가 그 집합의 다른 프로세스에 의해서만 일어날 수 있는 이벤트를 기다리는 상황을 말한다.*

<br/>

<br/>

## 💡 시스템 모델 _System Model

> 이 장에서는 커널 자원에 관해 설명하지만, 스레드는 다른 프로세스의 자원을 사용할 수 있으며 이러한 자원 사용으로 인해 교착상태가 발생할 수 있다!
이러한 교착 상태는 커널의 문제가 아니므로 여기에서는 설명하지 않는다.


<br/>

<br/>


> 자원 사용 흐름
> 
- 스레드는 자원을 사용하기 전에 반드시 요청을 해야한다.
    - 이때, 스레드는 지정된 태스크를 수행하기 위해 필요한 만큼의 자원을 요청할 수 있다.
- 사용 후에는 반드시 방출해야 한다.

<br/>

<br/>

> 프로세스의 자원 사용
> 
1. **요청** : 스레드는 자원을 요청한다.
    1. 요청이 즉시 허용되지 않으면 → 자원을 얻을 때까지 대기해야 한다.
2. **사용** : 스레드는 자원에 대해 작업을 수행할 수 있다.
3. **방출** : 스레드가 자원을 방출한다.

<br/>

<br/>

> 위에서 나온 자원의 요청과 방출은 시스템 콜이다.
> 
- 스레드가 (커널이 관리하는) 자원을 사용할 때마다 OS는 자원을 요청했는지와 할당받았는지를 확인한다.
- 또한 시스템 테이블이 각 자원이 가용 상태인지, (어느 스레드에) 할당되었는지를 기록한다.


<br/>

<br/>

## 💡 다중 스레드 응용에서의 교착 상태 _Deadlock in Multithreaded Applications

> POSIX mutex 락을 사용해 다중 스레드 Pthread 프로그램에서 어떻게 교착 상태가 발생할 수 있는지 알아보자.
> 

- 두 mutex 락이 있다면, 아래와 같은 코드 예제에 의해 생성되고 초기화된다.
    
    ```cpp
    pthread_mutex_t first_mutex;
    pthread_mutex_t second_mutex;
    
    pthread_mutex_init(&first_mutex, NULL);
    pthread_mutex_init(&second_mutex, NULL);
    ```
        
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/deadlock-example.png" width = 500/>
    

<br/>

<br/>

- 위 예제에서 thread_one이 first_mutex 락을 획득하고, thread_two가 second_mutex를 획득하면?
    - 교착 상태가 가능하다.
    - 단, thread_two가 락을 획득하려고 시도하기 전에 thread_one이 뮤텍스 락 두개를 방출한다면?
        → 교착 상태는 발생하지 않는다!
        

<br/>

<br/>

### 라이브락

> 라이브락(`livelock`)이란?
> 
> - 또 다른 형태의 라이브니스 장애로, 교착 상태와 유사하다.
> - 둘 다 두 개  이상의 스레드가 진행되는 것을 방해하지만 진행할 수 없는 이유가 서로 다르다.
> - 교착상태 : 어떤 스레드 집합의 모든 스레드가 이벤트를 기다리면서 봉쇄된다.
> - 라이브락 : 스레드가 실패한 행동을 계속해서 시도할 때 발생한다.
>     - ex) 복도에서 한사람은 오른쪽으로 움직이고, 반대편 사람은 왼쪽으로 움직여 서로 방해하는 상태

<br/>

<br/>

- 라이브락은 일반적으로 스레드가 실패한 작업을 동시에 재시도할 때 발생한다.
    - 따라서 일반적으로 각 스레드가 실패한 행동을 재시도하는 시간을 무작위로 정하면 회피할 수 있다.
    - 이 방법은 정확히 네트워크 충돌이 발생할 때 Ethernet 네트워크가 취하는 접근법이다.
    - 충돌이 발생한 직후에 퍀시을 재전송하려고 시도하는 대신, 충돌한 호스트는 재전송을 시도하기 전에 임의의 시간 동안 **한 발 뒤로 물러난다.**


<br/>

<br/>

## 💡 교착 상태 특성 _Deadlock Characterization

> 교착 상태를 특징 짓는 조건을 살펴보자.
> 

<br/>

<br/>

### 필요 조건들

교착 상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생할 수 있다.

1. **상호 배제(mutual exclusion)**
    1. 최소한 하나의 자원이 비공유 모드로 점유되어야 한다.
    2. 비공유 모드에서는 한 번에 한 스레드만이 그 자원을 사용할 수 있다.
    3. 다른 스레드가 그 자원을 요청하면 → 요청 스레드는 자원이 방출될 때까지 지연되어야 한다.

    <br/>

1. **점유하며 대기(hold-and-wait)**
    1. 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.

    <br/>

1. **비선점 (no-preemption)**
    1. 자원들을 선점할 수 없어야 한다.
    2. 즉, 자원이 강제적으로 방출될 수 없고, 점유하고 있는 스레드가 태스크를 종료한 후에 그 스레드에 의해 자발적으로만 방출될 수 있다.

    <br/>

1. **순환 대기(circular wait)**
    1. 대기하고 있는 스레드의 집합{T0, T1, … , Tn} 에서 T0은 T1이 점유한 자원을 대기하고, … , Tn은 T0가 점유한 자원을 대기한다.

<br/>

<br/>

### 자원 할당그래프

> 교착 상태는 시스템 자원 할당 그래프라고 하는 방향 그래프로 더욱 정확하게 기술할 수 있다.
> 

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/resource-allocation-graph.png" width = 500/>

- 위 그림에서 방향 간선 T → R 은 **요청 간선**이고, 방향 간선 R → T는 **할당 간선**이다.
- 자원 유형 R이 한 개 이상의 인스턴스를 가질 때 : 각 인스턴스를 사각형 내의 하나의 점으로 표시
- 할당 간선은 반드시 사각형 내의 하나의 점을 지정해야 하고, 요청 간선은 사각형 R만을 가리킨다.

<br/>

<br/>

> 그래프가 사이클을 포함하지 않으면 시스탬 내 어느 스레드도 교착 상태가 아님을 보일 수 있다.
>
> 사이클이 없다면? → 교착 상태가 아니다.
>
> 사이클이 있다면? → 교착 상태일 수도 있고 아닐 수도 있다.

<br/>

<br/>

## 💡 교착 상태 처리 방법 _Methods for Handling Deadlocks

> 원칙적으로 교착 상태 문제를 처리하는 데는 다음과 같은 세 가지 다른 방법이 있다.
> 
- 문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않는 척 한다.
- 시스템이 결코 교착 상태가 되지 않도록 보장하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다.
- 시스템이 교착 상태가 되도록 허용한 다음에 복구시키는 방법이 있다.

<br/>

<br/>

> 교착 상태가 발생하지 않도록 하기 위해 교착 상태 예방, 혹은 회피 기법의 하나를 사용할 수 있다.
> 
- **교착 상태 예방(prevent)**
    - 필요조건 중 적어도 하나가 성립하지 않도록 보장하는 일련의 방법으로,
    - 자원이 어떻게 요청될 수 있는지를 제한함으로써 교착 상태를 예방한다.
- **교착 상태 회피(avoidence)**
    - 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공할 것을 요구한다.
        - → 이 지식을 가지고, OS는 각 요청을 위해 해당 스레드가 기다려야 할지 않을지를 결정한다.

<br/>

<br/>

> 교착 상태를 탐지하고 복구하는 알고리즘이 없다면?
> 
- 시스템이 교착 상태에 이를 수 있고 교착 상태가 발생한 것을 인식하지도 못할 수 있다.
- 결국 시스템은 작동을 정지하고, 수작업으로 다시 시작할 필요가 있다.

<br/>

<br/>

> 교착 상태를 무시하는 것이 다른 처리 방법과 비교해 비용이 적게 든다.
> 
- 비용은 중요한 고려 사항 중의 하나이다.
- 사실 교착상태는 드물게 발생하기 때문에 부가적인 비용이 그만한 가치가 없을 수도 있다.

<br/>

<br/>

## 💡 교착 상태 예방 _Deadlock Prevention

> 교착 상태가 발생하려면 네 가지의 필요조건이 각가 성립해야 한다. 따라서 이들 조건 중 최소한 하나가 성립되지 않도록 보장함으로써, 우리는 **교착 상태의 발생을 예방**할 수 있다.
> 

<br/>

<br/>

### 상호 배제

- 하나의 자원은 공유가 불가능한 자원이어야 한다.
    - 반면에, 공유 가능한 자원들은 배타적인 접근을 요구하지 않으며, 따라서 교착 상태에 관련될 수 없다.

<br/>

<br/>

### 점유하며 대기

- 스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해야 한다.
    - 우리가 사용할 수 있는 하나의 프로토콜은 각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당해야 한다.
    - 물론 이는 자원 요청의 동적 특성으로 인해 대부분의 응용 프로그램에는 실용적이지 않다.

<br/>

- 한 대안 프로토콜은 스레드가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용한다.
    - 단, 두 가지 주요 단점이 있다.
    - 첫째, 자원이 할당되었지만 장기간 사용되지 않을 수 있어 자원 이용률이 낮아질 수 있다.
    - 둘째, 기아 현상이 발생할 수 있다.

<br/>

<br/>

### 비선점

- 이미 할당된 자원이 선점되지 않아야 한다는 것이다.
    - 이 조건을 위해 아래의 프로토콜을 사용할 수 있다.
    - 만일 어떤 자원을 점유하고 있는 스레드가 즉시 할당할 수 없는 다른 자원을 요청하면, 현재 점유하고 있는 모든 자원이 선점된다.
    - 즉, 이들 자원들이 묵시적으로 방출된다.

<br/>

<br/>

### 순환대기

- 이 조건은 필요한 조건 중 하나를 무효화하여 실용적인 해결책을 제공할 수 있다.
- 모든 자원 유형에 전체적인 순서를 부여하여, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구한다.

<br/>

> 교착 상태를 예방하기 위해 아래와 같은 프로토콜을 고려할 수 있다.
> 
- 각 스레드는 오름차순으로만 자원을 요청할 수 있다.
    - 즉, 스레드는 초기에 자원 R의 인스턴스를 요청할 수 있다.
    - 만일 동일한 자원 유형의 인스턴스를 여러 개 필요하다면, 이들 모두에 대한 요청이 주어져야 한다.


<br/>

<br/>

- 대안으로, 스레드가 자원 유형 Ri의 인스턴스를 요청할 때마다, F(Ri) ≥ F (Rj)인 모든 자원 Ri를 방출하도록 요구하는 방법이 있다.
    - 동일한 유형의 자원이 여러 개 필요할 경우, 단 한번의 자원 요청으로 모든 자원을 할당받아야 한다는 것에도 주의하자.

<br/>

<br/>

> 순서나 계층 구조를 정하는 것 자체만으로는 교착 상태를 예방할 수 없다.
> 
- 순서를 지키는 프로그램을 작성하는 것은 응용 프로그래머에게 달려 있다.
    - 따라서 Java에서는 `System.identityHashCode` 메서드를 제공한다.


<br/>

<br/>

## 💡 교착 상태 회피

> 교착 상태를 회피하는 다른 대안은 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하는 것이다.
> 
> - 각 스레드의 요청과 방출에 대한 완전한 순서를 파악하고 있다면, 우리는 각 요청에 대해서 가능한 미래의 교착 상태를 피하고자 스레드가 대기해야 하는지 여부를 결정할 수 있다.

<br/>

<br/>

- 이 방법을 사용하는 다양한 알고리즘들은 필요한 정보의 양과 유형에서 차이가 있다.
    - 가장 단순하고 제일 유용한 모델은 각 스레드가 **자신이 필요로 하는 각 유형의 자원마다 최대 수를 선언**하도록 하는 것이다.

<br/>

<br/>

- 교착 상태 회피 알고리즘은 시스템에 순환 대기 상황이 발생하지 않도록 자원 할당 상태를 검사한다.
    - **자원 할당 상태**는 가용 자원의 수, 할당된 자원의 수 그리고 스레드들의 최대 요구 수에 의해 정의된다.

<br/>

<br/>

### 안전 상태

- 시스템 상태가 안전(`safe`) 하다는 뜻
    - 시스템이 어떤 순서로든 스레드들이 요청하는 모든 자원을 교착 상태를 야기시키지 않고 차례로 모두 할당해 줄 수 있다는 것을 뜻한다.
    - 즉, 시스템이 **안전 순서**(`safe sequence`)를 찾을 수 있다면 시스템은 안전하다고 말한다.

<br/>

<br/>

- 시스템이 안전하다 = 교착 상태가 아니다.
    - 단, 시스템이 불안정하다고해서 반드시 교착 상태로 간다는 것은 아니다! (**갈 수도 있다는 것이다.**)

<br/>

<br/>

- 회피 알고리즘이 어떻게 교착 상태를 회피할 수 있을까?
    - 기본 원칙 : 시스템의 상태가 항상 안전 상태를 떠나지 않도록 고수하는 것이다! (최초의 상태는 안전)
    - 스레드들이 자원을 요청하면 시스템은 자원을 즉시 할당할 수 있는지 아니면 대기해야 하는지를 결정한다.
    - 자원을 즉시 승낙해주는 경우? → 시스템의 상태가 안전 상태에서 안전 상태로 옮길 때 뿐이다!

<br/>

<br/>

### 자원 할당 그래프 알고리즘

> 자원 할당 그래프의 변형을 사용할 수 있다.
> 
> - 요청 간선과 할당 간선에 추가하여, **예약 간선**이라는 새로운 타입의 간선을 추가하자. (점선으로 표시)

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/resource2.png" width = 500/>

- 스레드 T가 자원 R을 요청한다고 가정하자.
    - 요청 간선을 할당 간선으로 변환해도 자원 할당 그래프에 사이클이 형성되지 않을 때만 요청을 허용할 수 있다.
    - 우리가 사이클 탐지 알고리즘을 이용해 안전성을 검사한다는 사실에 유의하자!

<br/>

<br/>

### 은행원 알고리즘

> 은행원 알고리즘은 고객들이 현금을 찾으러 와도 일정한 순서에 의해 모든 고객의 요청을 다 들어줄 수 있어서 붙여진 이름이다.
> 

<br/>

<br/>


#### 🌱 책에 작성된 예시는 이해하기 힘들어 [블로그 포스팅](https://jhnyang.tistory.com/102)을 통해 이해하였습니다.

<br/>

<br/>

> 상황 설명
> 
> - 은행은 100 달러를 가지고 있고, 은행에서 돈을 빌리려는 고객은 3명이 있다.
> - 이 고객들은 각각 60, 40, 50 달러를 필요로 한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/bankers1.png" width = 500/>

<br/>

<br/>

> 우선 고객들에게 일부 금액만 빌려준 상태이다. (현재 은행에 남은 잔액은 20달러)
추가로 고객들이 원하는 금액은 각각 20, 30, 30 달러인데, 남은 금액들을 어떻게 처리할까?
> 

<br/>

<br/>

- 방법 1
    - 남은 20달러 중, 10달러를 고객 2에게 빌려주어 고객 2가 돈을 갚을 때까지 기다린다.
    - 이후 돈을 갚으면 50달러가 되니, 고객 1이나 고객 3을 도와줄 수 있다.
- 방법 2
    - 20 달러를 고객 3에게 빌려주고, 고객 3이 돈을 갚을 때까지 기다린다.

<br/>

<br/>

> 이 방식이 고객 1에게는 통하지 않음을 인지하자 → 은행이 돈을 받을 수 있는 상태를 **안전상태**라고 한다.
> 

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/bankers2.png" width = 500/>

<br/>

<br/>

> 갑자기 고객 1이 너무 급해서 35달러를 빌려줬다.
> 
- 이 경우, 은행에 남은 돈이 5달러이므로, 고객 1~3 모두에게 도움을 줄 수 없다!
- 이런 상태를 **불안전상태 또는 데드락 상태**라고 한다.
    - 즉, 은행원 알고리즘은 ‘최소한 고객 한명에게 대출해줄 금액은 항상 은행이 보유하고 있어야 한다’는 개념이 나온다.

<br/>

<br/>

> 은행원 알고리즘이 제대로 수행되기 위해서는 3가지가 필요하다.
> 
1. **Max** : 각 고객들이 얼마나 맥시멈으로 돈을 요구할지
2. **Allocated** : 각 고객들이 현재 빌린 돈이 얼마인지
3. **Available** : 은행이 보유한 돈이 얼마인지, 빌려줄 수 있는 돈이 얼마인지


<br/>

<br/>

## 💡 교착 상태 탐지

> 시스템이 교착 상태 예방이나 교착 상태 방지 알고리즘을 사용하지 않는다면, 교착 상태가 발생할 수 있다.
> 
- 교착 상태가 발생했는지 결정하기 위해 시스템의 상태를 검사하는 알고리즘
- 교착 상태로부터 회복하는 알고리즘

<br/>

<br/>

### 각 자원 유형이 한 개씩 있는 경우

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/wait-graph.png" width = 500/>

- 모든 자원이 한 개의 인스턴스만 있다면, **대기 그래프**를 사용해 교착 상태 탐지 알고리즘을 정의할 수 있다.
    - 앞에서와 마찬가지로 사이클을 포함하는 경우에만 교착 상태가 존재한다.
    - 교착 상태를 탐지하기 위해 시스템은 대기 그래프를 ***유지***할 필요가 있고, 주기적으로 그래프에서 사이클을 ***탐지하는 알고리즘을 호출***한다.

<br/>

<br/>

### 각 유형의 자원을 여러 개 가진 경우

- 이 알고리즘은 은행원 알고리즘과 마찬가지로 시시각각 그 내용이 달라지는 자료구조를 사용한다.
    - Available : 각 종류의 자원이 현재 몇 개가 가용한지를 나타내는 벡터
    - Allocation : 각 스레드에 현재 할당된 자원의 개수를 나타내는 행렬
    - Request : 각 스레드가 현재 요청중인 자원의 개수를 나타내는 행렬

<br/>

<br/>

### 탐지 알고리즘 사용

> 탐지 알고리즘은 언제 돌리는가? 에 대한 대답은 두 가지 관점에 달려있다.
> 
> 1. 교착 상태가 얼마나 자주 발생하는가?
> 2. 교착 상태가 이렁나면 통상 몇 개의 스레드가 거기에 연루되는가?

<br/>

<br/>

> 교착 상태가 발생하는 시점은 어떤 스레드가 자원을 요청했는데 그것이 만족되지 못하는 시점이다!
> 
- 때에 따라서는 바로 이 요청이 여러 스레드의 요청을 연결해 둥그런 고리 모양의 사슬을 완성하는 요청일 수도 있다.
- 한 극단적인 방법은 스레드의 요청이 즉시 만족하지 않을 때마다 탐지 알고리즘을 돌리는 방법이다.

<br/>

<br/>

> 물론 자원을 요청할 때마다 탐지 알고리즘을 호출하면 오버헤드가 너무 크게 된다.
> 
- 오버헤드를 줄이는 간단한 대안은 지정된 시간 간격으로 or CPU 이용률이 40% 이하로 떨어질 때마다 호출하는 것이다.

<br/>

<br/>

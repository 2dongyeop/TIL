# 교착 상태

> ***교착 상태란?***
> 
> - *프로세스 집합 내의 모든 프로세스가 그 집합의 다른 프로세스에 의해서만 일어날 수 있는 이벤트를 기다리는 상황을 말한다.*

<br/>

<br/>

## 💡 시스템 모델 _System Model

> 이 장에서는 커널 자원에 관해 설명하지만, 스레드는 다른 프로세스의 자원을 사용할 수 있으며 이러한 자원 사용으로 인해 교착상태가 발생할 수 있다!
이러한 교착 상태는 커널의 문제가 아니므로 여기에서는 설명하지 않는다.


<br/>

<br/>


> 자원 사용 흐름
> 
- 스레드는 자원을 사용하기 전에 반드시 요청을 해야한다.
    - 이때, 스레드는 지정된 태스크를 수행하기 위해 필요한 만큼의 자원을 요청할 수 있다.
- 사용 후에는 반드시 방출해야 한다.

<br/>

<br/>

> 프로세스의 자원 사용
> 
1. **요청** : 스레드는 자원을 요청한다.
    1. 요청이 즉시 허용되지 않으면 → 자원을 얻을 때까지 대기해야 한다.
2. **사용** : 스레드는 자원에 대해 작업을 수행할 수 있다.
3. **방출** : 스레드가 자원을 방출한다.

<br/>

<br/>

> 위에서 나온 자원의 요청과 방출은 시스템 콜이다.
> 
- 스레드가 (커널이 관리하는) 자원을 사용할 때마다 OS는 자원을 요청했는지와 할당받았는지를 확인한다.
- 또한 시스템 테이블이 각 자원이 가용 상태인지, (어느 스레드에) 할당되었는지를 기록한다.


<br/>

<br/>

## 💡 다중 스레드 응용에서의 교착 상태 _Deadlock in Multithreaded Applications

> POSIX mutex 락을 사용해 다중 스레드 Pthread 프로그램에서 어떻게 교착 상태가 발생할 수 있는지 알아보자.
> 

- 두 mutex 락이 있다면, 아래와 같은 코드 예제에 의해 생성되고 초기화된다.
    
    ```cpp
    pthread_mutex_t first_mutex;
    pthread_mutex_t second_mutex;
    
    pthread_mutex_init(&first_mutex, NULL);
    pthread_mutex_init(&second_mutex, NULL);
    ```
        
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/deadlock-example.png" width = 500/>
    

<br/>

<br/>

- 위 예제에서 thread_one이 first_mutex 락을 획득하고, thread_two가 second_mutex를 획득하면?
    - 교착 상태가 가능하다.
    - 단, thread_two가 락을 획득하려고 시도하기 전에 thread_one이 뮤텍스 락 두개를 방출한다면?
        → 교착 상태는 발생하지 않는다!
        

<br/>

<br/>

### 라이브락

> 라이브락(`livelock`)이란?
> 
> - 또 다른 형태의 라이브니스 장애로, 교착 상태와 유사하다.
> - 둘 다 두 개  이상의 스레드가 진행되는 것을 방해하지만 진행할 수 없는 이유가 서로 다르다.
> - 교착상태 : 어떤 스레드 집합의 모든 스레드가 이벤트를 기다리면서 봉쇄된다.
> - 라이브락 : 스레드가 실패한 행동을 계속해서 시도할 때 발생한다.
>     - ex) 복도에서 한사람은 오른쪽으로 움직이고, 반대편 사람은 왼쪽으로 움직여 서로 방해하는 상태

<br/>

<br/>

- 라이브락은 일반적으로 스레드가 실패한 작업을 동시에 재시도할 때 발생한다.
    - 따라서 일반적으로 각 스레드가 실패한 행동을 재시도하는 시간을 무작위로 정하면 회피할 수 있다.
    - 이 방법은 정확히 네트워크 충돌이 발생할 때 Ethernet 네트워크가 취하는 접근법이다.
    - 충돌이 발생한 직후에 퍀시을 재전송하려고 시도하는 대신, 충돌한 호스트는 재전송을 시도하기 전에 임의의 시간 동안 **한 발 뒤로 물러난다.**


<br/>

<br/>

## 💡 교착 상태 특성 _Deadlock Characterization

> 교착 상태를 특징 짓는 조건을 살펴보자.
> 

<br/>

<br/>

### 필요 조건들

교착 상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생할 수 있다.

1. **상호 배제(mutual exclusion)**
    1. 최소한 하나의 자원이 비공유 모드로 점유되어야 한다.
    2. 비공유 모드에서는 한 번에 한 스레드만이 그 자원을 사용할 수 있다.
    3. 다른 스레드가 그 자원을 요청하면 → 요청 스레드는 자원이 방출될 때까지 지연되어야 한다.

    <br/>

1. **점유하며 대기(hold-and-wait)**
    1. 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.

    <br/>

1. **비선점 (no-preemption)**
    1. 자원들을 선점할 수 없어야 한다.
    2. 즉, 자원이 강제적으로 방출될 수 없고, 점유하고 있는 스레드가 태스크를 종료한 후에 그 스레드에 의해 자발적으로만 방출될 수 있다.

    <br/>

1. **순환 대기(circular wait)**
    1. 대기하고 있는 스레드의 집합{T0, T1, … , Tn} 에서 T0은 T1이 점유한 자원을 대기하고, … , Tn은 T0가 점유한 자원을 대기한다.

<br/>

<br/>

### 자원 할당그래프

> 교착 상태는 시스템 자원 할당 그래프라고 하는 방향 그래프로 더욱 정확하게 기술할 수 있다.
> 

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/resource-allocation-graph.png" width = 500/>

- 위 그림에서 방향 간선 T → R 은 **요청 간선**이고, 방향 간선 R → T는 **할당 간선**이다.
- 자원 유형 R이 한 개 이상의 인스턴스를 가질 때 : 각 인스턴스를 사각형 내의 하나의 점으로 표시
- 할당 간선은 반드시 사각형 내의 하나의 점을 지정해야 하고, 요청 간선은 사각형 R만을 가리킨다.

<br/>

<br/>

> 그래프가 사이클을 포함하지 않으면 시스탬 내 어느 스레드도 교착 상태가 아님을 보일 수 있다.
>
> 사이클이 없다면? → 교착 상태가 아니다.
>
> 사이클이 있다면? → 교착 상태일 수도 있고 아닐 수도 있다.
>
# 가상 머신

## 💡 개요

> *가상머신의 기본 개념*
>
> : 단일 컴퓨터의 하드웨어를 여러 가지 실행 환경으로 추상화하여 개발 환경이 자신의 개인용 컴퓨터에서 실행되고 있다는 착각을 불러 일으키는 것!

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/18-1.png" width = 500/>

<br/>

<br/>

가상 머신의 구현은 여러 구성 요소를 포함한다.

- 기반에는 가상 머신을 실행하는 기본 하드웨어 시스템인 **호스트**가 위치한다.
- 가상 머신 관리자(**VMM**, 혹은 **하이퍼바이저**)는 호스트와 동일한 인터페이스를 제공한다.
    - → 이로써 가상 머신을 생성하고, 실행한다.
- 각 **게스트** 프로세스에는 호스트의 가상 복사본이 제공된다. → 실제로 운영체제이다!

<br/>

<br/>

VMM의 구현은 매우 다양하다!

- 펌웨어를 통해 가상 머신 생성 및 관리를 지원하는 하드웨어 기반 솔루션
    - → 이러한 VMM은 메인 프레임과 중대형 서버에서 일반적으로 사용, **유형 0 하이퍼바이저**
- VMware ESX 등등을 포함하여 가상화를 제공하기 위해 구축된 운영체제와 유사한 소프트웨어
    - → **유형 1 하이퍼바이저**
- 표준 운영체제에서 실행되지만 게스트 운영체제에 VMM 기능을 제공하는 응용 프로그램
    - → **유형 2 하이퍼바이저**
- **반 가상화**
    - → 게스트 운영체제를 VMM과 협력하여 성능을 최적화하여 수정하는 기술
- **프로그래밍 환경 가상화**
    - → VMM이 실제 하드웨어를 가상화하는 것이 아니라 최적화된 가상 시스템을 생성한다.
- **에뮬레이터**
    - → 한 하드웨어 환경용으로 작성된 응용 프로그램이 다른 유형의 CPU 유형과 같이 매우 다른 하드웨어 환경에서 실행될 수 있도록 한다.
- **응용 프로그램 격리**
    - → 가상화는 아니지만 운영체제에서 응용 프로그램을 격리하여 가상화와 유사한 기능을 제공


<br/>

<br/>

# 💡 역사

> 가상 머신은 1972년에 IBM 메인프레임에서 처음으로 상용화되었다.
> 

IBM VM / 370은 메인프레임을 여러 가상 머신으로 나누어 각각 고유한 운영체제를 실행하였다.

이때 VM 접근 방식의 주요 어려움은 디스크와 관련이 있다.

(실제 머신에 3개의 디스크 드라이브가 있지만 7개의 가상 머신을 지원하려했다고 가정)

→ 이 경우, 분명히 각 가상 머신에 디스크 드라이브를 할당할 수 없다.

<br/>

<br/>

> 해결책 : IBM의 VM 운영체제에서 ***minidisk***라고 하는 가상 디스크를 제공하기
> 

minidisk는 크기를 제외하고 모든 면에서 시스템의 하드 디스크와 동일했다.

시스템은 물리 디스크에 필요한 minidisk 수만큼 트랙을 할당하여 각 미니 디스크를 구현했다.

<br/>

*→ 이후, 이 가상화는 VM 운영체제 영역에만 남았지만, 그래도 공식적인 가상화 정의는 시스템 요구 사항과 기능 목표를 설정하는 데 도움이 되었다!*

<br/>

> 가상화 요구 사항
> 
- 충실도(`fidelity`)
    - → VMM은 원래 컴퓨터와 본질적으로 동일한 프로그램을 위한 환경을 제공한다.
- 성능(`performance`)
    - → 해당 환경에서 실행되는 프로그램은 성능이 약간만 저하된다.
- 안전(`safety`)
    - → VMM은 시스템 자원을 완벽하게 관리한다.


<br/>

<br/>

# 💡 빌딩 블록

> 가상화 기능은 CPU에서 제공하는 기능에 따라 다르다.
VMM은 트랩-앤-에뮬레이트 및 이진 변환과 같은 여러 기술을 사용해 가상화를 구현한다.
> 

<br/>

<br/>

> 가상 CPU(**VCPU**)는 코드를 실행하지 않는다.
> 

오히려 게스트 컴퓨터가 믿고 있는 CPU의 상태를 나타낸다.

각 게스트에 대해 VMM은 해당 게스트의 현재 CPU 상태를 나타내는 VCPU를 유지관리한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/18-2.png" width = 500/>

### *Trap-and-Emulate*

가상 시스템에서도 가상 사용자 모드에서 가상 커널 모드로의 변환이 일어난다!

<br/>

<br/>

> 절차
> 
1. 게스트의 커널이 특권 명령을 실행하려고 하면 오류이며, 실제 시스템의 VMM에 트랩을 발생시킨다.
2. VMM은 제어를 얻게 되고 게스트의 입장에서 게스트 커널이 시도한 작업을 시랳ㅇ한다.
3. 제어를 가상 머신으로 반환한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/18-3.png" width = 500/>

### *이진 변환*

> 일부 CPU는 특권 및 비 권한 명령을 완전히 분리하지 않는다.
가상화 구현자에게는 불행하게도 Intel x86 CPU 제품군이 그 중 하나다.
이 칩은 여러 세대에 걸쳐 이전 버전과의 호환성을 유지하였는데, 여러 세대에 걸쳐 가상화를 더 쉽게 만들 수 있는 변화를 막아왔다!
> 
>
>이러한 문제는 **이진 변환** 기술의 구현으로 해결되었다.

<br/>

<br/>

> 기본 단계
> 
1. 게스트 VCPU가 사용자 모드인 경우 게스트는 물리적 CPU에서 명령어를 그대로 실행할 수 있다.
2. 게스트 VCPU가 커널 모드인 경우 게스트는 자신이 커널 모드에서 실행되고 있다고 생각한다.
    1. VMM은 게스트의 프로그램 카운터를 기반으로 게스트가 실행할 다음 몇 가지 명령어를 읽어 게스트가 가상 커널 모드에서 실행되는 모든 명령어를 검사한다.
    2. 특수 명령어 이외의 명령어는 그대로 실행된다.
    3. VCPU의 플래그 변경과 같은 특수 명령어는 동등한 작업을 수행하는 새로운 명령어 집합으로 변환된다.

<br/>

<br/>

> 가상화의 또 다른 문제 → 메모리 관리! (특히 페이지 테이블..)
> 

가장 일반적인 방법은 **중첩 페이지 테이블(NPTs)**를 사용하는 것이다.

다만, 불행하게도 NPT를 사용하면 TLB 미스가 증가할 수 있어, 합리적인 성능을 달성하기 위해 다른 많은 복잡성을 고려해야 한다..

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/18-4.png" width = 500/>

### *하드웨어 지원*

> 일정 수준의 하드웨어 지원이 없으면 가상화는 불가능하다.
Intel x86 CPU 제품군에서 Intel은 2005년부터 새로운 세대의 가상화 지원(**VT-x** 명령어)를 추가했다!
따라서 이제 이진 변환은 필요없게 되었다.
>

<br/>

<br/>

# 💡 VM 유형 및 구현

### 가상 머신 수명 주기

하이퍼바이저 유형이 무엇이든 가상 시스템을 생성할 때 생성자는 VMM에 특정 매개 변수를 제공한다.

이러한 매개 변수에는 일반적으로 게스트를 만들 때 고려할 정보들이 포함된다.

<br/>

<br/>

> 또한 가상 머신이 더 이상 필요하지 않으면 삭제할 수 있다.
> 

이 경우 VMM은 먼저 사용된 디스크 공간을 비운 다음 가상 머신과 관련된 구성을 제거하여 가상 머신을 제거한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/18-5.png" width = 500/>

### 유형 0 하이퍼바이저

유형 0 하이퍼바이저는 “파티션”과 “도메인” 등을 포함한 여러 이름으로 수년간 존재해왔다.

그것은 하드웨어적인 특징이며 그것 자체의 긍정적인 측면과 부정적인 측면이 있다.

<br/>

<br/>

> 하이퍼바이저는 공유 액세스를 관리하거나 모든 장치를 **제어 파티션**에 부여한다.
> 

제어 파티션에서 게스트 운영체제제는 디먼을 통해 다른 게스트에게 서비스를 제공하고 하이퍼바이저는 I/O 요청을 적절하게 라우팅한다.

<br/>

<br/>

*→ 유형 0 가상화는 raw 하드웨어 실행에 매우 가깝기 때문에 여기서 논의된 다른 방법과 별도로 고려해야 한다.*

<br/>

<br/>

### 유형 1 하이퍼바이저

유형 1 하이퍼바이저는 일반적으로 회사 데이터 센터에서 발견되며 어떤 의미에서는 “데이터 센터 운영체제”다.

이들은 하드웨어에서 네이티브하게 실행되는 특수 목적 운영체제이지만, 프로그램 실행을 위한 시스템 콜 및 기타 인터페이스를 제공하는 것이 아니라 게스트 운영체제를 생성, 실행 및 관리한다.

<br/>

<br/>

> 데이터 센터 관리자는 유형 1 하이퍼바이저를 사용해 새롭고 정교한 방식으로 운영체제 및 응용 프로그램을 제어하고 관리할 수 있다.
> 

→ 이때 중요한 이점은 더 적은 수의 시스템으로 더 많은 운영체제와 응용 프로그램을 통합할 수 있다는 것!

<br/>

<br/>

### 유형 2 하이퍼바이저

유형 2 하이퍼바이저는 가상 머신 관리자에 대한 운영체제의 개입이 거의 없어 덜 흥미롭다.

<br/>

<br/>

> 유형 2 하이퍼바이저는 일부 다른 유형에는 없는 제한이 있다.
> 

ex) 최신 CPU의 많은 하드웨어 지원 기능에 접근하려면 사용자는 관리자 접근이 필요!

→ 이때 추가 권한 없이 표준 사용자가 VMM을 실행하는 경우 VMM은 이러한 기능을 활용할 수 없다.

→ 이 제한과 게스트 운영체제 뿐만 아니라 범용 운영체제를 실행하는 데 따르는 추가 오버헤드로 인해 유형 2 하이퍼바이저는 유형 0 또는 유형 1보다 전체적인 성능이 떨어지는 경향이 있다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/18-6.png" width = 500/>

### 반 가상화

Xen VMM은 호스트 시스템뿐만 아니라 게스트의 성능을 최적화하는 몇 가지 기술을 구현하여 반 가상화의 리더가 되었다.

→ 게스트와 VMM 사이의 효율적인 I/O 뿐만 아니라 우수한 I/O 관련 통신을 허용하고 깨끗하고 간단한 장치 추상화를 제공하였다.

<br/>

<br/>

> Xen은 메모리 관리를 위해 중첩된 페이지 테이블을 구현하지 않았다.
> 

오히려 각 게스트에는 고유한 페이지 테이블 집합이 있으며 읽기 전용으로 설저오디었다.

Xen은 페이지 테이블 변경이 필요할 때 게스트가 하이퍼바이저 VMM으로 **하이퍼콜**을 하도록 하였다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/18-7.png" width = 500/>

### 응용 프로그램 격리

> 때에 따라 가상화의 목표는 응용 프로그램을 분리하고 성능 및 자원 사용을 관리하며 시작, 중지, 이동 및 관리하기 쉬운 방법을 생성하는 방법을 제공하는 것이다.
이러한 경우 본격적인 가상화가 필요하지 않다. 대신 응용 프로그램 격리를 사용할 수 있다.
> 

<br/>

<br/>

위 그림을 보면 버전 10부터 Oracle Solaris에는 운영체제와 응용 프로그램 간에 가상 계층을 만드는 **컨테이너** 또는 **zone**이 포함되었다.

→ 이 시스템에서는 하나의 커널만 설치되며 하드웨어는 가상화되지 않는다!

→ 오히려 운영체제와 해당 장치는 가상화되어 zone 내의 프로세스에 자신이 시스템의 유일한 프로세스라는 인상을 준다.

<br/>

<br/>

> 컨테이너는 자동화 및 관리가 용이하며 **docker**나 **Kubernetes** 같은 조정 도구로 이어진다.
> 

조정 도구는 시스템과 서비스를 자동화하고 조정하는 수단이다.


<br/>

<br/>

# 💡 사례

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/18-9.png" width = 500/>

### VMware

VMware Workstation은 Intel x86 및 호환 가능한 하드웨어를 격리된 가상 머신으로 추상화하는 응용 프로그램이다. Windows나 Linux와 같은 호스트 운영체제에서 응용 프로그램으로 실행된다!

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/18-10.png" width = 500/>

### Java 가상 머신

- JVM은 추상 컴퓨터의 명세다.
- 클래스 로더와 아키텍처 중립 바이트코드를 실행하는 Java 인터프리터로 구성된다.
- 또한 JVM은 GC를 이용해 메모리를 자동으로 관리한다.
# 대용량 저장장치 구조
> 최신 컴퓨터 시스템에서 가장 일반적이고 중요한 저장장치는 HDD와 NVM 장치이다.
- HDD : 하드 디스크 드라이브, NVM : 비휘발성 메모리 장치
> 

<br/>

<br/>

## 💡 대용량 저장장치 구조의 개관

### 하드 디스크 드라이브

> 개념적으로 HDD는 비교적 단순하다.
> 

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/11-1.png" width = 500/>

- 각 디스크의 **플래터**(platter)는 CD처럼 생긴 원형 평판 모양이다.
    - 읽기-쓰기 헤드는 모든 플래터의 각 표면 바로 위에서 “움직인다”.
    - 헤드는 모든 헤드를 한꺼번에 이동시키는 **디스크 암**에 부착되어 있다.

<br/>

<br/>

- 플래터의 표면은 원형인 **트랙**(track)으로 논리적으로 나누어져 있고,
    - 이는 다시 **섹터**(sector)로 나눠져있다.
    - 동일한 암 위치에 있는 트랙의 집합은 하나의 **실린더**(cylinder)를 형성한다.

<br/>

<br/>

> 디스크 드라이브 모터는 고속으로 회전한다.
> 
- 대부분의 드라이브는 **RPM**(분당 회전수) 단위로 표현된다. (초당 60~250회)
    - 회전 속도는 전송 속도와 관련이 있다.
    - 전송 속도 : 드라이브와 컴퓨터 간의 데이터 흐름의 속도

<br/>

<br/>

- 또 다른 성능 측면 : **위치 지정 시간** (또는 **임의 액세스 시간**)
    - 이는 두 부분으로 구성된다.
    - **탐색 시간** : 디스크 암을 원하는 실린더로 이동하는 데 필요한 시간
    - **회전 지연 시간** : 원하는 섹터가 디스크 헤드 위치까지 회전하는 데 걸리는 시간

<br/>

<br/>

> **헤드 충돌**
> 
- 발생 원인
    - 디스크 헤드는 공기와 같은 다른 가스의 매우 얇은 쿠션 위를 비행 → 헤드가 디스크 표면에 닿을 위험!
    - 디스크 플래터는 얇은 보호 층으로 코팅되어 있지만, 헤드는 때때로 자기 표면을 손상한다.

<br/>

- 헤드 충돌은 일반적으로 수리할 수 없다.

<br/>

<br/>

## 비휘발성 메모리 장치

> 비휘발성 메모리(NVM) 장치의 중요성이 증가하고 있다. → NVM 장치는 기계식이 아닌 전기식!
> 

<br/>

<br/>

### 비휘발성 메모리 장치 개요

- 플래시 메모리 기반 NVM은 디스크 드라이브와 유사한 컨테이너에서 자주 사용된다.
    - 이 경우를 **SSD(solid-state disk)**라고 한다.
    - 다른 경우에는 **USB 드라이브** 또는 DRAM 스틱의 형태를 취한다.

<br/>

<br/>

> NVM 장치는 움직이는 부품이 없다. 
→ HDD보다 안정성이 높고, 탐색 시간이나 회전 지연이 없어 빠를 수 있다.
> 
- 단점
    - 기존 하드 디스크보다 가격이 비싸다.
    - 더 큰 하드 디스크보다 용량이 적다.
    - → 시간이 지남에 따라 NVM 장치의 용량 증가와 가격 하락으로 사용량이 증가하는 중!

<br/>

<br/>

> NAND 반도체는 일부 특성 때문에 자체적인 저장 및 신뢰성 문제를 가진다.
> 
- ex) 섹터와 유사한 “페이지” 단위로 읽고 쓸 수 있지만, 데이터를 덮어쓸 수는 없다.
    - 덮어 쓰려면 ? → NAND 셀을 먼저 지워야 함!
    - 삭제는 여러 페이지로 구성된 “블록” 단위로 이루어지며, 읽기 or 쓰기보다 시간이 더 걸린다.

<br/>

<br/>

> NVM 플래시 장치
> 
- 각 다이에 대한 많은 데이터 경로가 존재하는 여러 개의 다이로 이루어진다.
    - ***→ 연산이 병렬로 수행될 수 있다는 것이 문제 해결의 도움이 됨!***

<br/>

<br/>

> NAND NVM 수명은 연 단위가 아니라 **DWPD(Drive Writes Per Day)**로 측정된다.
> 
- 이는 [쓰기 마모로 인해 and 움직이는 부품이 없기] 때문이다!
    - → 이 측정 값은 드라이브 장애가 발생하기 전에 
    드라이브 용량에 해당하는 데이터를 하루에 몇 번 쓸 수 있는지를 나타낸다.

<br/>

<br/>

### NAND 플래시 컨트롤러 알고리즘

> NAND 반도체는 한 번 쓴 후에 덮어쓸 수 없다. → 일반적으로 유효하지 않은 데이터를 포함!
> 
- 한 번 기록된 후 나중에 다시 기록된 파일 시스템을 예시로 보자.
    - 다시 기록되기 전에 삭제가 발생하지 않았다면?
    - 처음 기록된 페이지 : 이전 데이터가 저장됨 → 현재는 유효하지 않은 데이터
    - 두번 째 페이지 : 현재의 올바른 버전의 블록이 저장되어 있음!

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/11-2.png" width = 500/>

> 유효한 데이터를 포함하는 논리 블록을 추적하기 위해 컨트롤러는 **플래시 변환 계층(FTL)**을 유지한다.
> 
- 이 테이블은 현재 유효한 논리 블록을 포함하는 물리 페이지를 매핑!
    - + 물리 블록 상태, 즉 유효하지 않은 페이지만 포함하고 있고, 따라서 삭제할 수 있는 블록을 추적한다.

<br/>

<br/>

- 보류 중인 “쓰기 요청”이 있는 전체 SSD를 고려하자.
    - SSD가 가득 찬 상태 → 지우기가 발생할 때까지 기다린 다음 쓰기가 수행될 수 있다.
    - 만약 개발 페이지에 유효하지 않은 데이터가 있으면? → 여전히 사용 가능한 공간이 있을 수 있음!
        - 이 경우 **가비지 수집**이 발생할 수 있다.

<br/>

<br/>

- **가비지 수집**이란?
    - 유효한 데이터를 다른 위치로 복사하여 지울 수 있는 블록을 비운 다음, 쓰기를 받아들인다.

<br/>

<br/>

> 가비지 수집은 유효한 데이터를 어디에 저장해야 할까?
> 
- *→ 이 문제를 해결하고, 쓰기 성능 향상을 위해 NVM 장치는 **과잉 공급**을 사용!*
    - 종종 전체 용량의 20%를 언제나 쓸 수 있도록 따로 준비해놓는다.

<br/>

<br/>

> 과잉 공급 공간은 **마모 평준화(wear leveling)**에도 도움이 된다.
> 
- 다른 블록에 비해 일부 블록만 반복적으로 지워주면?
    - 자주 지워지는 블록은 다른 블록보다 빨리 마모됨 & 모든 블록이 동시에 마모되는 경우보다 수명이 짧음

<br/>

<br/>

- 따라서 컨트롤러는 삭제 횟수가 적은 블록에 데이터를 배치하여 후속 삭제가 일어나도록 한다. 
→ 전체 장치의 마모 수준을 평준화!

<br/>

<br/>

> NVM 장치는 데이터 보호 측면에서 오류 수정 코드를 제공한다. (HDD와 마찬가지)
> 
- 동작 방식
    - 기록될 때 계산되어 데이터와 함께 저장된다.
    - 읽을 때 데이터와 함께 읽어 오류를 감지하고 가능한 경우 오류를 수정한다.
    - 페이지에 수정 가능한 오류가 자주 발생하는 경우 
    → 페이지를 불량으로 표시해 후속 쓰기에 사용되지 않게 함!

<br/>

<br/>

## 휘발성 메모리

> 대용량 저장장치 구조에서 휘발성 메모리에 대해 논의하는 것이 이상할 수 있지만,
DRAM이 대용량 저장장치로 자주 사용되므로 합리적이다.
> 

<br/>

<br/>

- 특히 RAM 드라이브는 보조저장장치처럼 작동한다.
    - 다만 시스템 DRAM의 한 영역을 할당하여 저장장치인 것처럼 장치 드라이브에 의해 생성된다.

<br/>

<br/>

> 컴퓨터에는 이미 버퍼링 및 캐싱을 하는데, 이미 데이터 저장장치로 DRAM을 사용하는 목적
> 
- 결국 DRAM은 휘발성이며, RAM 드라이브의 데이터는 시스템 크래시, 종료 후에는 지속되지 않는다.
    - 캐시와 버퍼 → 프로그래머나 운영체제에 의해 할당되는 반면,
    - RAM 드라이브 → 사용자와 프로그래머가 표준 파일 연산으로  데이터를 메모리에 임시로 보관 가능!
        - ex) Linux의 `/dev/ram` , macOS의 `dickutil` 명령어

<br/>

<br/>

> RAM 드라이브는 고속 임시 저장 공간으로도 유용하다.
> 
- DRAM은 NVM보다 훨씬 빠르다!
- RAM 드라이브에 대한 I/O 작업은 파일과 내용을 생성, 읽기, 쓰기 및 삭제하는 가장 빠른 방법임

<br/>

<br/>

## 보조저장장치 연결 방법

> 보조저장장치는 시스템 버스 또는 **I/O 버스**에 의해 컴퓨터에 연결된다.
> 
- 버스의 종류 : 가장 일반적인 연결 방법은 SATA
- `ATA(advancde technology attachment)`
- `SAS(serial attached SCSI)`
- `USB(universal serial bus)`
- `SATA(serial ATA)`
- `eSATA`
- `FC(fivre channel)`

<br/>

<br/>

> **NVMe(NVM express)**란?
> 
- NVM 장치는 HDD보다 훨씬 빠르다.
    - 산업계에서는 NVM만을 위한 인터페이스를 만듬!
    - 장치를 시스템 PCI 버스에 직접 연결하여 다른 연결 방법과 비교해 처리량을 높이고 지연시간을 줄인다.

<br/>

<br/>

> 버스에서의 데이터 전송은 **컨트롤러(호스트 버스 어댑터(HBA))**라는 특수 전자 프로세서에 의해 수행된다.
> 
- **호스트 컨트롤러**
    - 버스의 컴퓨터 쪽에 있는 컨트롤러

- **장치 컨트롤러**
    - 각 저장장치에 내장된 컨트롤러

<br/>

<br/>

- 동작 방식
    1. 대용량 저장장치 I/O 작업을 수행하기 위해 컴퓨터는 명령을 호스트 컨트롤러에 놓는다.
    2. 호스트 컨트롤러는 메시지를 통해 명령을 장치 컨트롤러에 전송, 컨트롤러는 하드웨어를 작동하여 명령을 수행

<br/>

<br/>

## 주소 매핑

> 저장 장치는 **논리 블록**의 커다란 1차원 배열처럼 주소가 매겨진다.
> 
- 논리 블록이란?
    - 가장 작은 전송 단위
    - 각 논리 블록의 1차원 배열은 물리 섹터 또는 반도체 페이지로 매핑된다.

<br/>

<br/>

> HDD에서 이 매핑을 사용하면 적어도 이론적으로는 아래 동작이 가능하다.
> 
- 논리 블록 번호를 실린더 번호, 해당 실린더 내의 트랙 번호 및 해당 트랙 내의 섹터 번호로 구성된 구식 디스크 주소로 변환!
- 단, 세 가지 이유로 이 변환을 수행하는 것이 어렵다.
    1. 대부분의 드라이브에는 결함이 있는 섹터가 잇지만 매핑은 드라이브의 다른 곳에 있는 예비 섹터로 대체하여 이를 숨긴다.
    2. 트랙당 섹터 수는 일부 드라이브에서 일정하지 않다.
    3. 디스크 제조업체는 **LBA**(논리 블록 주소)와 물리 주소 간의 매핑을 내부적으로 관리하므로 현재 드라이브에서는 LBA와 물리적 섹터 간에 관계가 거의 없다.

<br/>

<br/>

→ 위에서 두 번째 이유를 좀 더 살펴보자.

<br/>

<br/>

> **고정 선형 속도(CLV)**를 사용하는 장치에서는 트랙당 비트의 밀도가 일정하다.
> 
- 트랙이 디스크의 중심으로부터 멀어질수록 트랙의 길이는 길어진다. → 더 많은 섹터를 가지게 됨.
    - 따라서, 현대의 디스크는 실린더들을 몇 개의 구역으로 나눈다.
    - 트랙당 섹터의 수는 한 구역 안에서는 일정하지만, 구역 간에는 차이가 나게 됨!

<br/>

<br/>

- 해결안
    - 디스크의 회전 속도를 일정하게 유지하고 이 경우 안쪽 트랙에서 바깥쪽 트랙으로 갈수록 비트의 밀도를 줄여 데이터 비율을 일정하게 유지하기.
        - → 이 방법은 하드 디스크에 사용되며 **고정 각 속도(CAV)**로 알려져 있다.


<br/>

<br/>

# 💡 디스크 스케줄링

> 운영체제의 책임 중 하나는 효율적인 하드웨어 사용이다.
**HDD의 경우 이 책임은 접근 시간을 최소화하고, 전송 대역폭을 최대화하는 것을 수반한다.**
> 

<br/>

<br/>

> HDD 또는 플래터를 사용하는 기계식 저장장치의 경우 접근 시간은 두 가지 요소로 이루어진다.
> 
- **탐색 시간(seek time)**
    - 장치 암이 헤드를 해당 실린더로 움직이는 데 걸리는 시간

<br/>

- **회전 지연(rotational latency)**
    - 플래터가 원하는 섹터를 헤드 위치까지 회전시키는 데 소요되는 추가적인 시간

<br/>

<br/>

> 프로세스가 입출력을 해야 할 때마다 운영체제에 시스템 콜을 한다.
> 
- 이 호출에는 여러 가지의 인수가 주어진다.
    - 이 작업이 입력 또는 출력인지의 여부
    - 연산이 수행될 파일을 가리키는 열린 파일 핸들
    - 전송을 위한 메모리 주소
    - 전송할 데이터의 양

<br/>

<br/>

## 선입 선처리 스케줄링

- 디스크 스케줄링의 가장 간단한 형태로,
    - 본질적으로는 공평해 보이지만 빠른 서비스를 제공하지는 못한다.

<br/>

<br/>

- 동작 예시
    - 문제점 : 122 - 14 - 124로 이동
    - 122 , 124, 14 순으로 처리했으면 훨씬 빠르다.

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/11-3.png" width = 500/>

<br/>

<br/>

## SCAN 스케줄링

- 입출력 헤드가 디스크의 한 끝과 다른 끝 사이를 계속해서 왕복하는 형태이다.
    - **엘레베이터 알고리즘**이라고도 불림!

<br/>

<br/>

- 동작 방식
    - 현재 처리중인 곳의 반대쪽에 많은 요청이 몰릴 수 있다.

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/11-4.png" width = 500/>

<br/>

<br/>

## C-SCAN 스케줄링

- **Circular-SCAN** 스케줄링은 각 요청에 걸리는 시간을 좀 더 균등하게 하기 위한 SCAN의 변형이다.
    - 기존 동작 방식은 같지만, 한쪽 끝에 다다르면 처음 시작했던 자리로 다시 돌아가 서비스를 시작한다.

<br/>

<br/>

- 동작 방식

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/11-5.png" width = 500/>

<br/>

<br/>

## 디스크 스케줄링 알고리즘의 선택

> 디스크 스케줄링 알고리즘 중 가장 좋은 것을 어떻게 선택할까?
> 
- 디스크를 많이 사용하는 경우 → SCAN or C-SCANdl wjrekd!
- 어느 스케줄링 알고리즘을 사용하든 *성능은 요청의 형태와 수에 좌우*된다.

<br/>

<br/>

> SCAN 및 C-SCAN은 기아 문제를 일으킬 가능성이 작다.
> 
- 때문에 디스크에 많은 부하를 주는 시스템의 성능을 향상시킨다!
    - 다만, 기아가 계속될 순 있기 때문에 **마감시간(deadline) 스케줄러**가 등장했다.


<br/>

<br/>

# 💡 NVM 스케줄링

> NVM 장치에는 이동 디스크 헤드가 없으며, 일반적으로 간단한 FCFS 정책을 사용한다.
> 
- Linux NOOP 스케줄러는 FCFS 정책을 사용하지만, 인접한 요청을 병합하도록 수정한다.
    - NVM 장치의 작동을 보면, 읽기 서비스에 필요한 시간을 일정하지만 
    플래시 메모리의 속성 때문에 쓰기 서비스 시간은 일정하지 않다는 것을 알 수 있다.

<br/>

<br/>

> I/O는 순차적으로 또는 무작위로 발생할 수 있다.
> 
- 읽거나 쓸 데이터가 읽기/쓰기 헤드 근처에 있다. → *순차적 액세스가 최적!*
- 초당 입/출력 연산 수(**IOPS**)로 측정되는 무작위 액세스 I/O는 HDD 디스크 헤드 이동을 유발한다.

<br/>

<br/>

> raw 순차 처리량 측면
> 
- HDD 헤드 탐색을 최소화하고, 미디어에 대한 데이터 읽기 및 쓰기가 강조된다.
    - → NVM이 더 적은 이득을 제공
    - 읽기의 경우 두 가지 유형의 장치 성능은 동등하거나 NVM이 10배 정도 이득을 얻는다.
    - → NVM에 쓰는 것이 읽는 것보다 느리므로 이득은 줄어든다.

<br/>

<br/>

> 시간이 지남에 따라 NVM 장치의 수명과 성능을 향상시키는 한 가지 방법
> 
- 파일이 삭제될 때 파일 시스템이 장치에 알리도록 한다.
    - → 해당 파일이 저장된 블록을 지울 수 있도록 하자!

<br/>

<br/>

> 가비지 수집이 성능에 미치는 영향
> 
- 유효하지 않은 데이터가 차지한 공간을 회수하려면 가비지 수집을 실행해야 한다.
    - 즉, 하나의 쓰기 연산으로 인해 하나 이상의 페이지를 읽어서,
    해당 페이지에 있는 유효한 데이터를 과잉 공급 공간에 기록하고,
    유효하지 않은 데이터만 기록된 블록을 지우고,
    해당 블록을 과잉 공급 공간에 배치할 수도 있다는 것을 의미!

<br/>

<br/>

# 💡 오류 감지 및 수정

> 오류 감지 및 수정은 메모리, 네트워킹 및 저장장치를 포함한 많은 컴퓨팅 영역에서 필수적이다.
> 
- 여기서 **오류 감지**는 문제가 발생했는지 여부를 결정한다.
- 문제를 감지하면? → 시스템은 오류가 전파되기 전에 작업을 중단하거나, 관리자에게 오류를 보고!

<br/>

<br/>

> 메인 메모리 시스템은 패리티 비트를 사용해 특정 오류를 오랫동안 감지했다.
> 
- 동작 방식
    - 메모리 시스템의 각 바이트에는 1로 설정된 비트 수가 짝수인지 홀수인지를 기록한다.
    - 바이트의 비트 중 하나가 손상되면 패리티가 변경되어 저장된 패리티가 일치하지 않음!
        - → 모든 단일 비트 오류는 시스템에 의해 감지된다.

<br/>

<br/>

> 패리티는 고정 길이 워드의 값을 계산, 저장 및 비교하기 위해 나머지 연산을 수행하는 **체크섬**의 한 형태다.
> 
- 네트워킹에서 일반적으로 사용되는 다른 오류 감지 방법은 **순환 중복 검사(CRC)**이다.
    - CRC : 해시 함수를 사용해 다중 비트 오류를 감지한다.

<br/>

<br/>

> **오류 수정 코드(ECC)**는 문제를 감지할 뿐만 아니라 보정도 한다.
> 
- 여기서 보정은 알고리즘과 저장장치를 추가로 사용하여 수행된다.
    - 코드는 필요한 추가 저장장치의 양과 보정할 수 있는 오류의 개수에 따라 다르다.

<br/>

<br/>

- ECC는 몇 비트의 데이터만 손상된 경우 컨트롤러가 변경된 비트를 식별한다.
    - 이후, 올바른 값을 계산할 수 있도록 충분한 정보를 포함하고 있어, 오류 보정 방식이다.
    - 그 후에는 복구 가능한 **소프트 오류**를 보고한다.

<br/>

<br/>

# 💡 저장 장치 관리 _Storage Device Management

## 드라이브 포매팅, 파티션, 볼륨

> **저수준 포매팅** (또는 **물리적 포매팅**)이란?
> 
- 새로운 저장장치는 아무런 정보도 없는 비어있는 판 또는 초기화되지 않은 반도체 저장 셀의 집합이다.
    - 저장장치는 자료를 저장하기 전에 컨트롤러가 읽고 쓸 수 있도록 섹터들로 나누어져 있어야 한다.
    - NVM 페이지는 초기화되어야 하고 FTL이 생성되어야 한다.
        - → 이 과정을 저수준 포매팅이라고 함!

<br/>

<br/>

> 저수준 포매팅은 각 저장장치 위치마다 특별한 자료구조로 장치를 채운다.
> 
- 섹터 또는 페이지를 위한 자료구조는 보통 헤더, 자료 구역과 트레일러로 구성된다.
- 헤더와 트레일러는 섹터/페이지 번호와 오류 탐지, 오류 수정 코드와 같은 컨트롤러 사용하는 정보를 가짐!

<br/>

<br/>

> 드라이브를 사용하여 파일을 보유하려면? → 운영체제가 여전히 자체 데이터 구조를 장치에 기록해야 함!
> 
- 운영체제는 이 작업을 3단계로 수행한다.
1. 첫 번째 : 장치를 하나 이상의 블록 또는 페이지 그룹으로 **파티션**
    1. 운영체제는 각 파티션을 별도의 장치인 것처럼 취급할 수 있다.
    2. 일부 운영체제 및 파일 시스템은 장치 전체를 관리하게 되었을 때 자동으로 파티션 작업을 수행한다.
        - 이때, 파티션 정보는 저장장치의 고정된 위치에 고정된 형식으로 기록!
    3. 파일 시스템을 **마운트**하면 시스템과 해당 사용자가 그 파일 시스템을 사용할 수 있게 된다.

<br/>

1. 두 번째 : 볼륨 생성 및 관리
    1. 파일 시스템이 파티션 내에 직접 배치될 때와 같이 이 단계는 암시적으로 적용된다.
        - → 그러면 해당 볼륨을 마운트하여 사용할 수 있다!
    2. 다른 경우, **볼륨** 생성 및 관리가 명시적으로 행해진다.
    3. “볼륨”은 마운트 가능한 모든 파일 시스템을 의미할 수 있으며, CD 이미지와 같은 파일 시스템을 포함하는 파일일 수도 있다!

<br/>

1. 세 번째 : 논리적 포매팅 또는 파일 시스템의 생성
    1. 이 단계에서 운영체제는 초기 파일 시스템 자료구조를 장치에 저장한다.
    2. 이러한 자료구조에는 가용 공간과 할당된 공간의 맵과 초기의 빈 디렉터리 등이 포함된다.

<br/>

<br/>

> 파티션 정보는 부팅 가능한 파일 시스템이 포함되어 있는지도 나타낸다.
> 
- 부팅 가능으로 표시된 파티션 → 파일 시스템의 루트를 설정하는 데 사용!
- 마운트되면 모든 다른 장치 링크와 해당 파티션이 생성될 수 있다.

<br/>

<br/>

> 효율성을 높이기 위해 대부분의 파일 시스템은 블록을 종종 **클러스터**라고 하는 더 큰 청크로 묶는다.
> 
- 장치 I/O는 블록을 통해 수행되지만 파일 시스템 I/O는 클러스터를 통해 수행됨
    - *→ 효과적으로 I/O가 순차 접근을 더 많이하고 랜덤 액세스 특성을 줄이도록 보장!*

<br/>

<br/>

> **raw 디스크**란?
> 
- OS가 특정 프로그램이 파일 시스템 자료구조 없이도 파티션을 **논리 블록의 대용량 순차 배열**처럼 사용할 수 있게 하는데, 이 배열을 말한다.
    - 또한 이 배열에 대한 I/O를 raw I/O라고 한다.

<br/>

<br/>

## 부트 블록

> 컴퓨터가 실행을 시작하려면 실행할 초기 프로그램이 존재해야 한다.
> 
- *이 초기 **부트스트랩** 로더는 단순한 경향이 있다!*
    - 이 부트스트랩 로더 프로그램은 보조저장장치에서 완전한 부트스트랩 프로그램을 가져오기에 충분히 영리하다.
        - → 완전한 부트스트랩 프로그램은 장치의 고정된 위치에 있는 “부트 블록”에 저장되어 있다.
        - → 이런 부트 파티션이 있는 장치를 **부트 디스크** 또는 **시스템 디스크**라고 한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/11-6.png" width = 500/>

> Window에서의 부트 프로세스의 예시
> 
- 윈도우는 한 개 이상의 파티션으로 드라이브를 파티션할 수 있게 하고,
**부트 파티션**이라고 된 한 파티션에 운영체제와 장치 드라이버들이 저장된다.
    - 윈도우 시스템은 부트 코드를 하드 디스크의 첫 번째 논리 블록(또는 NVM 장치의 첫 번째 페이지 = **마스터 부트 레코드** 또는 **MBR**라고 함)에 배치한다.
- 이후, 부팅은 시스템 펌웨어에 상주하는 코드를 실행하여 시작!
    - 이 코드는 시스템이 MBR에서 부트 코드를 읽도록 지시한다.
- 시스템이 부팅 파티션을 식별하면 → 해당 파티션에서 첫 번째 섹터(**부트 섹터**)를 읽고 커널로 안내한다.

<br/>

<br/>

## 손상된 블록

> 종종 공장에서 출고될 때 이미 **손상 블록**을 가지고 나오는 디스크가 있을 수 있다.
> 
- 손상된 블록들은 디스크와 컨트롤러에 따라 다양한 방법으로 처리된다.
- 구형 IDE 컨트롤러를 가진 디스크 → 손상 블록들을 수동으로 처리
    - 전략 : 디스크 포맷 중에 디스크를 스캔해 손상된 블록들을 검사한다.
    - 발견된 손상된 블록은 사용 불가라고 표기해 파일 시스템이 해당 블록을 할당하지 않도록 한다.
- 더욱 정교한 디스크 → 조금 더 현명한 처리
    - 전략 : 컨트롤러는 손상 블록의 리스트를 유지
    - 리스트는 공장에서 저수준 포맷팅을 하는 동안 초기화되고, 디스크가 사용되는 동안 계속 유지된다.
    - 저수준 포매팅은 운영체제가 볼 수 없는 예비 섹터를 남겨 놓는다.
    - 이러한 예비 섹터 중 하나를 손상된 섹터와 교체시킨다! → **섹터 예비** 또는 **섹터 포워딩**

<br/>

<br/>

> 예비 섹터를 관리하는 방안에는 여러 가지가 있다.
> 
- ex) 일부 컨트롤러는 **섹터 밀어내기(sector slipping)**에 의해 손상 섹터를 처리할 수 있도록 한다.


<br/>

<br/>

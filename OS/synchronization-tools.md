# 동기화 도구들

<br/>

> 🌱 *협력적 프로세스란?*
>
>→ 시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나 받는 프로세스!
>
>→ 논리 주소 공간을 공유하거나, 공유 메모리 또는 메시지 전달을 통해 데이터를 공유한다.

<br/>

<br/>

## 💡 배경 

> 프로세스가 병행 또는 병렬로 실행될 때 **공유 데이터의 무결성**에 어떤 문제를 일으키는지에 관해 알아보자!
> 

<br/>

<br/>

- 유한 버퍼 문제로 가정해보자.
    - 동시에 최대 `BUFFER_SIZE - 1` 개 까지만 버퍼에 저장할 수 있다.

<br/>

<br/>

- 첫번째 방법 : `count` 에 버퍼에 있는 개수를 저장하자.
    - 생산자 코드
        
        ```java
        while (true) {
        		
        		while (count == BUFFER_SIZE) ;
        
        		buffer[in] = next_produced;
        		in = (in + 1) % BUFFER_SIZE;
        		count++;
        }
        ```
    
    <br/>
    
    - 소비자 코드
        
        ```java
        while (true) {
        
        		while (count == 0) ;
        
        		next_consumed = buffer[out];
        		out = (out + 1) % BUFFER_SIZE;
        		count--;
        }
        ```
        

<br/>

<br/>

- 결과
  - 첫번째 방식은 병행으로 실행 시 올바르게 동작하지 않는다.
  
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/buffer-count.png" width = 600/>

<br/>

<br/>


> 🌱 **경쟁 상황**(race condition)이란?
>
>→ 여러 프로세스가 동일한 자료에 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 말한다. 이를 피하기 위해 **동기화**는 필수적이다.

<br/>

<br/>

## 💡 임계구역 문제

- 프로세스 동기화에 관한 논의는 **임계구역 문제**라고 불리는 문제부터 시작한다.
    - **임계구역**이란, 적어도 하나 이상의 **다른 프로세스와 공유하는 데이터에 접근하고 갱신하는 구간**이다.
    - ***이때, 한 프로세스가 자신의 임계구역에서 수행하는 동안 다른 프로세스는 임계구역에 들어갈 수 없다.***

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/critical-section-process.png" width = 600/>

- 임계구역의 구성
    - 진입 구역(`entry section`)
        - 자신의 임계구역으로 진입하기 위해 진입 허가를 요청하는 부분이다.
    - 퇴출 구역(`exit section`)
        - 임계구역이 끝난 뒤 부분을 말한다.
    - 나머지 구역(`remainder section`)

<br/>

<br/>

- 임계구역에 대한 해결안은 아래 3가지 요구 조건을 충족해야 한다.
    1. **상호 배제(mutual exclusion)**
        1. 한 프로세스가 임계구역에서 실행되면, 다른 프로세스는 임계구역에서 실행될 수 없다.
    2. **진행(progress)**
        1. 자기의 임계구역에서 실행되는 프로세스가 없고, 임계구역에 진입하려는 프로세스가 있다면?
        2. 나머지 구역에서 실행중이지 않은 프로세스들만 다음에 누가 임계구역으로 진입할지 참여한다.
        3. 또한 이 선택은 무한정 연기될 수 없다.
    3. **한정된 대기(bounded waiting)**
        1. 프로세스가 임계구경게 진입하려는 요청을 한 후부터 허용될 때까지, 다른 프로세스가 임계구역에 진입하도록 허용되는 횟수에는 한계가 있어야 한다.

<br/>

<br/>

- 단일 코어 환경에서의 임계구역 문제
    - 공유 변수를 수정하는 동안 인터럽트를 막는다면? → 선점없이 순차적 수행되도록하여 간단히 해결!
    - ***단, 이는 다중 처리기 환경에서는 실현할 수 없다.***
        1. 메시지가 모든 프로세서에 전달 후 다중 처리기에서 인터럽트를 비활성화 → 많은 시간 소요
        2. 메시지 전달이 임계구역으로의 진입을 지연시키고, 시스템 효율성을 떨어뜨림.

<br/>

<br/>

> 운영체제 내에서 임계구역을 다루기 위해 사용되는 일반적인 두 가지 접근법
> 
1. **선점형 커널**
    1. 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용한다.
    2. 경쟁 조건이 발생하지 않도록 보장하기 위해 신중하게 설계를 해야 한다.
2. **비선점형 커널**
    1. 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않는다.
    2. 선점이 없으므로, 경쟁 조건을 염려할 필요가 없다.


<br/>

<br/>

## 💡 Peterson의 해결안 

- Perterson의 해결안은 임계구역에 대한 고전적인 소프트웨어 기반 해결책이다.
    - 다만, 현대 컴퓨터 구조에서 올바르게 실행된다고 보장할 수는 없다.
    - 각 프로세스에 P0, P1으로 번호 부여한다.
    - 이후, 편의상 Pi를 표현할 때 다른 프로세스를 Pj (j = 1 – i)로 나타낸다.

<br/>

<br/>

- 동작 과정
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/peterson's-solution.png" width = 600/>
    

    - 위 식은 아래를 만족한다.
        - **상호 배제**
            - flag[1]이 false이거나 turn = 0인 경우에만 P0이 임계구역에 진입한다.
            - 두 프로세스가 동시에 임계구역에서 실행하려면?
                
                → flag[0]과 flag[1]이 동시에 true이어야 한다.

        <br/>

        - **진행 조건**
            - P0가 요청했을 때 이미 P1이 임계구역을 수행 중이면, flag[1] = true이고 turn = 1 이므로 P0는 기다린다.
            - P1가 임계구역을 벗어나는 순간 flag[1] = false가 되어 P0가 임계구역에 진입하게 된다.

        <br/>

        - **한계 대기**
            - P0는 P1가 기껏해야 한번 임계구역에 들어간 후에는 P1가 나머지 구역을 수행 중이라도 임계구역에 들어갈 수 있다.
    

<br/>

<br/>

> 🌱 소프트웨어 기반 해결책(ex: 피터슨의 해결안)은 현대의 컴퓨터 구조에서 올바르게 동작한다는 것을 보장하지 않는다
>
> - 시스템 성능 향상을 위해 프로세서 및 컴파일러가 종속성이 없는 작업을 재정렬할 수 있기 때문!

<br/>

<br/>

## 💡 동기화를 위한 하드웨어 지원 

### 메모리 장벽

- **메모리 모델**이란?
    - 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식
    - **강한 순서**
        - 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임
    - **약한 순서**
        - 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보이지 않음.

<br/>

<br/>

- **메모리 장벽**이란? (= 메모리 펜스)
    - 메모리 모델은 프로세서 유형에 따라 달라 메모리 변경의 가시성에 대한 가정을 하기 어렵다.
    - 따라서 *메모리의 변경 사항을 다른 모든 프로세서로 전파하는 명령어*를 만들었고, 이를 뜻한다.

<br/>

<br/>

- 코드
    - 스레드 1에 메모리 장벽 연산 추가
        
        ```c
        while (!flag) 
        		memory_barrier();
        print x;
        ```
        
    <br/>

    - 스레드 2에 메모리 장벽 추가
        
        ```c
        x = 100;
        memory_barrier();
        flag = true;
        ```
        

<br/>

<br/>

### 하드웨어 명령어

- 많은 현대 기계들은 인터럽트 되지 않는 하나의 단위로써, 특별한 하드웨어 명령어들을 제공한다.
    - `test_and_set()`
        - 이 명령어는 **원자적으로 실행**된다는 특징이 있다.
        
        <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/test-and-set.png" width = 600/>
        
    <br/>

    - `compare_and_swap()`
        - test_and_set()과 비슷하지만, 두 워드 내용 교환에 기반을 둔 다른 기법을 사용한다.
        
        <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/compare-and-swap.png" width = 600/>
        

<br/>

<br/>

### 원자적 변수

- 일반적으로 `compare_and_swap()` 은 임계구역 문제를 해결하는 다른 도구를 구축하는 요소로 사용된다.
    - 그러한 도구 중 하나가 **원자적 변수**(`atomic variable`)이다.
        - 이는 정수 및 부울과 같은 기본 데이터 유형에 대한 원자적 연산을 제공한다.
        - 원자적 변수를 지원하는 대부분의 시스템은 원자적 변수에 접근하고 조작하기 위한 기능뿐만 아니라 특별한 원자적 데이터 유형을 제공한다.

<br/>

<br/>

- 구현 코드
    
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/atomic-variable.png" width = 600/>
    
    - 이는 원자적 갱신을 제공하지만 모든 상황에서 경쟁 조건을 완벽히 해결하지는 않는다.


<br/>

<br/>

## 💡 Mutex Locks

- Mutex 락이란?
    - 임계구역을 보호하고, 경쟁 조건을 방지하기 위해 사용한다.
    - `available` 이라는 불린 변수를 이용해 락의 가용 여부를 표시한다.
    - 락이 가용하면? → `acquire()` 호출!

<br/>

<br/>

- 동작 방식
    
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/mutex.png" width = 600/>
    

    ```c
    acquire() {
            while (!available)
                    ; /* busy wait */
            available = false;
    }
    ```

    ```c
    release() {
            available = true;
    }
    ```

<br/>

<br/>

- ***뮤텍스 락의 단점은 바쁜 대기(`busy waiting`)를 해야 한다는 것이다.***
    - 한 프로세스가 임계구역에 있는 동안 임계구역에 진입하려는 다른 프로세스들은 `acquire()` 함수를 호출하는 반복문을 계속 실행한다.
    - 이는 다중 프로그래밍 시스템에서 **CPU 낭비**로 볼 수 있다.

<br/>

- 스핀락(`spinlock`)이란?
    - 위에 나온 mutex 락이 해당되는 유형으로, 락을 사용할 수 있을 때까지 프로세스가 회전하는 구조
    - 프로세스가 락을 기다려야하고, 문맥 교환에 상당한 시간이 소요될 때 ***문맥 교환이 필요로 하지 않는
    장점***이 있다!

<br/>

<br/>

## 💡 세마포

> 🌱 mutex는 일반적으로 동기화 도구의 가장 간단한 형태로 생각된다.
>
>세마포는 프로세스들이 자신들의 행동을 더 정교하게 동기화할 수 있는 방법을 제공한다.

<br/>

<br/>

- 세마포(`Semaphores`)란?
    - S는 정수 변수로, 초기화를 제외하고는 단지 두 개의 표준 **원자적** 연산으로만 접근할 수 있다.
        - `wait()` , `signal()`

        <br/>

        ```c
        wait(S) {
                while (S <= 0)
                        ; //busy wait
                S--;
        }
        ```

        <br/>

        ```c
        signal(S) {
                S++;
        }
        ```

<br/>

<br/>

### 세마포 사용법

- 운영체제는 종종 카운팅과 이진 세마포를 구분한다.
    - **카운팅 세마포**의 값은 제한 없는 영역(domain)을 갖는다.
        - 유한한 개수를 가진 자원에 대한 접근을 제어하는 데 사용된다.
        - 세마포는 가용한 자원의 개수로 초기화되고, 값이 0이 되면 모든 자원이 사용 중임을 나타낸다.
    - **이진 세마포**의 값은 0과 1 사이의 값만 가능하다.
        - mutex 락과 유사하게 동작하지만, 상호 배제를 보장하기 위해 이진 세마포가 대신 사용되곤 한다.

<br/>

<br/>

### 세마포 구현

- 세마포에서는 뮤텍스처럼 **바쁜 대기를 극복**하기 위해, `wait()` 과 `signal()` 연산을 일부 변경한다.
    - 프로세스가 `wait()` 을 실행하고 세마포 값이 양수가 아님을 발견하면, 프로세스는 대기한다.
        - **이때, 바쁜 대기 대신에 프로세스는 자신을 일시 중지(sleep) 시킨다!**
    - 프로세스가 `signal()` 연산을 실행하면 일시정지된 프로세스는 `wakeup()` 에 의해 재시작된다.

<br/>

<br/>

```c
typedef struct {
		int value;
		struct process *list;
} semaphore;
```

```c
wait(semaphore *S) {
	S->value--;
	if (S->value < 0) {
		add this process to S->list;
		sleep();
	}
}
```

```c
signal(semaphore *S) {
	S->value++;
	if (S->value <= 0) {
		remove a process P from S->list;
		wakeup(P);
	}
}
```


<br/>

<br/>

## 💡 모니터

> 세마포가 프로세스 간의 동기화를 위해 편리하고 효율적으로 쓰일 수 있지만, 여전히 잘못 사용하면 발견하기 어려운 *타이밍 오류*를 야기할 수 있다.
>
>따라서 간단한 동기화 도구를 통합해 **고급 언어 구조물을 제공**하는 전략이 나왔고, **모니터**형이 이에 해당된다.
> 

<br/>

<br/>

### 모니터 사용법

- 추상화된 데이터 형(ADT)은 데이터와 이 데이터를 조작하는 함수들의 집합을 하나의 단위로 묶는다.
    - *이때, 함수의 구현은 ADT의 특정 구현과는 독립적이다!*

<br/>

<br/>

- *모니터 형*이란?
    - 모니터 내부에서 상호 배제가 보장되는 프로그래머가 정한 일련의 연산자 집합을 포함하는 ADT이다.
    - 또한, 여기에 포함된 변수들의 값은 인스턴스의 상태를 정의한다.

<br/>

<br/>

- 모니터 구조물은 항상 하나의 프로세스만 모니터 안에서 활성화되도록 보장한다.
    - *프로그래머는 동기화 제약 조건을 명시적으로 코딩할 필요가 없다!*

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/monitor1.png" width = 600/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/monitor2.png" width = 600/>

<br/>

<br/>

### 세마포를 이용한 모니터 구현

- 모니터 구현 시 `signal-and-wait` 기법을 사용한다.
    
    ```c
    semaphore mutex; // initially = 1
    semaphore next; // initially = 0
    int next_count = 0; // number of processes waiting inside the monitor
    
    // 외부 프로세서 F
    wait(mutex);
    	...
    	body of F
    	...
    
    if (next_count > 0)
    	signal(next);
    else
    	signal(mutex);
    ```
    

<br/>

<br/>

- 조건 변수를 세마포로 구현하는 방법
    - 조건 x마다 x_sem이라는 이진 세미포와 x_count라는 정수형 변수를 도입한다.

        ```c
        semaphore x_sem; // initially = 0
        int x_count = 0;

        // x.wait() 연산

        x_count++;
        if (next_count > 0)
                signal(next);
        else
                signal(mutex);
        wait(x_sem);
        x_count--;
        ```

        <br/>

        ```c
        // x.signal() 연산
        if (x_count > 0) {
                next_count++;
                signal(x_sem);
                wait(next);
                next_count--;
        }
        ```

<br/>

<br/>

### 모니터 내에서 프로세스 수행 재개

- 모니터 안에서 프로세스가 수행 재개되는 순서로 주제를 전환한다.
    - 일시중지 된 프로세스가 여럿 있을 때, 어느 프로세스가 재수행 될 지 어떻게 결정할까?
    - → 주로 아래와 가은 형식의 `confitional-wait` 구조물을 사용한다.
        
        ```c
        x.wait(c);
        ```
        

<br/>

- 위에서 c는 정수 수식이고, 이 수식은 wait() 연산이 호출될 때 값이 계산된다.
    - c의 값은 **우선순위 번호**라 불리며, 일시 중지되는 프로세스의 이름과 함께 저장된다.


<br/>

<br/>

## 💡 라이브니스

- **라이브니스**란?
    - 프로세스가 실행 수명주기 동안 진행되는 것을 보장하기 위해 시스템이 충족해야 하는 일련의 속성
    - 무기한 대기하는 프로세스의 경우(like 무한 루프) → 라이브니스 실패의 예시!

<br/>

<br/>

### 교착 상태(Deadlock)

- 대기 큐를 가졌을 때, 두 개 이상의 프로세스들이 **이벤트를 무한정 기다리는 상황이 발생**할 수 있다.
    - 세마포를 구현한 경우, 서로 `signal()`의 발생을 기다리는 경우이다.
        
        <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/deadlock.png" width = 600/>
        

<br/>

<br/>

### 우선순위 역전

- 높은 우선순위 프로세스가 현재 낮은 우선순위 프로세스 또는 연속된 낮은 우선순위 프로세스들에
의해 접근되고 있는 커널 데이터를 읽거나 변경할 필요가 있을 때 스케줄이 문제가 생긴다.

<br/>

<br/>

- 예시
    - 우선순위가 L < M < H 인 3개의 프로세스 L, M, H이라고 가정.
    - H는 L이 사용중인 자원 R을 필요로 하고, M이 실행가능 상태가 되어 L을 선점한다.
    - ***M이 H는 L이 자원을 양도할 때까지 기다리는 시간에 영향을 준다.***

<br/>

<br/>

- 우선순위 역전(`priority inversion`) 문제
    - 셋 이상의 우선순위를 가진 시스템에서만 발생한다.
    - **우선순위 상속 프로토콜**(`priority-inheritance protocol`)을 구현하여 해결한다.
        - 더 높은 우선순위 프로세스가 필요로 하는 자원을 접근하는 모든 프로세스들은 문제가 된 자원의 사용이 끝날 때까지 더 높은 우선순위를 상속받는다.
        - 자원 사용이 끝나면 원래 우선순위로 되돌아간다.


<br/>

<br/>

## 💡 평가

- 최근에는 락 오버헤드 없이 경쟁 조건으로부터 보호하는 `lock-free` 알고리즘을 구현하는 데에 중점을 둔다.
    - 이러한 알고리즘은 오버헤드가 낮고 확장성이 있어 인기를 얻지만, 개발 및 테스트가 어렵다.

<br/>

<br/>

- CAS 기반 접근 방식은 *낙관적인* 접근법으로 간주한다.
    - 우선 변수를 갱신한 다음 충돌 감지를 사용해 다른 스레드가 변수를 병행하게 갱신하는지 확인한다.
    - 갱신중이라면? → 충돌 없이 성공적으로 갱신될 때까지 연산을 반복 시도

<br/>

<br/>
    
- 이와 반대로 상호 배제 락킹은 *비관적* 전략으로 간주한다.
    - 다른 스레드가 병행하게 갱신중이라면? → 갱신하기 전에 비관적으로 락을 획득!
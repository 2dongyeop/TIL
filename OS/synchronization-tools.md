# 동기화 도구들

<br/>

> 🌱 *협력적 프로세스란?*
>
>→ 시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나 받는 프로세스!
>
>→ 논리 주소 공간을 공유하거나, 공유 메모리 또는 메시지 전달을 통해 데이터를 공유한다.

<br/>

<br/>

## 💡 배경 

> 프로세스가 병행 또는 병렬로 실행될 때 **공유 데이터의 무결성**에 어떤 문제를 일으키는지에 관해 알아보자!
> 

<br/>

<br/>

- 유한 버퍼 문제로 가정해보자.
    - 동시에 최대 `BUFFER_SIZE - 1` 개 까지만 버퍼에 저장할 수 있다.

<br/>

<br/>

- 첫번째 방법 : `count` 에 버퍼에 있는 개수를 저장하자.
    - 생산자 코드
        
        ```java
        while (true) {
        		
        		while (count == BUFFER_SIZE) ;
        
        		buffer[in] = next_produced;
        		in = (in + 1) % BUFFER_SIZE;
        		count++;
        }
        ```
    
    <br/>
    
    - 소비자 코드
        
        ```java
        while (true) {
        
        		while (count == 0) ;
        
        		next_consumed = buffer[out];
        		out = (out + 1) % BUFFER_SIZE;
        		count--;
        }
        ```
        

<br/>

<br/>

- 결과
  - 첫번째 방식은 병행으로 실행 시 올바르게 동작하지 않는다.
  
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/buffer-count.png" width = 600/>

<br/>

<br/>


> 🌱 **경쟁 상황**(race condition)이란?
>
>→ 여러 프로세스가 동일한 자료에 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 말한다. 이를 피하기 위해 **동기화**는 필수적이다.

<br/>

<br/>

## 💡 임계구역 문제

- 프로세스 동기화에 관한 논의는 **임계구역 문제**라고 불리는 문제부터 시작한다.
    - **임계구역**이란, 적어도 하나 이상의 **다른 프로세스와 공유하는 데이터에 접근하고 갱신하는 구간**이다.
    - ***이때, 한 프로세스가 자신의 임계구역에서 수행하는 동안 다른 프로세스는 임계구역에 들어갈 수 없다.***

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/critical-section-process.png" width = 600/>

- 임계구역의 구성
    - 진입 구역(`entry section`)
        - 자신의 임계구역으로 진입하기 위해 진입 허가를 요청하는 부분이다.
    - 퇴출 구역(`exit section`)
        - 임계구역이 끝난 뒤 부분을 말한다.
    - 나머지 구역(`remainder section`)

<br/>

<br/>

- 임계구역에 대한 해결안은 아래 3가지 요구 조건을 충족해야 한다.
    1. **상호 배제(mutual exclusion)**
        1. 한 프로세스가 임계구역에서 실행되면, 다른 프로세스는 임계구역에서 실행될 수 없다.
    2. **진행(progress)**
        1. 자기의 임계구역에서 실행되는 프로세스가 없고, 임계구역에 진입하려는 프로세스가 있다면?
        2. 나머지 구역에서 실행중이지 않은 프로세스들만 다음에 누가 임계구역으로 진입할지 참여한다.
        3. 또한 이 선택은 무한정 연기될 수 없다.
    3. **한정된 대기(bounded waiting)**
        1. 프로세스가 임계구경게 진입하려는 요청을 한 후부터 허용될 때까지, 다른 프로세스가 임계구역에 진입하도록 허용되는 횟수에는 한계가 있어야 한다.

<br/>

<br/>

- 단일 코어 환경에서의 임계구역 문제
    - 공유 변수를 수정하는 동안 인터럽트를 막는다면? → 선점없이 순차적 수행되도록하여 간단히 해결!
    - ***단, 이는 다중 처리기 환경에서는 실현할 수 없다.***
        1. 메시지가 모든 프로세서에 전달 후 다중 처리기에서 인터럽트를 비활성화 → 많은 시간 소요
        2. 메시지 전달이 임계구역으로의 진입을 지연시키고, 시스템 효율성을 떨어뜨림.

<br/>

<br/>

> 운영체제 내에서 임계구역을 다루기 위해 사용되는 일반적인 두 가지 접근법
> 
1. **선점형 커널**
    1. 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용한다.
    2. 경쟁 조건이 발생하지 않도록 보장하기 위해 신중하게 설계를 해야 한다.
2. **비선점형 커널**
    1. 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않는다.
    2. 선점이 없으므로, 경쟁 조건을 염려할 필요가 없다.


<br/>

<br/>

## 💡 Peterson의 해결안 

- Perterson의 해결안은 임계구역에 대한 고전적인 소프트웨어 기반 해결책이다.
    - 다만, 현대 컴퓨터 구조에서 올바르게 실행된다고 보장할 수는 없다.
    - 각 프로세스에 P0, P1으로 번호 부여한다.
    - 이후, 편의상 Pi를 표현할 때 다른 프로세스를 Pj (j = 1 – i)로 나타낸다.

<br/>

<br/>

- 동작 과정
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/peterson's-solution.png" width = 600/>
    

    - 위 식은 아래를 만족한다.
        - **상호 배제**
            - flag[1]이 false이거나 turn = 0인 경우에만 P0이 임계구역에 진입한다.
            - 두 프로세스가 동시에 임계구역에서 실행하려면?
                
                → flag[0]과 flag[1]이 동시에 true이어야 한다.

        <br/>

        - **진행 조건**
            - P0가 요청했을 때 이미 P1이 임계구역을 수행 중이면, flag[1] = true이고 turn = 1 이므로 P0는 기다린다.
            - P1가 임계구역을 벗어나는 순간 flag[1] = false가 되어 P0가 임계구역에 진입하게 된다.

        <br/>

        - **한계 대기**
            - P0는 P1가 기껏해야 한번 임계구역에 들어간 후에는 P1가 나머지 구역을 수행 중이라도 임계구역에 들어갈 수 있다.
    

<br/>

<br/>

> 🌱 소프트웨어 기반 해결책(ex: 피터슨의 해결안)은 현대의 컴퓨터 구조에서 올바르게 동작한다는 것을 보장하지 않는다
>
> - 시스템 성능 향상을 위해 프로세서 및 컴파일러가 종속성이 없는 작업을 재정렬할 수 있기 때문!

<br/>

<br/>

## 💡 동기화를 위한 하드웨어 지원 

### 메모리 장벽

- **메모리 모델**이란?
    - 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식
    - **강한 순서**
        - 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임
    - **약한 순서**
        - 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보이지 않음.

<br/>

<br/>

- **메모리 장벽**이란? (= 메모리 펜스)
    - 메모리 모델은 프로세서 유형에 따라 달라 메모리 변경의 가시성에 대한 가정을 하기 어렵다.
    - 따라서 *메모리의 변경 사항을 다른 모든 프로세서로 전파하는 명령어*를 만들었고, 이를 뜻한다.

<br/>

<br/>

- 코드
    - 스레드 1에 메모리 장벽 연산 추가
        
        ```c
        while (!flag) 
        		memory_barrier();
        print x;
        ```
        
    <br/>

    - 스레드 2에 메모리 장벽 추가
        
        ```c
        x = 100;
        memory_barrier();
        flag = true;
        ```
        

<br/>

<br/>

### 하드웨어 명령어

- 많은 현대 기계들은 인터럽트 되지 않는 하나의 단위로써, 특별한 하드웨어 명령어들을 제공한다.
    - `test_and_set()`
        - 이 명령어는 **원자적으로 실행**된다는 특징이 있다.
        
        <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/test-and-set.png" width = 600/>
        
    <br/>

    - `compare_and_swap()`
        - test_and_set()과 비슷하지만, 두 워드 내용 교환에 기반을 둔 다른 기법을 사용한다.
        
        <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/compare-and-swap.png" width = 600/>
        

<br/>

<br/>

### 원자적 변수

- 일반적으로 `compare_and_swap()` 은 임계구역 문제를 해결하는 다른 도구를 구축하는 요소로 사용된다.
    - 그러한 도구 중 하나가 **원자적 변수**(`atomic variable`)이다.
        - 이는 정수 및 부울과 같은 기본 데이터 유형에 대한 원자적 연산을 제공한다.
        - 원자적 변수를 지원하는 대부분의 시스템은 원자적 변수에 접근하고 조작하기 위한 기능뿐만 아니라 특별한 원자적 데이터 유형을 제공한다.

<br/>

<br/>

- 구현 코드
    
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/atomic-variable.png" width = 600/>
    
    - 이는 원자적 갱신을 제공하지만 모든 상황에서 경쟁 조건을 완벽히 해결하지는 않는다.


<br/>

<br/>

## 💡 Mutex Locks

- Mutex 락이란?
    - 임계구역을 보호하고, 경쟁 조건을 방지하기 위해 사용한다.
    - `available` 이라는 불린 변수를 이용해 락의 가용 여부를 표시한다.
    - 락이 가용하면? → `acquire()` 호출!

<br/>

<br/>

- 동작 방식
    
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/mutex.png" width = 600/>
    

    ```c
    acquire() {
            while (!available)
                    ; /* busy wait */
            available = false;
    }
    ```

    ```c
    release() {
            available = true;
    }
    ```

<br/>

<br/>

- ***뮤텍스 락의 단점은 바쁜 대기(`busy waiting`)를 해야 한다는 것이다.***
    - 한 프로세스가 임계구역에 있는 동안 임계구역에 진입하려는 다른 프로세스들은 `acquire()` 함수를 호출하는 반복문을 계속 실행한다.
    - 이는 다중 프로그래밍 시스템에서 **CPU 낭비**로 볼 수 있다.

<br/>

- 스핀락(`spinlock`)이란?
    - 위에 나온 mutex 락이 해당되는 유형으로, 락을 사용할 수 있을 때까지 프로세스가 회전하는 구조
    - 프로세스가 락을 기다려야하고, 문맥 교환에 상당한 시간이 소요될 때 ***문맥 교환이 필요로 하지 않는
    장점***이 있다!

<br/>

<br/>

## 💡 세마포

> 🌱 mutex는 일반적으로 동기화 도구의 가장 간단한 형태로 생각된다.
>
>세마포는 프로세스들이 자신들의 행동을 더 정교하게 동기화할 수 있는 방법을 제공한다.

<br/>

<br/>

- 세마포(`Semaphores`)란?
    - S는 정수 변수로, 초기화를 제외하고는 단지 두 개의 표준 **원자적** 연산으로만 접근할 수 있다.
        - `wait()` , `signal()`

        <br/>

        ```c
        wait(S) {
                while (S <= 0)
                        ; //busy wait
                S--;
        }
        ```

        <br/>

        ```c
        signal(S) {
                S++;
        }
        ```

<br/>

<br/>

### 세마포 사용법

- 운영체제는 종종 카운팅과 이진 세마포를 구분한다.
    - **카운팅 세마포**의 값은 제한 없는 영역(domain)을 갖는다.
        - 유한한 개수를 가진 자원에 대한 접근을 제어하는 데 사용된다.
        - 세마포는 가용한 자원의 개수로 초기화되고, 값이 0이 되면 모든 자원이 사용 중임을 나타낸다.
    - **이진 세마포**의 값은 0과 1 사이의 값만 가능하다.
        - mutex 락과 유사하게 동작하지만, 상호 배제를 보장하기 위해 이진 세마포가 대신 사용되곤 한다.

<br/>

<br/>

### 세마포 구현

- 세마포에서는 뮤텍스처럼 **바쁜 대기를 극복**하기 위해, `wait()` 과 `signal()` 연산을 일부 변경한다.
    - 프로세스가 `wait()` 을 실행하고 세마포 값이 양수가 아님을 발견하면, 프로세스는 대기한다.
        - **이때, 바쁜 대기 대신에 프로세스는 자신을 일시 중지(sleep) 시킨다!**
    - 프로세스가 `signal()` 연산을 실행하면 일시정지된 프로세스는 `wakeup()` 에 의해 재시작된다.

<br/>

<br/>

```c
typedef struct {
		int value;
		struct process *list;
} semaphore;
```

```c
wait(semaphore *S) {
	S->value--;
	if (S->value < 0) {
		add this process to S->list;
		sleep();
	}
}
```

```c
signal(semaphore *S) {
	S->value++;
	if (S->value <= 0) {
		remove a process P from S->list;
		wakeup(P);
	}
}
```

---

<br/>

<br/>

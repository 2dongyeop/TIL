# 가상 메모리
> 가상 메모리(`virtual memory`)란?
>
>→ 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이다. 
>
>→ 주요 장점은 하나는 사용자 프로그램이 물리 메로리보다 커져도 된다는 점이다! 

<br/>

<br/>

## 💡 배경 _Background

> 실행 중인 코드는 반드시 물리 메모리에 있어야 한다는 것은 일견 필요하고 타당한 요구 조건으로 보이지만, 프로그램의 크기를 물리 메모리의 크기로 제한한다는 점 때문에 마냥 좋은 요구 조건은 아니다.
> 

<br/>

<br/>

> 실제 프로그램을 살펴보면 많은 경우에 프로그램 전체가 한꺼번에 메모리에 늘 올라와 있어야 한다는 건 아님을 쉽게 발견할 수 있다.
> 
- 프로그램에 잘 발생하지 않는 오류 상황을 처리하는 코드가 종종 존재한다.
    - 이런 오류들은 실질적으론 거의 발생하지 않는다.
- 배열, 리스트, 테이블 등은 필요 이상으로 많은 공간을 점유할 수도 있다.
- 프로그램 내의 어떤 옵션이나 기능들은 거의 사용되지 않는다.

<br/>

<br/>

> 만일 프로그램을 일부분만 메모리에 올려놓고 실행할 경우의 얻는 이점
> 
- 프로그램은 물리 메모리 크기에 의해 더는 제약받지 않게 된다.
    - → 사용자들은 매우 큰 ***가상*** 주소 공간을 가정하고 프로그램을 만들 수 있다.
- 각 프로그램이 더 작은 메모리를 차지하므로 더 많은 프로그램을 동시에 수행할 수 있게 된다.
- 프로그램을 메모리에 올리고 스왑하는데 필요한 I/O 회수가 줄어들기 때문에 프로그램 실행이 빠르다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/10-background1.png" width = 500/>


> **가상 메모리**는 실제의 물리 메모리 개념과 개발자의 논리 메모리 개념을 분리한 것이다.
> 
- 이로써 작은 메모리를 가지고도 얼만든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있다는 점이다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/10-background2.png" width = 500/>

> 한 프로세스의 **가상 주소 공간**은 그 프로세스가 메모리에 저장되는 논리적인 모습(view)을 말한다.
> 
- 일반적으로 위 그림과 같이 특정 논리 주소에서 시작하여 연속적인 공간을 차지한다.
    - 힙과 스택 사이의 공백도 가상 주소 공간의 일부이다. (**성긴 주소 공간**)

<br/>

<br/>

> 가상 메모리는 페이지 공유를 통해 프로세스들에게 (파일 또는 메모리) 공유를 제공한다.
> 
- 표준 C 라이브러리와 같은 시스템 라이브러리가 여러 프로세스들에 공유되는 것이 예시이다.
- 마찬가지로 프로세스들이 메모리를 공유할 수 있다! → 아래 사진 참고
    
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/10-background3.png" width = 500/>


<br/>

<br/>

# 💡 요구 페이징 _Demand Paging

> 어떻게 실행 프로그램을 보조저장장치에서 메모리로 적재할 수 있을까?
> 
- → 필요한 페이지만 적재하자! = ***요구 페이징(demand paging)***
    - 일반적으로 가상메모리 시스템에서 사용되며, **필요할 때**만 페이지가 적재된다.

<br/>

<br/>

## 기본 개념

> 요구 페이징의 기본 개념은 필요할 때만 페이지를 메모리에 적재하는 것이다.
> 
- 결과적으로 프로세스가 실행되는 동안 일부 페이지는 메모리에 있고 일부는 보조저장장치에 있다.
    
    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/10-background4.png" width = 500/>

    

<br/>

<br/>

> 그러나 프로세스가 메모리에 올라와 있지 않은 페이지에 접근하려고 하면 어떤 일이 발생할까?
> 
- ***페이지 폴트*** 트랩 발생!
    - 페이지 테이블 항목이 무효로 설정되어 있을 때를 의미.

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/10-background5.png" width = 500/>


<br/>

<br/>

> 페이지 폴트를 처리하는 과정
> 
1. 프로세스에 대한 내부 테이블을 검사해서 그 메모리 참조가 유효인지 무효인지 검사
2. 만약 무효한 페이지에 대한 참조라면 그 프로세스는 중단된다.
    1. 유효한 참조인데 페이지가 아직 메모리에 올라오지 않았다면, 보조저장장치로부터 가져와야 한다.
3. 빈 공간, 즉 가용 프레임을 찾는다.
4. 보조저장장치에 새로이 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청한다.
5. 보조저장장치 읽기가 끝나면, 이 페이지가 이제는 메모리에 있다는 것을 알리기 위해 페이지 테이블을 갱신하며, 프로세스가 유지하고 있는 내부 테이블을 수정한다.
6. 트랩에 의해 중단되었던 명령어를 다시 수행한다.

<br/>

<br/>

> 극단적인 경우: 메모리에 페이지가 ***하나도*** 안 올라와있는 상태에서도 프로세스를 실행할 수 있음!
> 
- OS에서 명령 포인터의 값을 프로세스의 첫 명령으로 설정하는 순간?
    - → 이 명령이 메모리에 존재하지 않는 페이지에 있으므로, 페이지 폴트를 발생!
- 페이지가 적재되고 나면 프로세스는 수행을 계속하는데, 페이지를 필요할 때마다 폴트가 발생
    - 일단 필요한 모든 페이지가 적재되고 나면 더 폴트가 발생하지는 않는다.
    - 이것이 순수 요구 페이징(`pure demand paging`)이다.

<br/>

<br/>

> 프로그램들은 한 명령어에서도 여러 개의 페이지 폴트를 일으킬 수 있다.
> 
- 다행히 실행중인 프로세스들을 분석해보면 이러한 경우는 거의 발생하지 않는다.
    - 모든 프로그램은 **참조의 지역성**이라는 성질이 있어 어느 한 특정 작은 부분만 한동안 집중적으로 참조하는데, 이러한 성질 덕에 요구 페이징은 만족할 만한 성능을 보인다.

<br/>

<br/>

> 요구 페이징을 지원하기 위해 필요한 하드웨어는 페이지오가 스와핑을 위한 하드웨어와 동일하다.
> 
- 페이지 테이블 : 보호 비트들 특별한 값 또는 유효/무효 비트를 통해 특정 항목을 무효로 설정할 수 있다.
- 보조저장장치 : 메인 메모리에 없는 모든 페이지를 가지고 있다.
    - 보통 고성능 디스크 또는 NVM 장치로, 스왑 장치라고도 한다.
    - 이 목적을 위해 사용되는 저장장치 영역을 **스왑 공간**이라고 한다

<br/>

<br/>

> 한 명령어가 많은 기억 장소를 변경하는 것일 때에는 상당히 어려운 문제가 발생한다.
> 
- 이러한 문제는 두 가지 해결법이 있다.
    1. 마이크로코드로 양 블록의 두 끝을 계산해 겹치지 않는 것을 확인하기
        1. 만약 페이지 폴트가 발생할 가능성이 있다면 미리 페이지 폴트를 발생시킨다.
        2. 그 후에 이동을 시작하면 어떤 페이지 폴트도 일어날 수 없다.
    2. 이동에 의해서 이전의 내용이 지워질 기억 장소드의 값을 보존하기 위해 임시 레지스터들을 사용하기
        1. 복구의 용도로 사용

<br/>

<br/>

## 가용 프레임 리스트

> 페이지 폴트가 발생하면 운영체제는 요청된 페이지를 보조저장장치에서 메인 메모리로 가져와야 한다.
OS는 페이지 폴트를 해결하기 위해 가용 프레임의 풀인 **가용 프레임 리스트**를 유지한다.
> 
- 프로세스의 스택 또는 힙 세그먼트가 확장될 때도 가용 프레임이 할당 되어야 한다!
    - OS는 일반적으로 **zero-fill-on-demand**라는 기법을 사용!
        
        <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/10-background6.png" width = 500/>

        
    - 여기서 `Zero-fill-on-demand` 프레임은 할당되기 전에 0으로 모두 채워져 이전 내용이 지워진다.

<br/>

<br/>

## 요구 페이징의 성능

> 요구 페이징은 컴퓨터 시스템의 성능에 큰 영향을 줄 수 있다.
> 

→ 요구 페이지 메모리에 대한 **실질 접근 시간**을 계산해보자.

<br/>

<br/>

> 페이지 폴트의 확률 p(0 ≤ p ≤1)
> 
- 실질 접근 시간 = (1-p) * ma + p * 페이지 폴트 시간

<br/>

<br/>

> 페이지 폴트의 처리 순서
> 
1. 운영체제에 트랩을 요청
2. 레지스터들과 프로세스 상태를 저장
3. 인터럽트 원인이 페이지 폴트임을 알아냄
4. 페이지 참조가 유효한 것인지 확인하고, 보조저장장치에 있는 페이지의 위치를 알아냄.
5. 저장장치에 가용 프레임으로의 읽기 요구를 냄
    1. 읽기 차례가 돌아오기까지 대기 큐에서 기다린다.
    2. 디스크에서 찾는 시간과 회전 지연 시간 동안 기다린다.
    3. 가용 프레임으로 페이지 전송을 시작한다.
6. 기다리는 동안 CPU 코어는 다른 사용자에게 할당
7. 저장장치가 다 읽었다고 인터럽트를 검
8. 다른 프로세스의 레지스터들과 프로세스 상태를 저장
9. 인터럽트가 보조저장장치로부터 왔다는 것을 알아냄
10. 새 페이지가 메모리로 올라왔다는 것을 페이지 테이블과 다른 테이블들에 기록
11. CPU 코어가 자기 차례로 오기까지 다시 기다림
12. CPU 차례가 오면 위에서 저장시켜 두었던 레지스터들, 프로세스 상태, 새로운 페이지 테이블을 복원시키고 인터럽트 되었던 명령어를 다시 실행

<br/>

<br/>

> 어떤 경우에도, 페이지 폴트 처리 시간은 다음 3개의 주요 작업 요소로 이루어져 있음을 알 수 있다.
> 
1. 인터럽트의 처리
2. 페이지 읽기
3. 프로세스 재시작

<br/>

<br/>

> 실질 접근 시간 구하기 예시
> 
- 평균 페이지 폴트 처리 시간이 8밀리초이고, 메모리 접근 시간이 200나노초 임을 가정
- 실질 접근 시간 = (1-p) * 200 + p * (8milliseconds)
= (1-p) * 200 + p * 8,000,000 = 200 + 7,999,800 * p

<br/>

<br/>

**→ 실제 접근 시간은 페이지 폴트율에 비례한다!**

> 요구 페이징의 또 다른 특성 중 하나는 스왑 공간의 관리이다.
> 
- 스왑 공간에서의 디스크 I/O은 일반적으로 파일 시스템에서의 입출력보다 빠르다.
    - → 스왑 공간은 파일 시스템보다 더 큰 블록을 사용하기 때문!
    - 또 스왑 공간과 입출력을 할 때는 파일 찾기나 간접 할당 방법 등을 사용하지 않기 때문!

<br/>

<br/>

> 어떤 시스템들은 실행 파일을 스왑 공간에 넣지 않음으로써 스왑 공간의 크기를 줄이기도 한다.
> 
- 실행 파일로부터 요구 페이지를 요청하면 파일 시스템으로부터의 그 페이지를 직접 가져온다.
- 이 페이지들의 교체가 필요하면 이들 페이지에 새 페이지의 내용을 덮어쓸 수 있다.
- 페이지가 다시 필요해지면 추후 파일 시스템으로부터 다시 읽어 들일 수 있다.
    - → 이러한 방식에선 파일 시스템이 백업 저장장치로 사용됨!
    - 그러나 스왑 공간은 여전히 파일과 관련이 없는 페이지 때문에 필요하다.
        - → 이러한 메모리를 **익명(anonymous) 메모리**라고 한다.


<br/>

<br/>

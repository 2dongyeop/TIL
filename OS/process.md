# 프로세스

오늘날의 컴퓨터 시스템은 메모리에 다수의 프로그램이 적재되어 병행 실행 되는 것을 허용한다.

이러한 발전은 다양한 프로그램을 보다 견고하게 제어하고, 보다 구획화할 것을 필요로 했다.

→ 이러한 필요성이 프로세스의 개념을 낳았다.

<br/>

<br/>

 프로세스란? 
- 실행 중인 프로그램을 말하며, 현대의 컴퓨팅 시스템에서 작업의 단위이다.
- 모든 프로세스는 잠재적으로 병행 실행이 가능하고, CPU는 이들 프로세스 가운데서 다중화된다.

<br/>

<br/>

> 💡 *이 장의 목표*
>
>- 프로세스의 개별 구성 요소를 식별하고, 운영체제에서 해당 구성요소가 어떻게 표현되고 스케줄되는지 기술한다.
>- 운영체제에서 프로세스를 생성하고 종료하는 방법을 설명한다.
>- 공유 메모리 및 메시지 전달을 사용하는 프로세스 간 통신을 설명하고 대조한다.

<br/>

<br/>

## 💡 프로세스 개념

- 초창기 컴퓨터는 **작업**을 실행하는 일괄처리 시스템이었다.
    - 이후, **사용자 프로그램** 또는 **태스크**를 실행하는 시분할 시스템이 뒤를 이었다.

<br/>

<br/>

- 우리는 개인적으로 더 현대적인 용어인 ***프로세스***를 선호하지만, 운영체제의 주요 활동이 작업 처리인 시절에 많은 운영체제 이론 및 용어가 개발되었기 때문에 작업이라는 ***용어***는 중요한 의미가 있따.
    - 따라서 일부 적절한 경우 운영체제의 역할을 설명할 때 작업을 사용한다.

<br/>

<br/>

### 프로세스

- 프로세스의 현재 활동 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다.
    - 프로세스의 메모리 배치는 아래 사진과 같이 여러 섹션으로 구분된다.
        
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/layout.png" width = 600/>
        

- 텍스트 및 데이터 섹션
    - 크기가 고정되어 프로그램 실행 시간 동안 크기가 변하지 않는다.
- 스택 및 힙 섹션
    - 실행 중에 동적으로 크기가 바뀐다.
    - 함수가 호출될 때마다 **활성화 레코드**가 스택에 푸시된다.
    - 스택 및 힙 섹션은 ***서로의 방향***으로 커지더라도 운영체제는 ***서로 겹치지 않도록*** 해야 한다.

<br/>

<br/>

- 프로그램과 프로세스는 다르다.
    - 프로그램은 디스크에 저장된 파일과 같은 **수동적인** 존재이다.
    - 프로세스는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인** 존재다.

<br/>

<br/>

- 두 프로세스들이 동일한 프로그램에 연관될 수 있지만, 이들은 두 개의 별도의 실행 순서로 간주한다.
    - 또한 프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있다!
    - 가장 좋은 예시로 Java 프로그래밍 환경의 JVM이 존재한다.

<br/>

<br/>

### 프로세스 상태

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/process-state.png" width = 600/>

- 프로세스는 실행되면서 그 상태가 변한다.
    - ***new***(새로운) : 프로세스가 생성 중
    - ***running***(실행) : 명령어들이 실행 중
    - ***waiting***(대기) : 이벤트가 일어나기를 대기 중
    - ***ready***(준비) : 프로세스가 처리기에 할당되기를 대기
    - ***terminated***(종료) : 프로세스의 실행이 종료

<br/>

<br/>

- ***어느 한 순간에 한 처리기 코어에서 우직 하나의 프로세스만이 실행된다는 것을 인지하자!***

<br/>

<br/>

### 프로세스 제어 블록

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/PCB.png" width = 600/>

- 각 프로세스는 운영체제에서 **프로세스 제어 블록(PCB)**에 의해 표현된다.
    - 특정 프로세스와 연관된 여러 정보를 수록한다.

<br/>

<br/>

- PCB의 내용
    - 프로세스 상태
    - 프로그램 카운터
    - CPU 레지스터들
    - CPU-스케줄링 정보
    - 메모리 관리 정보
    - 회계 정보
    - 입출력 상태 정보

<br/>

<br/>

### 스레드

- 이제까지 논의한 프로세스 모델은 프로세스가 단일의 실행 **스레드**를 실행하는 프로그램임을 암시했다.
    
    → 단일 제어 스레드 : 프로세스가 한 번에 한 가지 일만 실행하도록 허락한다.
    
<br/>

<br/>


- 현대의 운영체제는 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허락한다.
    - 이러한 특성으로 다중 처리기 시스템에서 이익을 얻을 수 있다! (스레드 병렬 실행)

<br/>

<br/>

## 💡 프로세스 스케줄링

- 다중 프로그래밍의 목적
    - CPU 이용을 최대화하기 위해 항상 어떤 프로세스가 실행되도록 하는 데 있다.

<br/>

<br/>

- 시분할의 목적
    - 각 프로그램이 실행되는 동안 사용자가 상호작용할 수 있도록 CPU 코어를 빈번하게 교체하는 것.
    - 이를 위해 **프로세스 스케줄러**는 실행 가능한 여러 프로세스 중 하나의 프로세스를 선택한다.

<br/>

<br/>

- 코어보다 많은 프로세스가 이는 경우 초과 프로세스는 기다려야 한다.
    - 현재 메모리에 있는 프로세스 수를 **다중 프로그래밍 정도**라고 한다.

<br/>

<br/>

- ***다중 프로그래밍 및 시간 공유의 목표를 균형있게 유지하자!***
    - I/O 바운드 프로세스 : 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비
    - CPU 바운드 프로세스 : 계산에 더 많은 시간을 사용!

<br/>

<br/>

### 스케줄링 큐

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/ready-queue.png" width = 600/>

- 프로세스가 실행 시스템에 들어가면 **준비 큐**에 들어가서 준비 상태가 된다.
    - 이외에도 시스템에는 다른 큐도 존재한다!
    - ex) 어떤 이벤트가 발생하길 기다릴 때 → **대기 큐**

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/Queueing-diagram.png" width = 600/>

- **큐잉 다이어그램**은 프로세스 스케줄링의 일반적인 표현을 보여준다.
    - 원은 큐에 서비스를 제공하는 자원을 나타내고, 화살표는 흐름을 나타낸다.

<br/>

<br/>

- 새 프로세스는 처음에 준비 큐에 놓이고, 선택되거나 **디스패치** 될 때까지 기다린다.
    - 이후, CPU가 할당되고 실행 상태가 되면 여러 이벤트가 발생할 수 있다!
        - 프로세스가 I/O 요청을 공표해 대기 큐에 놓일 수 있다.
        - 새 자식 프로세스를 만들고 자식이 끝나기를 기다리며 대기 큐에 놓일 수 있다.
        - 인터럽트 또는 타입 슬라이스가 만료되어 강제로 제거되어 준비 큐로 돌아갈 수 있다.

<br/>

<br/>

### CPU 스케줄링

- 프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다.
    - **CPU 스케줄러**는 준비 큐에 있는 프로세스 중 하나에 CPU 코어를 할당한다!

<br/>

<br/>

- CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다.
    - 한 프로세스에게 오랜 시간동안 코어를 부여할 가능성은 없다.

<br/>

<br/>

- 일부 운영체제는 **스와핑**으로 알려진 스케줄링을 가진다.
    - 이는 메모리에서 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시키는 것이다. → 스왑 아웃
    - 이후 디스크에서 메모리로 “스왑인”을 통해 상태를 복원 할 수 있다.

<br/>

<br/>

### 문맥 교환

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/context-switch.png" width = 600/>

- 인터럽트가 발생하면 시스템은 처리가 끝나고 **문맥**을 복구할 수 있도록 해야 한다.
    - 이는 결국 프로세스를 중단했다가 재개하는 작업인데, 문맥은 프로세스의 PCB에 표현된다.
    - 이러한 작업을 문맥 교환(`context switch`)라고 한다.

<br/>

<br/>

- 문맥 교환이 진행될 동안 시스템이 아무런 일을 못한다 → ***문맥 교환 시간은 순수한 오버헤드이다!***
    - 그리고, 문맥 교환 시간은 하드웨어의 지원에 크게 좌우된다.

<br/>

<br/>

## 💡 프로세스에 대한 연산

- 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.

<br/>

<br/>

### 프로세스 생성

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/process-tree.png" width = 600/>

- 프로세스는 새로운 프로세스를 생성할 수 있고, 그 결과는 프로세스의 **트리**가 형성된다.
    - 이때, 프로세스를 구분하는 데는 **프로세스 식별자(pid)**가 사용된다.

<br/>

<br/>

- pid가 1인 systemd 프로세스는 모든 사용자 프로세스의 부모이다.
    - UNIX와 Linux에서는 ps 명령어로 프로세스들의 목록을 확인할 수 있다.
    - `ps -el`

<br/>

<br/>

- 일반적으로 프로세스가 새로운 자식 프로세스를 생성할 때
    - 자식의 자원은 운영체제로부터 직접 얻거나, 부모의 자원만을 사용하도록 제한되어 있다.

<br/>

<br/>

- 프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두 가지 방법이 존재한다.
    1. 부모는 자식과 병행하게 실행을 계속한다.
    2. 부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.

<br/>

<br/>

- 새로운 프로세스들의 주소 공간 측면을 볼 때 다음과 같은 두 가지 가능성이 있다.
    1. 자식 프로세스는 부모 프로세스의 복사본이다.
    2. 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/fork.png" width = 600/>


- UNIX 명령어로 살펴보는 간단 예시
    - `fork()` : 새로운 프로세스 생성
    - `wait()` : 자식이 종료될 때까지 대기
    - `exec()` : 메모리에 적재한 후 프로그램을 실행

<br/>

<br/>

### 프로세스 종료

- 프로세스가 마지막 실행을 끝내고, `exit` 시스템콜을 이용해 종료될 수 있다.
- 다른 경우로는, 한 프로세스가 다른 프로세스의 종료를 유발할 수 있다!
    - 통상적으로 부모만이 자식을 종료되도록 할 수 있다.
    - ***이때, 자식을 종료시키기 위해 자식의 pid를 알아야 한다는 것에 유의하자!***

<br/>

<br/>

- 부모는 아래와 같은 이유로 자식을 종료할 수 있다.
    - 자식이 자신에게 할당된 자원을 초과하여 사용할 때
    - 자식에게 할당된 태스크가 더 이상 필요 없을 때
    - 부모가 exit을 하는데, 운영체제는 부모가 exit 한 후에 자식이 실행을 계속함을 허용하지 않는 경우

<br/>

<br/>

- 몇몇 시스템에선 부모 프로세스가 종료한 이후 자식 프로세스가 존재할 수 없다.
    - 이때는 부모가 종료되면 자식들도 종료되어야 하는데 이를 **연쇄식 종료**라고 한다.

<br/>

<br/>

- 프로세스를 종료하면 사용하던 자원은 운영체제가 되찾아 간다.
    - 단, 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 부모의 wait() 명령을 기다린다.
    - 이를 **좀비 프로세스**라고 한다.

<br/>

<br/>

**Android 프로세스 계층**

- 모바일 운영체제는 제한된 시스템 자원을 회수하기 위해 기존 프로세스를 종료할 수 있다.
    - 따라서 프로세스의 ***중요도 계층***을 식별하여, 중요도가 낮은 프로세스부터 종료시킨다.
        - forground process : 화면에 보이는 프로세스
        - visible process : 전경에 표시되는 활동을 수행하는 프로세스
        - service process : 사용자가 인지할 수 있는 활동을 수행하는 프로세스
        - background process : 활동을 수행하지만 사용자가 인지하지 못하는 프로세스
        - empty process : 응용과 관련된 활성 구성요소가 없는 프로세스


<br/>

<br/>

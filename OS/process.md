# 프로세스

오늘날의 컴퓨터 시스템은 메모리에 다수의 프로그램이 적재되어 병행 실행 되는 것을 허용한다.

이러한 발전은 다양한 프로그램을 보다 견고하게 제어하고, 보다 구획화할 것을 필요로 했다.

→ 이러한 필요성이 프로세스의 개념을 낳았다.

<br/>

<br/>

 프로세스란? 
- 실행 중인 프로그램을 말하며, 현대의 컴퓨팅 시스템에서 작업의 단위이다.
- 모든 프로세스는 잠재적으로 병행 실행이 가능하고, CPU는 이들 프로세스 가운데서 다중화된다.

<br/>

<br/>

> 💡 *이 장의 목표*
>
>- 프로세스의 개별 구성 요소를 식별하고, 운영체제에서 해당 구성요소가 어떻게 표현되고 스케줄되는지 기술한다.
>- 운영체제에서 프로세스를 생성하고 종료하는 방법을 설명한다.
>- 공유 메모리 및 메시지 전달을 사용하는 프로세스 간 통신을 설명하고 대조한다.

<br/>

<br/>

## 💡 프로세스 개념

- 초창기 컴퓨터는 **작업**을 실행하는 일괄처리 시스템이었다.
    - 이후, **사용자 프로그램** 또는 **태스크**를 실행하는 시분할 시스템이 뒤를 이었다.

<br/>

<br/>

- 우리는 개인적으로 더 현대적인 용어인 ***프로세스***를 선호하지만, 운영체제의 주요 활동이 작업 처리인 시절에 많은 운영체제 이론 및 용어가 개발되었기 때문에 작업이라는 ***용어***는 중요한 의미가 있따.
    - 따라서 일부 적절한 경우 운영체제의 역할을 설명할 때 작업을 사용한다.

<br/>

<br/>

### 프로세스

- 프로세스의 현재 활동 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다.
    - 프로세스의 메모리 배치는 아래 사진과 같이 여러 섹션으로 구분된다.
        
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/layout.png" width = 600/>
        

- 텍스트 및 데이터 섹션
    - 크기가 고정되어 프로그램 실행 시간 동안 크기가 변하지 않는다.
- 스택 및 힙 섹션
    - 실행 중에 동적으로 크기가 바뀐다.
    - 함수가 호출될 때마다 **활성화 레코드**가 스택에 푸시된다.
    - 스택 및 힙 섹션은 ***서로의 방향***으로 커지더라도 운영체제는 ***서로 겹치지 않도록*** 해야 한다.

<br/>

<br/>

- 프로그램과 프로세스는 다르다.
    - 프로그램은 디스크에 저장된 파일과 같은 **수동적인** 존재이다.
    - 프로세스는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인** 존재다.

<br/>

<br/>

- 두 프로세스들이 동일한 프로그램에 연관될 수 있지만, 이들은 두 개의 별도의 실행 순서로 간주한다.
    - 또한 프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있다!
    - 가장 좋은 예시로 Java 프로그래밍 환경의 JVM이 존재한다.

<br/>

<br/>

### 프로세스 상태

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/process-state.png" width = 600/>

- 프로세스는 실행되면서 그 상태가 변한다.
    - ***new***(새로운) : 프로세스가 생성 중
    - ***running***(실행) : 명령어들이 실행 중
    - ***waiting***(대기) : 이벤트가 일어나기를 대기 중
    - ***ready***(준비) : 프로세스가 처리기에 할당되기를 대기
    - ***terminated***(종료) : 프로세스의 실행이 종료

<br/>

<br/>

- ***어느 한 순간에 한 처리기 코어에서 우직 하나의 프로세스만이 실행된다는 것을 인지하자!***

<br/>

<br/>

### 프로세스 제어 블록

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/PCB.png" width = 600/>

- 각 프로세스는 운영체제에서 **프로세스 제어 블록(PCB)**에 의해 표현된다.
    - 특정 프로세스와 연관된 여러 정보를 수록한다.

<br/>

<br/>

- PCB의 내용
    - 프로세스 상태
    - 프로그램 카운터
    - CPU 레지스터들
    - CPU-스케줄링 정보
    - 메모리 관리 정보
    - 회계 정보
    - 입출력 상태 정보

<br/>

<br/>

### 스레드

- 이제까지 논의한 프로세스 모델은 프로세스가 단일의 실행 **스레드**를 실행하는 프로그램임을 암시했다.
    
    → 단일 제어 스레드 : 프로세스가 한 번에 한 가지 일만 실행하도록 허락한다.
    
<br/>

<br/>


- 현대의 운영체제는 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허락한다.
    - 이러한 특성으로 다중 처리기 시스템에서 이익을 얻을 수 있다! (스레드 병렬 실행)

<br/>

<br/>

## 💡 프로세스 스케줄링

- 다중 프로그래밍의 목적
    - CPU 이용을 최대화하기 위해 항상 어떤 프로세스가 실행되도록 하는 데 있다.

<br/>

<br/>

- 시분할의 목적
    - 각 프로그램이 실행되는 동안 사용자가 상호작용할 수 있도록 CPU 코어를 빈번하게 교체하는 것.
    - 이를 위해 **프로세스 스케줄러**는 실행 가능한 여러 프로세스 중 하나의 프로세스를 선택한다.

<br/>

<br/>

- 코어보다 많은 프로세스가 이는 경우 초과 프로세스는 기다려야 한다.
    - 현재 메모리에 있는 프로세스 수를 **다중 프로그래밍 정도**라고 한다.

<br/>

<br/>

- ***다중 프로그래밍 및 시간 공유의 목표를 균형있게 유지하자!***
    - I/O 바운드 프로세스 : 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비
    - CPU 바운드 프로세스 : 계산에 더 많은 시간을 사용!

<br/>

<br/>

### 스케줄링 큐

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/ready-queue.png" width = 600/>

- 프로세스가 실행 시스템에 들어가면 **준비 큐**에 들어가서 준비 상태가 된다.
    - 이외에도 시스템에는 다른 큐도 존재한다!
    - ex) 어떤 이벤트가 발생하길 기다릴 때 → **대기 큐**

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/Queueing-diagram.png" width = 600/>

- **큐잉 다이어그램**은 프로세스 스케줄링의 일반적인 표현을 보여준다.
    - 원은 큐에 서비스를 제공하는 자원을 나타내고, 화살표는 흐름을 나타낸다.

<br/>

<br/>

- 새 프로세스는 처음에 준비 큐에 놓이고, 선택되거나 **디스패치** 될 때까지 기다린다.
    - 이후, CPU가 할당되고 실행 상태가 되면 여러 이벤트가 발생할 수 있다!
        - 프로세스가 I/O 요청을 공표해 대기 큐에 놓일 수 있다.
        - 새 자식 프로세스를 만들고 자식이 끝나기를 기다리며 대기 큐에 놓일 수 있다.
        - 인터럽트 또는 타입 슬라이스가 만료되어 강제로 제거되어 준비 큐로 돌아갈 수 있다.

<br/>

<br/>

### CPU 스케줄링

- 프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다.
    - **CPU 스케줄러**는 준비 큐에 있는 프로세스 중 하나에 CPU 코어를 할당한다!

<br/>

<br/>

- CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다.
    - 한 프로세스에게 오랜 시간동안 코어를 부여할 가능성은 없다.

<br/>

<br/>

- 일부 운영체제는 **스와핑**으로 알려진 스케줄링을 가진다.
    - 이는 메모리에서 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시키는 것이다. → 스왑 아웃
    - 이후 디스크에서 메모리로 “스왑인”을 통해 상태를 복원 할 수 있다.

<br/>

<br/>

### 문맥 교환

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/context-switch.png" width = 600/>

- 인터럽트가 발생하면 시스템은 처리가 끝나고 **문맥**을 복구할 수 있도록 해야 한다.
    - 이는 결국 프로세스를 중단했다가 재개하는 작업인데, 문맥은 프로세스의 PCB에 표현된다.
    - 이러한 작업을 문맥 교환(`context switch`)라고 한다.

<br/>

<br/>

- 문맥 교환이 진행될 동안 시스템이 아무런 일을 못한다 → ***문맥 교환 시간은 순수한 오버헤드이다!***
    - 그리고, 문맥 교환 시간은 하드웨어의 지원에 크게 좌우된다.

<br/>

<br/>

## 💡 프로세스에 대한 연산

- 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.

<br/>

<br/>

### 프로세스 생성

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/process-tree.png" width = 600/>

- 프로세스는 새로운 프로세스를 생성할 수 있고, 그 결과는 프로세스의 **트리**가 형성된다.
    - 이때, 프로세스를 구분하는 데는 **프로세스 식별자(pid)**가 사용된다.

<br/>

<br/>

- pid가 1인 systemd 프로세스는 모든 사용자 프로세스의 부모이다.
    - UNIX와 Linux에서는 ps 명령어로 프로세스들의 목록을 확인할 수 있다.
    - `ps -el`

<br/>

<br/>

- 일반적으로 프로세스가 새로운 자식 프로세스를 생성할 때
    - 자식의 자원은 운영체제로부터 직접 얻거나, 부모의 자원만을 사용하도록 제한되어 있다.

<br/>

<br/>

- 프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두 가지 방법이 존재한다.
    1. 부모는 자식과 병행하게 실행을 계속한다.
    2. 부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.

<br/>

<br/>

- 새로운 프로세스들의 주소 공간 측면을 볼 때 다음과 같은 두 가지 가능성이 있다.
    1. 자식 프로세스는 부모 프로세스의 복사본이다.
    2. 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/fork.png" width = 600/>


- UNIX 명령어로 살펴보는 간단 예시
    - `fork()` : 새로운 프로세스 생성
    - `wait()` : 자식이 종료될 때까지 대기
    - `exec()` : 메모리에 적재한 후 프로그램을 실행

<br/>

<br/>

### 프로세스 종료

- 프로세스가 마지막 실행을 끝내고, `exit` 시스템콜을 이용해 종료될 수 있다.
- 다른 경우로는, 한 프로세스가 다른 프로세스의 종료를 유발할 수 있다!
    - 통상적으로 부모만이 자식을 종료되도록 할 수 있다.
    - ***이때, 자식을 종료시키기 위해 자식의 pid를 알아야 한다는 것에 유의하자!***

<br/>

<br/>

- 부모는 아래와 같은 이유로 자식을 종료할 수 있다.
    - 자식이 자신에게 할당된 자원을 초과하여 사용할 때
    - 자식에게 할당된 태스크가 더 이상 필요 없을 때
    - 부모가 exit을 하는데, 운영체제는 부모가 exit 한 후에 자식이 실행을 계속함을 허용하지 않는 경우

<br/>

<br/>

- 몇몇 시스템에선 부모 프로세스가 종료한 이후 자식 프로세스가 존재할 수 없다.
    - 이때는 부모가 종료되면 자식들도 종료되어야 하는데 이를 **연쇄식 종료**라고 한다.

<br/>

<br/>

- 프로세스를 종료하면 사용하던 자원은 운영체제가 되찾아 간다.
    - 단, 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 부모의 wait() 명령을 기다린다.
    - 이를 **좀비 프로세스**라고 한다.

<br/>

<br/>

**Android 프로세스 계층**

- 모바일 운영체제는 제한된 시스템 자원을 회수하기 위해 기존 프로세스를 종료할 수 있다.
    - 따라서 프로세스의 ***중요도 계층***을 식별하여, 중요도가 낮은 프로세스부터 종료시킨다.
        - forground process : 화면에 보이는 프로세스
        - visible process : 전경에 표시되는 활동을 수행하는 프로세스
        - service process : 사용자가 인지할 수 있는 활동을 수행하는 프로세스
        - background process : 활동을 수행하지만 사용자가 인지하지 못하는 프로세스
        - empty process : 응용과 관련된 활성 구성요소가 없는 프로세스


<br/>

<br/>

## 💡 프로세스 간 통신

- 운영체제 내에서 실행되는 병행 프로세스들은 독립적이거나 협력적인 프로세스가 있다.
    - ***독립적 : 다른 프로세스들과 데이터를 공유하지 않음***
    - ***협력적 : 다른 프로세스들에 영향을 주거나 받음***

<br/>

<br/>

- 프로세스 협력을 허용하는 환경을 제공하는 이유
    1. 정보 공유
    2. 계산 가속화
    3. 모듈성

<br/>

<br/>

- ***프로세스 간 통신(IPC) 기법***
    - 협력적 프로세스들이 데이터를 교환할 수 있도록 한다.
    - **공유 메모리 모델** : 공유되는 메모리의 영역을 따로 구축한다.
    - **메시지 전달 모델** : 프로세스들이 메시지를 교환하며 협력한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/IPC.png" width = 600/>

- ***메시지 전달 모델***
    - 충돌을 회피할 필요가 없다 → 적은 양의 데이터를 교환하는 데 유용!
    - 분산 시스템에서 공유 메모리보다 구현하기 쉽다.
- ***공유 메모리 모델***
    - 시스템 콜을 이용하는 메시지 전달 모델보다 속도가 빠르다.


<br/>

<br/>

## 💡 공유 메모리 시스템에서의 프로세스 간 통신

- 공유 메모리 모델에서는 통신하는 프로세스들이 공유 메모리 영역을 구축해야 한다.
    - ***일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 금지함을 기억하자!***
    - 따라서 둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 동의가 필요하다.

<br/>

<br/>

- 협력하는 프로세스의 개념 설명 ⇒ 생산자-소비자 문제
    - **생산자** 프로세스 : 정보를 생산
    - **소비자** 프로세스 : 정보를 소비
    - ex) 컴파일러가 생산한 어셈블리 코드를 어셈블러가 소비한다.

<br/>

<br/>

- 생산자-소비자 문제의 하나의 해결책은 공유 메모리를 사용하는 것이다.
    - 생산자와 소비자가 병행하려면? → 버퍼가 반드시 필요!
    - 이 버퍼는 생산자와 소비자가 공유하는 메모리 영역에 위치하고, 동기화되도록 노력해야 한다.

<br/>

<br/>

- 버퍼에는 두 가지 유형이 있다.
    - 무한 버퍼 : 버퍼의 크기에 실질적인 한계가 없다.
    - 유한 버퍼 : 버퍼의 크기가 고정되어 있다.
        - 버퍼가 비어있으면? → 소비자가 대기, 버퍼가 가득찼으면? → 생산자가 대기

<br/>

<br/>

## 💡 메시지 전달 시스템에서의 프로세스 간 통신

- 메시지 전달 방식은 통신하는 프로세스들이 네트워크에 의해 연결된 다른 컴퓨터에 존재할 수 있는 분산 환경에서 특히 유용하다.

<br/>

<br/>

- 메시지 전달 시스템은 최소한 두 가지 연산을 제공한다.
    - send(message)
    - receive(message)

<br/>

<br/>

- 고정 길이 메시지
    - 시스템 수준의 구현이 직선적이지만, 이러한 제한이 프로그래밍 작업을 힘들게 한다.
- 가변 길이 메시지
    - 프로그래밍 작업은 간단하지만, 복잡한 시스템 수준의 구현을 필요로 한다.

<br/>

<br/>

- 프로세스가 통신을 원하면 메시지를 주고 받을 **통신 연결**이 설정되어야 한다.
    - 연결의 논리적 구현 방법들
        - 직접 또는 간접 통신
        - 동기식 또는 비동기식 통신
        - 자동 또는 명시적 버퍼링

<br/>

<br/>

### 명명

- 통신을 원하는 프로세스들은 서로를 가리킬 방법이 필요하다 → 간접/직접 통신에 사용

<br/>

<br/>

- **직접 통신**에서는 송신자 또는 수신자의 이름을 명시해야 한다.
    - send(P, message) : P에게 전송
    - receive(Q, message) : Q로부터 수신

<br/>

<br/>

- 이 기법에서 통신 연결은 아래의 특성을 가진다.
    - 통신을 원하는 각 프로세스 쌍들 사이에 연결은 자동으로 구축된다.
        - 따라서 프로세스들은 상대방의 신원(identity)만 알면 된다.
    - 연결은 정확히 두 프로세스 사이에만 연관된다.
    - 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다.

<br/>

<br/>

- 이 기법은 주소 방식에서 **대칭성**을 보인다. (송신, 수신자 모두 상대방의 이름을 제시)
    - 변형으로는 **비대칭** 방식도 있다. (송신자만 수신자의 이름을 지명)

<br/>

<br/>

- 단, 이 기법은 프로세스를 지정하는 방식 때문에 모듈성을 제한한다는 단점이 있다!
    - 프로세스의 이름을 바꾸면 모든 프로세스 지정 부분을 검사해야 한다. (***하드 코딩***)

<br/>

<br/>

- **간접 통신**에서 메시지들은 ***메일박스 또는 포트***로 송신되고, 그것으로부터 수신된다.
    - 메일박스는 메시지들을 넣고 제거할 수 있는 객체라고 볼 수 있다.

<br/>

<br/>

- 이 방법에서 통신 연결은 아래의 성질을 가진다.
    - 한 쌍의 프로세스들 사이의 연결은 이들 프로세스가 공유 메일박스를 가질 때만 구축된다.
    - 연결은 두 개 이상의 프로세스들과 연관될 수 있다.
    - 통신하고 있는 각 프로세스 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응된다.

<br/>

<br/>

- 메일 박스는 한 프로세스 또는 운영체제에 의해 소유될 수 있다.
    - 프로세스에 의해 소유될 경우
        - 소유자와 메일박스의 사용자를 구분할 수 있다.
    - 운영체제에 의해 소유될 경우 : 자체적으로 존재
        - 독립적으로, 어떤 특정한 프로세스에 예속되지 않는다.

<br/>

<br/>

### 동기화

- 프로세스간 통신은 프리미티브에 대한 호출에 의해 발생한다.
    - 메시지 전달은 **블로킹**이나 **논블로킹** 방식으로 전달된다.
        - 이 두 방식은 각각 **동기식**, **비동기식**이라고도 알려져 있다.

<br/>

<br/>

- 봉쇄형 보내기 : 송신 프로세스는 수신 프로세스가 수신될 때까지 봉쇄된다.
- 비봉쇄형 보내기 : 송신 프로세스는 메시지를 보내고 작업을 재시작한다.
- 봉쇄형 받기 : 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다.
- 비봉쇄형 : 송신 프로세스가 유효한 메시지 또는 널을 받는다.

<br/>

<br/>

- send()와 receive()의 다른 조합도 가능하다!
    - send()와 receive()가 모두 봉쇄형일 때, ***랑데부(rendezvous)***를 하게 된다.

<br/>

<br/>

### 버퍼링

- 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어있고, 임시 큐를 구현하는 방식은 3가지가 있다.
    1. 무용량 : 큐의 최대 길이가 0이다. → ***버퍼가 없는 시스템***
        1. 즉, 링크는 자체 안에 대기하는 메시지를 가질 수 없다.
    2. 유한 용량 : 큐는 유한한 길이 n을 가진다.
        1. 즉, 최대 n개의 메시지가 그 안에 들어있을 수 있다.
    3. 무한 용량 : 큐는 잠재적으로 무한한 길이를 가진다.
        1. 메시지들은 얼마든지 큐에서 대기할 수 있고, 송신자는 절대 봉쇄되지 않는다.

<br/>

<br/>

## 💡 IPC 시스템의 사례

- 네 가지 다른 IPC 시스템을 탐구해보자!

<br/>

<br/>

### POSIX 공유 메모리

- POSIX 공유 메모리는 메모리-사상 파일을 사용하여 구현된다.
    - 메모리-사상 파일은 공유 메모리의 특정 영역을 파일과 연관시킨다.

<br/>

<br/>

### Mach 메시지 전달 모델

- Mach커널은 프로세스와 유사하지만, 제어 스레드가 많고 자원이 적은 ***다중 태스크***의 생성 및 제거를 지원
    - 모든 태스크 간 통신을 포함하여 Mach에서는 ***메시지***로 수행된다.
    - **포트(port)**라고 하는 메일박스로 메시지를 주고 받는다.

<br/>

<br/>

- 포트는 단방향이다. → 메시지 전달 포트 따로, 응답 포트 따로!
    - 송신자는 여러 개지만, 수신자는 오직 하나다.
    - 메시지 전달은 상호작용을 위해 객체 지향 접근 방식을 제공한다.

<br/>

<br/>

- 각 포트에는 그 포트와 상호작용하는 데 필요한 자격을 식별하도록 ***포트 권한 집합***이 있다.

<br/>

- 각 태스크는 부트스트랩 포트에 액세스할 수 있다. → 태스크가 생성한 포트를 부트스트랩 서버에 등록 가능

<br/>

- 각 포트와 관련된 큐는 크기가 제한되어 있다.
    - 메시지 전송 시 복사본이 큐에 들어오고, 이때 메시지는 동일한 우선순위를 가진다.
    - Mach는 선입선출 방식으로 큐에 삽입하지만, 절대적 순서를 보장하지 않는다.

<br/>

<br/>

### Windows

- Windows는 모듈화를 이용해 기능을 향상시키고, 새로운 기능을 구현하는 시간을 감소시킨 예이다.
    - 다중 운영 환경 또는 ***서브시스템***을 지원하며, 응용은 ***메시지 전달 기법***을 통해 통신한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/ALPC.png" width = 600/>

- Windows의 메시지 전달 설비는 **ALPC(고급 로컬 프로시저 호출 설비)**라 불린다.
    - 이는 널리 사용되는 표준 원격 프로시저 호출(RPC)와 같으나, Windows에 최적화되었다.
    - Windows는 **연결 포트**와 **통신 포트**의 두 가지 유형의 포트를 사용한다.

<br/>

<br/>

### 파이프

- 파이프는 두 프로세스가 통신할 수 있게 하는 전달자로서 동작한다.
    - 이는 초기 UNIX 시스템에서 동작하는 IPC 기법의 하나였다.

<br/>

<br/>

> 💡 파이프를 구현하기 위해 아래 4가지 문제를 고려해보자.
>
>1. 파이프가 단방향 통신 또는 양방향 통신을 허용하는가?
>2. 양방향 통신이 허용된다면 반이중 방식인가, 전이중 방식인가?
>3. 통신하는 두 프로세스 간에 부모-자식과 같은 특정 관계가 존재해야만 하는가?
>4. 파이프는 네트워크를 통하여 통신이 가능한가, 아니면 동일한 기계 안에 존재하는 두 프로세스끼리만 통신할 수 있는가?


<br/>

<br/>

**파이프의 종류 - 1. 일반 파이프**

- 일반 파이프는 생산자-소비자 형태로 두 프로세스 간의 통신을 허용한다.
    - 생산자는 파이프의 한 종단에 쓰고, 소비자는 다른 종단에서 읽는다.

<br/>

<br/>

- 일반 파이프는 파이프를 생성한 프로세스 이외에는 접근할 수 없다.
    - Windows에서는 **익명 파이프(`anonymous pipe`)**라고 불린다.
    - 이 파이프는 단방향이고 통신하는 프로세스는 부모-자식 관계여야 한다.

<br/>

<br/>

**파이프의 종류 - 2. 지명 파이프**

- 지명 파이프는 일반 파이프보다 더 강력한 통신 도구를 제공한다.
    - 통신은 양방향으로 가능하며, 부모-자식 관계도 필요로 하지 않는다.

<br/>

<br/>

- UNIX에서는 `FIFO`라고 부른다.
    - 양방향이지만, 반이중 전송만이 가능하다.


<br/>

<br/>

## 💡 클라이언트 서버 환경에서의 통신

> 클라이언트 서버에서 사용할 수 있는 두 가지 다른 통신 전략에 대해 설명한다.
 

<br/>

<br/>

### 소켓

- 소켓은 IP 주소와 포트 번호 두 가지를 접합(concatenate)해서 구별한다.

<br/>

<br/>

- 동작 방식
    1. 서버는 지정된 포트에 클라이언트 요청 메시지가 도착하기를 기다린다.
    2. 요청이 수신되면 서버는 클라이언트 소켓으로부터 연결 요청을 수락한다. → 연결 완성!
    3. Telnet, ftp, http 등의 특정 서비스를 구현하는 서버는 `well-known` 포트로부터 메시지를 기다림
    4. 클라이언트가 프로세스 연결을 요청하면 호스트 컴퓨터는 포트 번호를 부여한다.
        1. 이때, 모든 연결은 유일해야 한다.

<br/>

<br/>

- Java가 제공하는 소켓 서비스
    - **TCP**(연결 기반) 소켓은 Socket 클래스로 구현된다.
    - **UDP**(비연결 기반) 소켓은 DatagramSocket 클래스를 사용한다.

<br/>

<br/>
    

- Java 실습 코드 및 실행 결과

    <img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/socket-example.png" width = 600/>

<br/>

<br/>

### 원격 프로시저 호출(RPC)

- 원격 서비스와 관련한 가장 보편적인 형태 중 하나로, 네트워크에 연결된 두 시스템 사이의 통신을 담당한다

<br/>

<br/>

- IPC와 차이점
    - 전달되는 메시지가 구조화되어 있다. → 데이터의 패킷 수준을 넘어서게 된다!

<br/>

<br/>

- 시스템은 네트워크 주소는 하나지만, 서비스를 구별하기 위해 **포트**는 여러 개 가질 수 있다.
    - 원격 프로세스가 서비스를 받으려면 그에 대응되는 포트 주소로 메시지를 보내야 한다.

<br/>

<br/>

- RPC는 클라이언트가 원격 호스트의 프로시저 호출을 마치 자신의 프로시저를 호출하는 것처럼 한다.
    - = 클라이언트 쪽에 **스텁**을 제공하여 통신을 하는 데 필요한 자세한 사항들을 숨겨준다.
    - 스텁은 메시지 전달 기법을 사용하며 서버에 메시지를 전달하고, 필요한 값을 되돌려받는다.

<br/>

<br/>

- 또 다른 중요한 문제는 호출의 의미(`semantic`)이다.
    - 지역 프로시저 호출 : 극단적인 경우에만 실패
    - RPC : 네트워크 오류 혹은 메시지 중복 호출 등의 오류가 발생.
    - 이 문제를 해결하는 방법
        - ***운영체제가 메시지를 최대 한 번 실행하는 것이 아니라 정확히 한 번 처리되도록 보장해야 한다!***

<br/>

<br/>

- 또 다른 중요한 문제는 클라이언트와 서버 간의 통신 문제이다.
    - 프로시저 호출 : 바인딩을 통해 링킹, 적재, 실행 시점에 행해짐
    - RPC : 서버와 클라이언트에는 서로에 대한 완전한 정보가 없다! (공유 메모리의 부재)

<br/>

<br/>

- 이를 위해 두 가지 방법이 사용된다.
    1. 고정된 포트 주소 형태를 미리 정해놓기
    2. 랑데부 방식에 의해 동적으로 바인딩 하기

<br/>

<br/>

**Android RPC**

- Android 운영체제는 **바인더** 프레임워크에 포함된 풍부한 IPC 기법을 가진다.
    - 이 중 RPC는 프로세스가 다른 프로세스의 서비스를 요청할 수 있게 한다.

<br/>

<br/>

- Android는 **응용 프로그램 구성요소**를 프로그램에 유용성을 제공하는 기본 빌딩 블록으로 제공한다.
    - 이러한 응용 프로그램 구성요소 중 하나는 UI는 없지만 백그라운드로 실행되는 **서비스**이다.


<br/>

<br/>

# 프로세스

오늘날의 컴퓨터 시스템은 메모리에 다수의 프로그램이 적재되어 병행 실행 되는 것을 허용한다.

이러한 발전은 다양한 프로그램을 보다 견고하게 제어하고, 보다 구획화할 것을 필요로 했다.

→ 이러한 필요성이 프로세스의 개념을 낳았다.

<br/>

<br/>

 프로세스란? 
- 실행 중인 프로그램을 말하며, 현대의 컴퓨팅 시스템에서 작업의 단위이다.
- 모든 프로세스는 잠재적으로 병행 실행이 가능하고, CPU는 이들 프로세스 가운데서 다중화된다.

<br/>

<br/>

> 💡 *이 장의 목표*
>
>- 프로세스의 개별 구성 요소를 식별하고, 운영체제에서 해당 구성요소가 어떻게 표현되고 스케줄되는지 기술한다.
>- 운영체제에서 프로세스를 생성하고 종료하는 방법을 설명한다.
>- 공유 메모리 및 메시지 전달을 사용하는 프로세스 간 통신을 설명하고 대조한다.

<br/>

<br/>

## 💡 프로세스 개념

- 초창기 컴퓨터는 **작업**을 실행하는 일괄처리 시스템이었다.
    - 이후, **사용자 프로그램** 또는 **태스크**를 실행하는 시분할 시스템이 뒤를 이었다.

<br/>

<br/>

- 우리는 개인적으로 더 현대적인 용어인 ***프로세스***를 선호하지만, 운영체제의 주요 활동이 작업 처리인 시절에 많은 운영체제 이론 및 용어가 개발되었기 때문에 작업이라는 ***용어***는 중요한 의미가 있따.
    - 따라서 일부 적절한 경우 운영체제의 역할을 설명할 때 작업을 사용한다.

<br/>

<br/>

### 프로세스

- 프로세스의 현재 활동 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다.
    - 프로세스의 메모리 배치는 아래 사진과 같이 여러 섹션으로 구분된다.
        
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/layout.png" width = 600/>
        

- 텍스트 및 데이터 섹션
    - 크기가 고정되어 프로그램 실행 시간 동안 크기가 변하지 않는다.
- 스택 및 힙 섹션
    - 실행 중에 동적으로 크기가 바뀐다.
    - 함수가 호출될 때마다 **활성화 레코드**가 스택에 푸시된다.
    - 스택 및 힙 섹션은 ***서로의 방향***으로 커지더라도 운영체제는 ***서로 겹치지 않도록*** 해야 한다.

<br/>

<br/>

- 프로그램과 프로세스는 다르다.
    - 프로그램은 디스크에 저장된 파일과 같은 **수동적인** 존재이다.
    - 프로세스는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인** 존재다.

<br/>

<br/>

- 두 프로세스들이 동일한 프로그램에 연관될 수 있지만, 이들은 두 개의 별도의 실행 순서로 간주한다.
    - 또한 프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있다!
    - 가장 좋은 예시로 Java 프로그래밍 환경의 JVM이 존재한다.

<br/>

<br/>

### 프로세스 상태

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/process-state.png" width = 600/>

- 프로세스는 실행되면서 그 상태가 변한다.
    - ***new***(새로운) : 프로세스가 생성 중
    - ***running***(실행) : 명령어들이 실행 중
    - ***waiting***(대기) : 이벤트가 일어나기를 대기 중
    - ***ready***(준비) : 프로세스가 처리기에 할당되기를 대기
    - ***terminated***(종료) : 프로세스의 실행이 종료

<br/>

<br/>

- ***어느 한 순간에 한 처리기 코어에서 우직 하나의 프로세스만이 실행된다는 것을 인지하자!***

<br/>

<br/>

### 프로세스 제어 블록

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/PCB.png" width = 600/>

- 각 프로세스는 운영체제에서 **프로세스 제어 블록(PCB)**에 의해 표현된다.
    - 특정 프로세스와 연관된 여러 정보를 수록한다.

<br/>

<br/>

- PCB의 내용
    - 프로세스 상태
    - 프로그램 카운터
    - CPU 레지스터들
    - CPU-스케줄링 정보
    - 메모리 관리 정보
    - 회계 정보
    - 입출력 상태 정보

<br/>

<br/>

### 스레드

- 이제까지 논의한 프로세스 모델은 프로세스가 단일의 실행 **스레드**를 실행하는 프로그램임을 암시했다.
    
    → 단일 제어 스레드 : 프로세스가 한 번에 한 가지 일만 실행하도록 허락한다.
    
<br/>

<br/>


- 현대의 운영체제는 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허락한다.
    - 이러한 특성으로 다중 처리기 시스템에서 이익을 얻을 수 있다! (스레드 병렬 실행)

<br/>

<br/>

## 💡 프로세스 스케줄링

- 다중 프로그래밍의 목적
    - CPU 이용을 최대화하기 위해 항상 어떤 프로세스가 실행되도록 하는 데 있다.

<br/>

<br/>

- 시분할의 목적
    - 각 프로그램이 실행되는 동안 사용자가 상호작용할 수 있도록 CPU 코어를 빈번하게 교체하는 것.
    - 이를 위해 **프로세스 스케줄러**는 실행 가능한 여러 프로세스 중 하나의 프로세스를 선택한다.

<br/>

<br/>

- 코어보다 많은 프로세스가 이는 경우 초과 프로세스는 기다려야 한다.
    - 현재 메모리에 있는 프로세스 수를 **다중 프로그래밍 정도**라고 한다.

<br/>

<br/>

- ***다중 프로그래밍 및 시간 공유의 목표를 균형있게 유지하자!***
    - I/O 바운드 프로세스 : 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비
    - CPU 바운드 프로세스 : 계산에 더 많은 시간을 사용!

<br/>

<br/>

### 스케줄링 큐

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/ready-queue.png" width = 600/>

- 프로세스가 실행 시스템에 들어가면 **준비 큐**에 들어가서 준비 상태가 된다.
    - 이외에도 시스템에는 다른 큐도 존재한다!
    - ex) 어떤 이벤트가 발생하길 기다릴 때 → **대기 큐**

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/Queueing-diagram.png" width = 600/>

- **큐잉 다이어그램**은 프로세스 스케줄링의 일반적인 표현을 보여준다.
    - 원은 큐에 서비스를 제공하는 자원을 나타내고, 화살표는 흐름을 나타낸다.

<br/>

<br/>

- 새 프로세스는 처음에 준비 큐에 놓이고, 선택되거나 **디스패치** 될 때까지 기다린다.
    - 이후, CPU가 할당되고 실행 상태가 되면 여러 이벤트가 발생할 수 있다!
        - 프로세스가 I/O 요청을 공표해 대기 큐에 놓일 수 있다.
        - 새 자식 프로세스를 만들고 자식이 끝나기를 기다리며 대기 큐에 놓일 수 있다.
        - 인터럽트 또는 타입 슬라이스가 만료되어 강제로 제거되어 준비 큐로 돌아갈 수 있다.

<br/>

<br/>

### CPU 스케줄링

- 프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다.
    - **CPU 스케줄러**는 준비 큐에 있는 프로세스 중 하나에 CPU 코어를 할당한다!

<br/>

<br/>

- CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다.
    - 한 프로세스에게 오랜 시간동안 코어를 부여할 가능성은 없다.

<br/>

<br/>

- 일부 운영체제는 **스와핑**으로 알려진 스케줄링을 가진다.
    - 이는 메모리에서 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시키는 것이다. → 스왑 아웃
    - 이후 디스크에서 메모리로 “스왑인”을 통해 상태를 복원 할 수 있다.

<br/>

<br/>

### 문맥 교환

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/context-switch.png" width = 600/>

- 인터럽트가 발생하면 시스템은 처리가 끝나고 **문맥**을 복구할 수 있도록 해야 한다.
    - 이는 결국 프로세스를 중단했다가 재개하는 작업인데, 문맥은 프로세스의 PCB에 표현된다.
    - 이러한 작업을 문맥 교환(`context switch`)라고 한다.

<br/>

<br/>

- 문맥 교환이 진행될 동안 시스템이 아무런 일을 못한다 → ***문맥 교환 시간은 순수한 오버헤드이다!***
    - 그리고, 문맥 교환 시간은 하드웨어의 지원에 크게 좌우된다.

<br/>

<br/>


# 입출력 시스템

## 💡 개관 _Overview

> 입출력 장치 관련 기술들은 두 가지의 상충하는 궤도를 따라간다.
> 
- 한편으로는 관련 인터페이스의 표준화가 늘어나고 있다는 것이다.
    - → 이런 경향은 새로 나오는 장치들이 기존 시스템에 쉽게 결합할 수 있도록 하기 위함이다.
- 다른 경향으로는 입출력 장치가 갈수록 다양해진다는 것이다.
    - → 몇몇 장치들은 기존 장치와는 너무 다르다.
    - 이러한 문제는 하드웨어와 소프트웨어 기술들의 조합에 의해 해결될 수 있다.

<br/>

<br/>

> 장치 드라이버의 역할
> 
- 모든 하드웨어를 일관된 인터페이스로 표현해 주며, 이러한 인터페이스를 그보다 상위층인 커널의 입출력 서비스 시스템의 제공한다.

<br/>

<br/>

# 💡 입출력 하드웨어 _ I/O Hardware

> 하드웨어 장치는 케이블을 통하거나 무선으로 신호를 보냄으로써 컴퓨터 시스템과 통신한다.
> 
- 이들 장치는 **포트**라 불리는 연결점을 통해 컴퓨터와 접속한다.
    - 만약 하나 이상의 장치들이 공동으로 여러 선을 사용하면, 이 선을 **버스**라 부른다.

<br/>

<br/>

> 버스의 정의는 회선의 집합으로써 이를 통해 어떻게 메시지를 주고 받는지를 정한 프로토콜까지 포함이다.
> 
- 전자적으로 보면, 메시지는 미리 정해진 시간에 맞추어 전선에 보내지는 전압의 패턴에 의해 전달된다.
    - 만일 장치 A가 B에 연결되고, B가 C, 이어 C가 컴퓨터의 포트에까지 연결되었으면?
        - → **데이지 체인**(daisy chain)이라고 부른다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-1.png" width = 500/>

> 버스는 컴퓨터 구조에서 널리 사용되고 신호 방식, 속도, 처리량 및 연결 방식에 따라 다양한 종류가 있다.
> 
- 위 그림에서는 **PCI 버스**가 프로세서-메모리 서브시스템을 고속 장치와 키보드와 직렬, USB 포트처럼 상대적으로 느린 장치들을 연결하는 **확장 버스**에 연결하는 모습을 나타낸다.
- 그림의 왼쪽 하단은 네 개의 디스크가 SAS 컨트롤러에 접속된 **직렬연결 SCSI** 버스에 연결되어 있다.

<br/>

<br/>

> 컨트롤러는 포트, 버스 또는 장치를 작동할 수 있는 전자장치 집합체이다.
> 
- 직렬 포트 컨트롤러는 간단한 장치 컨트롤러이다.
    - 직렬 포트의 전선에 나타나는 전기신호를 제어하는 데 쓰이고 하나의 칩으로 나온다.
    - 반대로 광섬유 채널(FC) 버스 컨트롤러는 간단하지 않다.
        - FC 프로토콜은 복잡하고, PC가 아닌 데이터 센터에서 사용되기 때문에 종종 컴퓨터의 버스에 연결되는 별도의 회로 보드 또는 **호스트 버스 어댑터(HBA)**로 구현된다.

<br/>

<br/>

## 메모리 맵드 입출력

> 모든 컨트롤러는 레지스터를 가지고 있다.
> 
- 본체의 프로세서는 이들 컨트롤러의 레지스터에 비트 패턴을 쓰거나 읽음으로써 입출력을 수행한다.
    - 이러한 통신을 수행하는 한 방법은 “특별한 입출력 명렁어”를 사용하는 것이다.
    - 이들 입출력 명령어는 한 바이트나 워드를 어떤 입출력 포트 주소로 전달하는 것이다.

<br/>

<br/>

- 다른 방법으로 장치 제어 레지스터를 프로세서의 주소 공간으로 사상하는 것이 있다.
    - 이러한 방식이 **메모리 맵드 입출력 방식**이다.
    - 이 경우 각 주변 장치 레지스터들은 메모리 주소와 일대일 대응이다.
    - CPU는 물리 메모리에 사상된 장치-제어 레지스터를 읽고 쓸 때 표준 데이터 전송 명령을 사용함으로써 입출력 요청을 수행하게 된다.

<br/>

<br/>

> 입출력 장치 컨트롤러는 보통 네 개의 레지스터로 구성되어 있다.
> 
- ***입력 레지스터***
    - 호스트가 입력을 얻기 위해 읽기를 수행한다.
- ***출력 레지스터***
    - 호스트가 데이터를 출력하기 위해 쓰기를 수행한다.
- ***상태 레지스터***
    - 호스트가 읽는 용도이다.
    - 이 비트들은 현재의 명령이 완료되었는지, 입력 레지스터로부터 한 바이트를 읽어도 되는지,
    그리고 오류가 있었는가와 같은 상태를 보고한다.
- ***제어 레지스터***
    - 호스트가 주변 장치에 입출력 명령을 내리거나 장치의 모드를 변경하기 위해 쓰기를 수행하는 대상

<br/>

<br/>

## 폴링

> 호스트와 입출력 하드웨어 사이의 프로토콜은 복잡하지만, 기본적인 핸드셰이킹 개념은 간단하다.
> 
- ex) 컨트롤러와 호스트 사이에 생산자 소비자 관계를 조정하기 위해 두 개의 비트가 사용된다고 가정.
    - 컨트롤러는 상태 레지스터의 비지 비트를 통해 자신의 상태를 나타낸다.
    - 호스트는 명령 레지스터의 명령 준비 완료 비트를 통해 자신이 입출력을 원한다는 신호를 한다.

<br/>

<br/>

> 호스트가 핸드셰이킹을 통해 컨트롤러와 협력하면서 포트를 통해 출력을 쓰는 과정
> 
1. 호스트가 반복적으로 비지 비트를 검사한다.
2. 호스트가 명령 레지스터에 쓰기 비트를 설정하고 출력 레지스터에 출력할 바이트를  쓴다.
3. 호스트가 명령 준비 완료 비트를 설정한다.
4. 컨트롤러가 명령 준비 완료 비트가 선정된 것을 알아차렸을 때, 자신의 비지 비트를 설정한다.
5. 컨트롤러는 명령 레지스터를 읽고, 쓰기 명령임을 알게 된다.
출력 레지스터를 읽어 해당 바이트를 가져와 해당 하드웨어 장치로 출력한다.
6. 컨트롤러는 명령 준비 비트를 소거하고 입출력이 성공했음을 알리기 위해 상태 레지스터의 오류 비트를 소거한다. 또한, 입출력이 끝났음을 알리기 위해 비지 비트를 소거한다.

<br/>

<br/>

> 위의 단계 1에서 호스트는 **바쁜 대기**, 즉 **폴링**을 하게 된다!
> 
- 호스트는 이 루프를 계속 돌면서 비지 비트가 소거될 때까지 검사를 반복한다.
    - 이 기간이 짧아진다면 별문제가 없지만 기다림이 매우 길어지면, 호스트는 다른 태스크로 전환하여 다른 일을 하다가 오는 것이 좋을 것이다.

<br/>

<br/>

> 대부분의 컴퓨터 구조에서는 한 장치를 폴하기 위해 세 개의 CPU 명령 사이클로 충분하다.
> 
- 즉, 장치 레지스터를 읽고, 상태 비트를 추출하기 위해 논리곱을 하고, 0이 아니면 분기(branch)한다.
    - 분명히 기본 폴링 연산은 효율적이다.
    - 그러나 호스트가 폴링을 반복하고 있지만 장치가 서비스할 준비가 되는 데에 시간이 오래 걸린다면?
        - → 폴링을 비효율적 연산이 되고, 다른 유용한 CPU 처리가 계속 지연된다.

<br/>

<br/>

> 위와 같은 경우에는 하드웨어 컨트롤러가 자신의 상태가 바뀔 때 CPU에 그것을 통보해 주는 것이 반복적으로 폴링을 하는 것보다 더욱더 효율적이다.
> 
- 입출력 장치가 CPU에 자신의 상태 변화를 통보하는 하드웨어 기법을 **인터럽트**라고 한다.

<br/>

<br/>

## 인터럽트

> 기본 인터럽트 기법은 다음과 같다.
> 
- CPU 하드웨어는 **인터럽트 요청 라인**이라고 불리는 선을 하나 갖는데,
CPU는 매 명령어를 끝내고 다음 명령어를 수행하기 전에 늘 이 선을 검사한다.
- 입출력 하드웨어 컨트롤러가 이 요청 라인에 신호를 보내면?
    - → CPU가 알아차리고 각종 레지스터 값과 상태 정보를 저장한 다음,
    - → 메모리상의 **인터럽트 핸들러 루틴**으로 이동한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-2.png" width = 500/>

> 인터럽트 핸들러의 역할
> 
- 인터럽트의 발생 원인을 조사하고, 필요한 작업을 수행한 후 CPU를 인터럽트 전의 실행 상태로 되돌리기 위해 인터럽트 이전의 복귀 명령을 실행한다.

<br/>

<br/>

> 장치 컨트롤러의 역할
> 
- 장치 컨트롤러는 인터럽트 요청 라인에 신호를 보냄으로써 인터럽트를 ***야기***하고, CPU는 인터럽트  상황을 ***알아차리고*** 인터럽트 핸들러를 ***수행***한다.
- 그러면 핸들러는 입출력 장치를 서비스함으로써 이 인터럽트를 처리해 준다.

<br/>

<br/>

> 현대 운영체제에서는 더욱 세분된 인터럽트 핸들링 방법이 필요하다.
> 
1. 어떤 특수한 상황에서는 인터럽트 발생을 연기시키는 능력이 필요하다.
2. 어떤 장치가 인터럽트를 일으켰는지 조사하기 위해 모든 장치를 폴링하지 않고 알아내는 방법이 필요하다.
3. 여러 개의 인터럽트가 병행하게 발생할 때, 운영체제는 높은 우선순위와 낮은 우선순위 인터럽트를 구별하고 긴급한 정도에 따라 먼저 응답하기 위한 다수준 인터럽트가 필요하다.
4. 페이지 폴트 및 0으로 나누기 오류와 같은 활동에 대해 운영체제의 주의를 직접 돌릴 수 있는 방법이 필요하다. → 나중에 트랩으로 수행!

<br/>

<br/>

> 현대 컴퓨터는 이들 요소를 CPU와 **인터럽트 컨트롤러 하드웨어**에 제공하고 있다.
> 
- 대부분의 CPU는 두 종류의 인터럽트 요청 라인을 가진다.
    1. 회복 불가능한 메모리 오류와 같은 이벤트를 위해 사용되는 **마스크 불가 인터럽트**
    2. 필요하면 인터럽트 기능을 잠시 중단 시켜놓을 수 있는 **마스크 가능** 인터럽트

<br/>

<br/>

> 인터럽트 기법은 보통 **주소**라고 하는, 하나의 작은 정수를 받아들인다.
> 
- 이 정수는 특정 인터럽트 핸들링 루틴을 사용하기 위해 사용된다.
    - 대부분의 아키텍처에서 이 주소는 **인터럽트 벡터**라고 불리는 테이블의 오프셋으로 사용된다.
    - 이 벡터는 인터럽트 핸들러들의 메모리 주소들을 가지고 있다.

<br/>

<br/>

> 이러한 벡터형 인터럽트 기법은 단일 인터럽트 핸들러가 서비스할 인터럽트를 결정하기 위해, 모든 가능한 인터럽트의 진원지를 찾아야 할 필요를 줄인다.
> 
- 그러나 컴퓨터는 인터럽트 벡터 내에 있는 주소들보다 더 많은 수의 장치가 있다.
    - 이러한 문제를 해결하기 위해 인터럽트 **사슬화(chaining)** 기술을 사용한다.

<br/>

<br/>

> 또한, 인터럽트 기법은 **인터럽트 우선순위 수준**의 구현을 가능하게 한다.
> 
- 이러한 수준들은 CPU가 모든 낮은 우선순위 인터럽트를 일일이 마스크 오프시키지 않더라도 자동으로 높은 우선순위 인터럽트가 낮은 우선순위 인터럽트의 실행을 선점할 수 있게 한다.

<br/>

<br/>

> 오늘날 운영체제는 여러 방식으로 인터럽트 기법을 사용한다.
> 
- 부팅 시에 운영체제는 하드웨어 버스를 조사하여 어떤 장치들이 존재하는지 알아내고, 인터럽트 벡터에 필요한 장치들의 인터럽트 핸들러들을 등록한다.

<br/>

<br/>

> 운영체제는 인터럽트를 사용해 여러 가지 **예외**도 처리한다.
> 
- 이러한 예외들의 예를 보면, 액세스해서는 안되는 메모리 영역을 애겟스하려 한다든가, CPU가 사용자 모드 상태에서는 허용될 수 없는 특권 명령을 수행하려고 시도했을 때 등이다.

<br/>

<br/>

> 대부분의 경우 인터럽트 처리는 시간과 자원이 제한되어 구현하기가 복잡하다.
> 
- 따라서 시스템은 인터럽트 관리를 **1차 인터럽트 처리기(FLIH)**와 **2차 인터럽트 처리기(SLIH)**로 나눈다.
    - FLIH는 문맥 교환, 상태 저장 및 처리 작업을 큐에 삽입하는 작업을 수행
    - 별도로 스케줄 된 SLIH는 요청된 작업 처리를 수행한다.

<br/>

<br/>

> 운영체제는 인터러트를 시스템 콜(system call)의 수행으로도 이용한다.
> 
- 일반적으로 응용 프로그램은 시스템 콜을 수행하기 위해 라이브러리 루틴을 호출한다.
    - 그 라이브러리 루틴은 호출 인자를 점검하고, 커널로 인자를 넘겨주기 위한 자료구조를 구성하고,
    **소프트웨어 인터럽트** 또는 **트랩**이라고 하는 특수한 명령어를 수행한다.
    - → 이 명령어는 요구되는 커널 서비스를 확인하는 피연산자를 갖는다.

<br/>

<br/>

> 긴 내용들 정리..
> 
- 인터럽트는 모든 현대 시스템에서 비동기적으로 일어나는 이벤트를 처리하고,
커널 내의 수퍼바이저 루틴으로 달려가기 위한 방도로 사용된다.
- 또한 이러한 일 중에서도 가장 급한 일부터 차례로 수행하기 위해서 현대 컴퓨터들은 인터럽트 간에도 다른 우선순위를 부여한다..

<br/>

<br/>

## 직접 메모리 접근

> 디스크와 같은 많은 데이터를 입출력하는 장치를 위해 비싼 범용 프로세서가 매번 바이트 전송을 제어하게 하는 것은 낭비이다.
> 

<br/>

<br/>

- **PIO**(Programmed I/O)
    - CPU가 상태 비트를 반복적으로 검사하면서 1바이트씩 옮기는 입출력 방식

<br/>

<br/>

- 컴퓨터는 CPU의 PIO 작업 중 일부를 **DMA** 컨트롤러라고 불리는 특수 프로세서에 위임한다.
    - DMA 전송을 시작시키기 위해서 호스트는 메모리에 DMA 명령 블록을 쓴다.
    - 이 블록에는 전송할 데이터가 있는 곳의 포인터, 전송할 장소에 대한 포인터,
    그리고 전송될 바이트 수를 기록해 놓는다.
    - 이런 **분산-수집** 방법을 사용 → 하나의 DMA 명령을 통해 여러 개의 전송을 실행할 수 있음!

<br/>

<br/>

> 대상 주소가 커널 주소 공간에 있는 경우가 가장 간단하다.
> 
- DMA로 전송된 데이터를 스레드가 액세스할 수 있게 하려면, 이번에는 커널 메모리에서 사용자 메모리로 두 번째 복사 작업이 필요하다.
    - *이러한 **이중 버퍼링**을 비효율적이다!*

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-3.png" width = 500/>

<br/>

<br/>

> DMA 컨트롤러와 장치 컨트롤러 간의 핸드셰이킹은 `DMA-request`와 `DMA-acknowledge`라고 불리는 두 개의 선을 통해 수행된다.
> 
- 장치 컨트롤러는 전송할 자료가 생기면 DMA-request 선에 신호를 보낸다.
- 이 신호를 받으면 DMA 컨트롤러가 메모리 버스를 얻어 거기에 원하는 주소를 올려놓고,
DMA-acknowledge 선에 신호를 보낸다.
- 장치 컨트롤러가 DMA-acknowledge 신호를 받으면, 컨트롤러는 한 워드를 메모리로 전송하고 DMA-request 신호를 제거한다.

<br/>

<br/>

> 전송이 완전히 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 건다.
> 
- DMA가 메모리 버스를 점유 중이면 비록 CPU는 캐시에 있는 데이터는 접근할 수 있지만, 
일시적으로 주메모리에 있는 데이터는 접근하지 못한다.
    - 이러한 **사이클 스틸링**은 CPU의 속도를 저하하지만 
    *입출력 작업을 DMA로 넘기는 것은 전체적으로 시스템 성능을 향상시킨다!*
    - 어떤 컴퓨터들은 DMA를 할 때는 물리 주소를 사용하지만, 다른 컴퓨터들은 **직접 가상 주소 접근 (DVMA)**를 사용하기도 한다.


<br/>

<br/>

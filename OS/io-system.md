# 입출력 시스템

## 💡 개관 _Overview

> 입출력 장치 관련 기술들은 두 가지의 상충하는 궤도를 따라간다.
> 
- 한편으로는 관련 인터페이스의 표준화가 늘어나고 있다는 것이다.
    - → 이런 경향은 새로 나오는 장치들이 기존 시스템에 쉽게 결합할 수 있도록 하기 위함이다.
- 다른 경향으로는 입출력 장치가 갈수록 다양해진다는 것이다.
    - → 몇몇 장치들은 기존 장치와는 너무 다르다.
    - 이러한 문제는 하드웨어와 소프트웨어 기술들의 조합에 의해 해결될 수 있다.

<br/>

<br/>

> 장치 드라이버의 역할
> 
- 모든 하드웨어를 일관된 인터페이스로 표현해 주며, 이러한 인터페이스를 그보다 상위층인 커널의 입출력 서비스 시스템의 제공한다.

<br/>

<br/>

# 💡 입출력 하드웨어 _ I/O Hardware

> 하드웨어 장치는 케이블을 통하거나 무선으로 신호를 보냄으로써 컴퓨터 시스템과 통신한다.
> 
- 이들 장치는 **포트**라 불리는 연결점을 통해 컴퓨터와 접속한다.
    - 만약 하나 이상의 장치들이 공동으로 여러 선을 사용하면, 이 선을 **버스**라 부른다.

<br/>

<br/>

> 버스의 정의는 회선의 집합으로써 이를 통해 어떻게 메시지를 주고 받는지를 정한 프로토콜까지 포함이다.
> 
- 전자적으로 보면, 메시지는 미리 정해진 시간에 맞추어 전선에 보내지는 전압의 패턴에 의해 전달된다.
    - 만일 장치 A가 B에 연결되고, B가 C, 이어 C가 컴퓨터의 포트에까지 연결되었으면?
        - → **데이지 체인**(daisy chain)이라고 부른다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-1.png" width = 500/>

> 버스는 컴퓨터 구조에서 널리 사용되고 신호 방식, 속도, 처리량 및 연결 방식에 따라 다양한 종류가 있다.
> 
- 위 그림에서는 **PCI 버스**가 프로세서-메모리 서브시스템을 고속 장치와 키보드와 직렬, USB 포트처럼 상대적으로 느린 장치들을 연결하는 **확장 버스**에 연결하는 모습을 나타낸다.
- 그림의 왼쪽 하단은 네 개의 디스크가 SAS 컨트롤러에 접속된 **직렬연결 SCSI** 버스에 연결되어 있다.

<br/>

<br/>

> 컨트롤러는 포트, 버스 또는 장치를 작동할 수 있는 전자장치 집합체이다.
> 
- 직렬 포트 컨트롤러는 간단한 장치 컨트롤러이다.
    - 직렬 포트의 전선에 나타나는 전기신호를 제어하는 데 쓰이고 하나의 칩으로 나온다.
    - 반대로 광섬유 채널(FC) 버스 컨트롤러는 간단하지 않다.
        - FC 프로토콜은 복잡하고, PC가 아닌 데이터 센터에서 사용되기 때문에 종종 컴퓨터의 버스에 연결되는 별도의 회로 보드 또는 **호스트 버스 어댑터(HBA)**로 구현된다.

<br/>

<br/>

## 메모리 맵드 입출력

> 모든 컨트롤러는 레지스터를 가지고 있다.
> 
- 본체의 프로세서는 이들 컨트롤러의 레지스터에 비트 패턴을 쓰거나 읽음으로써 입출력을 수행한다.
    - 이러한 통신을 수행하는 한 방법은 “특별한 입출력 명렁어”를 사용하는 것이다.
    - 이들 입출력 명령어는 한 바이트나 워드를 어떤 입출력 포트 주소로 전달하는 것이다.

<br/>

<br/>

- 다른 방법으로 장치 제어 레지스터를 프로세서의 주소 공간으로 사상하는 것이 있다.
    - 이러한 방식이 **메모리 맵드 입출력 방식**이다.
    - 이 경우 각 주변 장치 레지스터들은 메모리 주소와 일대일 대응이다.
    - CPU는 물리 메모리에 사상된 장치-제어 레지스터를 읽고 쓸 때 표준 데이터 전송 명령을 사용함으로써 입출력 요청을 수행하게 된다.

<br/>

<br/>

> 입출력 장치 컨트롤러는 보통 네 개의 레지스터로 구성되어 있다.
> 
- ***입력 레지스터***
    - 호스트가 입력을 얻기 위해 읽기를 수행한다.
- ***출력 레지스터***
    - 호스트가 데이터를 출력하기 위해 쓰기를 수행한다.
- ***상태 레지스터***
    - 호스트가 읽는 용도이다.
    - 이 비트들은 현재의 명령이 완료되었는지, 입력 레지스터로부터 한 바이트를 읽어도 되는지,
    그리고 오류가 있었는가와 같은 상태를 보고한다.
- ***제어 레지스터***
    - 호스트가 주변 장치에 입출력 명령을 내리거나 장치의 모드를 변경하기 위해 쓰기를 수행하는 대상

<br/>

<br/>

## 폴링

> 호스트와 입출력 하드웨어 사이의 프로토콜은 복잡하지만, 기본적인 핸드셰이킹 개념은 간단하다.
> 
- ex) 컨트롤러와 호스트 사이에 생산자 소비자 관계를 조정하기 위해 두 개의 비트가 사용된다고 가정.
    - 컨트롤러는 상태 레지스터의 비지 비트를 통해 자신의 상태를 나타낸다.
    - 호스트는 명령 레지스터의 명령 준비 완료 비트를 통해 자신이 입출력을 원한다는 신호를 한다.

<br/>

<br/>

> 호스트가 핸드셰이킹을 통해 컨트롤러와 협력하면서 포트를 통해 출력을 쓰는 과정
> 
1. 호스트가 반복적으로 비지 비트를 검사한다.
2. 호스트가 명령 레지스터에 쓰기 비트를 설정하고 출력 레지스터에 출력할 바이트를  쓴다.
3. 호스트가 명령 준비 완료 비트를 설정한다.
4. 컨트롤러가 명령 준비 완료 비트가 선정된 것을 알아차렸을 때, 자신의 비지 비트를 설정한다.
5. 컨트롤러는 명령 레지스터를 읽고, 쓰기 명령임을 알게 된다.
출력 레지스터를 읽어 해당 바이트를 가져와 해당 하드웨어 장치로 출력한다.
6. 컨트롤러는 명령 준비 비트를 소거하고 입출력이 성공했음을 알리기 위해 상태 레지스터의 오류 비트를 소거한다. 또한, 입출력이 끝났음을 알리기 위해 비지 비트를 소거한다.

<br/>

<br/>

> 위의 단계 1에서 호스트는 **바쁜 대기**, 즉 **폴링**을 하게 된다!
> 
- 호스트는 이 루프를 계속 돌면서 비지 비트가 소거될 때까지 검사를 반복한다.
    - 이 기간이 짧아진다면 별문제가 없지만 기다림이 매우 길어지면, 호스트는 다른 태스크로 전환하여 다른 일을 하다가 오는 것이 좋을 것이다.

<br/>

<br/>

> 대부분의 컴퓨터 구조에서는 한 장치를 폴하기 위해 세 개의 CPU 명령 사이클로 충분하다.
> 
- 즉, 장치 레지스터를 읽고, 상태 비트를 추출하기 위해 논리곱을 하고, 0이 아니면 분기(branch)한다.
    - 분명히 기본 폴링 연산은 효율적이다.
    - 그러나 호스트가 폴링을 반복하고 있지만 장치가 서비스할 준비가 되는 데에 시간이 오래 걸린다면?
        - → 폴링을 비효율적 연산이 되고, 다른 유용한 CPU 처리가 계속 지연된다.

<br/>

<br/>

> 위와 같은 경우에는 하드웨어 컨트롤러가 자신의 상태가 바뀔 때 CPU에 그것을 통보해 주는 것이 반복적으로 폴링을 하는 것보다 더욱더 효율적이다.
> 
- 입출력 장치가 CPU에 자신의 상태 변화를 통보하는 하드웨어 기법을 **인터럽트**라고 한다.

<br/>

<br/>

## 인터럽트

> 기본 인터럽트 기법은 다음과 같다.
> 
- CPU 하드웨어는 **인터럽트 요청 라인**이라고 불리는 선을 하나 갖는데,
CPU는 매 명령어를 끝내고 다음 명령어를 수행하기 전에 늘 이 선을 검사한다.
- 입출력 하드웨어 컨트롤러가 이 요청 라인에 신호를 보내면?
    - → CPU가 알아차리고 각종 레지스터 값과 상태 정보를 저장한 다음,
    - → 메모리상의 **인터럽트 핸들러 루틴**으로 이동한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-2.png" width = 500/>

> 인터럽트 핸들러의 역할
> 
- 인터럽트의 발생 원인을 조사하고, 필요한 작업을 수행한 후 CPU를 인터럽트 전의 실행 상태로 되돌리기 위해 인터럽트 이전의 복귀 명령을 실행한다.

<br/>

<br/>

> 장치 컨트롤러의 역할
> 
- 장치 컨트롤러는 인터럽트 요청 라인에 신호를 보냄으로써 인터럽트를 ***야기***하고, CPU는 인터럽트  상황을 ***알아차리고*** 인터럽트 핸들러를 ***수행***한다.
- 그러면 핸들러는 입출력 장치를 서비스함으로써 이 인터럽트를 처리해 준다.

<br/>

<br/>

> 현대 운영체제에서는 더욱 세분된 인터럽트 핸들링 방법이 필요하다.
> 
1. 어떤 특수한 상황에서는 인터럽트 발생을 연기시키는 능력이 필요하다.
2. 어떤 장치가 인터럽트를 일으켰는지 조사하기 위해 모든 장치를 폴링하지 않고 알아내는 방법이 필요하다.
3. 여러 개의 인터럽트가 병행하게 발생할 때, 운영체제는 높은 우선순위와 낮은 우선순위 인터럽트를 구별하고 긴급한 정도에 따라 먼저 응답하기 위한 다수준 인터럽트가 필요하다.
4. 페이지 폴트 및 0으로 나누기 오류와 같은 활동에 대해 운영체제의 주의를 직접 돌릴 수 있는 방법이 필요하다. → 나중에 트랩으로 수행!

<br/>

<br/>

> 현대 컴퓨터는 이들 요소를 CPU와 **인터럽트 컨트롤러 하드웨어**에 제공하고 있다.
> 
- 대부분의 CPU는 두 종류의 인터럽트 요청 라인을 가진다.
    1. 회복 불가능한 메모리 오류와 같은 이벤트를 위해 사용되는 **마스크 불가 인터럽트**
    2. 필요하면 인터럽트 기능을 잠시 중단 시켜놓을 수 있는 **마스크 가능** 인터럽트

<br/>

<br/>

> 인터럽트 기법은 보통 **주소**라고 하는, 하나의 작은 정수를 받아들인다.
> 
- 이 정수는 특정 인터럽트 핸들링 루틴을 사용하기 위해 사용된다.
    - 대부분의 아키텍처에서 이 주소는 **인터럽트 벡터**라고 불리는 테이블의 오프셋으로 사용된다.
    - 이 벡터는 인터럽트 핸들러들의 메모리 주소들을 가지고 있다.

<br/>

<br/>

> 이러한 벡터형 인터럽트 기법은 단일 인터럽트 핸들러가 서비스할 인터럽트를 결정하기 위해, 모든 가능한 인터럽트의 진원지를 찾아야 할 필요를 줄인다.
> 
- 그러나 컴퓨터는 인터럽트 벡터 내에 있는 주소들보다 더 많은 수의 장치가 있다.
    - 이러한 문제를 해결하기 위해 인터럽트 **사슬화(chaining)** 기술을 사용한다.

<br/>

<br/>

> 또한, 인터럽트 기법은 **인터럽트 우선순위 수준**의 구현을 가능하게 한다.
> 
- 이러한 수준들은 CPU가 모든 낮은 우선순위 인터럽트를 일일이 마스크 오프시키지 않더라도 자동으로 높은 우선순위 인터럽트가 낮은 우선순위 인터럽트의 실행을 선점할 수 있게 한다.

<br/>

<br/>

> 오늘날 운영체제는 여러 방식으로 인터럽트 기법을 사용한다.
> 
- 부팅 시에 운영체제는 하드웨어 버스를 조사하여 어떤 장치들이 존재하는지 알아내고, 인터럽트 벡터에 필요한 장치들의 인터럽트 핸들러들을 등록한다.

<br/>

<br/>

> 운영체제는 인터럽트를 사용해 여러 가지 **예외**도 처리한다.
> 
- 이러한 예외들의 예를 보면, 액세스해서는 안되는 메모리 영역을 애겟스하려 한다든가, CPU가 사용자 모드 상태에서는 허용될 수 없는 특권 명령을 수행하려고 시도했을 때 등이다.

<br/>

<br/>

> 대부분의 경우 인터럽트 처리는 시간과 자원이 제한되어 구현하기가 복잡하다.
> 
- 따라서 시스템은 인터럽트 관리를 **1차 인터럽트 처리기(FLIH)**와 **2차 인터럽트 처리기(SLIH)**로 나눈다.
    - FLIH는 문맥 교환, 상태 저장 및 처리 작업을 큐에 삽입하는 작업을 수행
    - 별도로 스케줄 된 SLIH는 요청된 작업 처리를 수행한다.

<br/>

<br/>

> 운영체제는 인터러트를 시스템 콜(system call)의 수행으로도 이용한다.
> 
- 일반적으로 응용 프로그램은 시스템 콜을 수행하기 위해 라이브러리 루틴을 호출한다.
    - 그 라이브러리 루틴은 호출 인자를 점검하고, 커널로 인자를 넘겨주기 위한 자료구조를 구성하고,
    **소프트웨어 인터럽트** 또는 **트랩**이라고 하는 특수한 명령어를 수행한다.
    - → 이 명령어는 요구되는 커널 서비스를 확인하는 피연산자를 갖는다.

<br/>

<br/>

> 긴 내용들 정리..
> 
- 인터럽트는 모든 현대 시스템에서 비동기적으로 일어나는 이벤트를 처리하고,
커널 내의 수퍼바이저 루틴으로 달려가기 위한 방도로 사용된다.
- 또한 이러한 일 중에서도 가장 급한 일부터 차례로 수행하기 위해서 현대 컴퓨터들은 인터럽트 간에도 다른 우선순위를 부여한다..

<br/>

<br/>

## 직접 메모리 접근

> 디스크와 같은 많은 데이터를 입출력하는 장치를 위해 비싼 범용 프로세서가 매번 바이트 전송을 제어하게 하는 것은 낭비이다.
> 

<br/>

<br/>

- **PIO**(Programmed I/O)
    - CPU가 상태 비트를 반복적으로 검사하면서 1바이트씩 옮기는 입출력 방식

<br/>

<br/>

- 컴퓨터는 CPU의 PIO 작업 중 일부를 **DMA** 컨트롤러라고 불리는 특수 프로세서에 위임한다.
    - DMA 전송을 시작시키기 위해서 호스트는 메모리에 DMA 명령 블록을 쓴다.
    - 이 블록에는 전송할 데이터가 있는 곳의 포인터, 전송할 장소에 대한 포인터,
    그리고 전송될 바이트 수를 기록해 놓는다.
    - 이런 **분산-수집** 방법을 사용 → 하나의 DMA 명령을 통해 여러 개의 전송을 실행할 수 있음!

<br/>

<br/>

> 대상 주소가 커널 주소 공간에 있는 경우가 가장 간단하다.
> 
- DMA로 전송된 데이터를 스레드가 액세스할 수 있게 하려면, 이번에는 커널 메모리에서 사용자 메모리로 두 번째 복사 작업이 필요하다.
    - *이러한 **이중 버퍼링**을 비효율적이다!*

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-3.png" width = 500/>

<br/>

<br/>

> DMA 컨트롤러와 장치 컨트롤러 간의 핸드셰이킹은 `DMA-request`와 `DMA-acknowledge`라고 불리는 두 개의 선을 통해 수행된다.
> 
- 장치 컨트롤러는 전송할 자료가 생기면 DMA-request 선에 신호를 보낸다.
- 이 신호를 받으면 DMA 컨트롤러가 메모리 버스를 얻어 거기에 원하는 주소를 올려놓고,
DMA-acknowledge 선에 신호를 보낸다.
- 장치 컨트롤러가 DMA-acknowledge 신호를 받으면, 컨트롤러는 한 워드를 메모리로 전송하고 DMA-request 신호를 제거한다.

<br/>

<br/>

> 전송이 완전히 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 건다.
> 
- DMA가 메모리 버스를 점유 중이면 비록 CPU는 캐시에 있는 데이터는 접근할 수 있지만, 
일시적으로 주메모리에 있는 데이터는 접근하지 못한다.
    - 이러한 **사이클 스틸링**은 CPU의 속도를 저하하지만 
    *입출력 작업을 DMA로 넘기는 것은 전체적으로 시스템 성능을 향상시킨다!*
    - 어떤 컴퓨터들은 DMA를 할 때는 물리 주소를 사용하지만, 다른 컴퓨터들은 **직접 가상 주소 접근 (DVMA)**를 사용하기도 한다.


<br/>

<br/>

# 💡 응용 입출력 인터페이스

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-4.png" width = 500/>

> 다른 소프트웨어 엔지니어링 문제와 같이 여기서도 추상화와 캡슬화, 소프트웨어 계층화를 사용한다.
> 
- 특히, 몇 가지 대표적인 종류의 장치에 대한 정의를 세움으로써 각 입출력 장치들의 구체적인 차이점을 추상화하여 감출 수 있다.
- 각 대표적인 종류의 장치들은 **인터페이스**라고 불리는 표준 함수들의 집합을 통하여 접근된다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-5.png" width = 500/>

> 한 가지 문제는 운영체제마다 장치 드라이버 인터페이스에 대한 규격이 다르다는 것이다.
> 
- 따라서 새로운 장치는 Windows, Linux, AIX 및 macOS에 대한 드라이버와 같은 여러 개의 장치 드라이버와 함께 제공되어야 할 것이다.
- 여러 입출력 장치들
    - 문자 스트림과 블록
    - 순차 접근과 임의 접근
    - 동기식과 비동기식
    - 공유와 전용
    - 동작 속도
    - 읽기/쓰기, 읽기 전용, 한 번만 쓰기

<br/>

<br/>

> 운영체제는 응용 프로그램이 입출력 장치로 임의의 명령을 전달하도록 하는 `escape` 시스템 콜을 갖는다.
> 
- 이는 UNIX에서 `ioctl()` 에 해당된다.
- 이는 새로운 시스템 콜을 만들 필요 없이 응용 프로그램이 임의의 장치 드라이버가 제공하는 임의의 기능을 사용할 수 있게 한다.

<br/>

<br/>

## 블록 장치와 문자 장치

> **블록 장치 인터페이스**
> 

→ 디스크나 이와 유사한 블록 지향 장치를 사용하기 위해 필요한 모든 요소를 제공하고 있다.

- 일반적으로는 읽기와 쓰기, 그리고 다음에 전송할 위치를 지정하는 탐색 명령을 제공한다.

<br/>

<br/>

> 운영체제나 데이터베이스는 블록 장치를 마치 선형 배열이라고 이해하고 사용하길 원한다.
> 
- 이러한 접근 모드를 비가공 **입출력**이라 불린다.
    - 만약 응용이 자체 버퍼링을 수행한다면?
        - → 파일 시스템은 불필요하고 중복된 버퍼링을 하게 된다.
    - 마찬가지로, 만약 응용이 파일의 블록이나 일부에 대한 자체 잠금 기능을 제공한다면?
        - → 운영체제의 잠금 기능은 최소한 중복된 기능이고, 최악의 경우엔 모순이 발생한다!
    - 이러한 충돌을 피하고자 비가공 장치의 접근은 장치의 제어권을 직접 응용에 일임하고 운영체제는 한 발 뒤로 물러나야 한다!

<br/>

<br/>

> 메모리 맵드 파일 접근은 블록 장치 위의 층으로 구현할 수 있다.
> 
- 메모리 맵드 파일 접근이란 실제로 “디바이스를 읽거나 쓰는 명령”을 사용하는 대신, 
“메모리의 특정 번지를 읽거나 쓰는 명령”으로 파일 입출력을 대신하는 방식이다.

<br/>

<br/>

> 키보드는 문자 스트림 인터페이스를 통해 접근되는 장치의 예이다.
> 
- 이러한 인터페이스의 시스템 콜은 응용 프로그램에 한 글자씩을 보내거나 받아오는 명령을 제공한다.

<br/>

<br/>

## 네트워크 장치

> 네트워크 입출력은 디스크 입출력과는 상당히 다르다.
> 
- → 대부분의 운영체제는 디스크에서 사용되는 인터페이스와는 다른 인터페이스를 네트워크 입출력에 제공!
    - UNIX나 Windows NT를 포함한 많은 운영체제에서 사용하는 인터페이스는 ***네트워크 소켓***이다.

<br/>

<br/>

> 소켓 인터페이스의 시스템콜
> 
- 응용 프로그램이 소켓을 생성하고,
- 로컬 소켓은 원격지 주소와 연결해 주고,
- 원격지 응용 프로그램이 이 소켓으로 접속을 완료했는지를 알아보고,
- 연결되었으면 패킷을 주고 받도록 한다.

<br/>

<br/>

## 클록과 타이머

> 대부분의 컴퓨터는 하드웨어 클록과 타이머를 가지고 아래 3가지 기본적인 기능을 제공한다.
> 
- 현재 시각을 제공
- 지난 시각을 제공
- T 시각이 되면 X 오퍼레이션을 실행

<br/>

<br/>

> 지나간 시간을 재고 특정 오퍼레이션을 실행시키는 하드웨어를 프로그램 가능 **인터벌 타이머**라고 한다.
> 
- 이것은 어느 시간만큼 지나면 인터럽트를 발생시키도록 설정할 수 있다.
    - 또한 이 과정을 한 번 또는 주기적으로 인터럽트를 발생하도록 반복해서 설정할 수도 있다.

<br/>

<br/>

> 컴퓨터에는 다양한 용도로 사용되는 클록 하드웨어가 있다.
> 
- 최신 PC에는 고성능 **이벤트 타이머(HPET)**가 포함되어 있다.
    - 트리거는 인터럽트를 발생시키고 OS의 클록 관리 루틴은 타이머의 목적과 수행할 조치를 결정한다.
    - 이처럼 촉발(trigger) 발생 간격은 덜 정밀한 타이머 하드웨어 자체에도 이유가 있지만,
    그보다는 이보다 더 정밀해지려면 가상  클록을 유지하는 데 드는 오버헤드가 매우 크기 때문이다.

<br/>

<br/>

## 봉쇄형과 비봉쇄형

> 시스템 콜 인터페이스와 관련된 나머지 이슈 : 봉쇄형 - 비봉쇄형 방법 간의 선택 문제
> 
- 응용 프로그램이 봉쇄형 시스템 콜을 하면?
    - 운영체제가 호출 스레드를 실행 큐로부터 대기 큐로 옮긴다.
    - 추후 입력이 끝나면 이 스레드는 다시 실행 큐로 되돌아온다.

<br/>

<br/>

- 어떤 사용자 프로그램들은 비봉쇄형 입출력이 필요하다.
    - ex) 스크린에 자료를 표시하거나, 연산 중에 키보드와 마우스의 입력을 받는 경우!

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-6.png" width = 500/>

> 비봉쇄형 시스템 콜의 대안으로 비동기식 시스템 콜이 있다.
> 
- 비동기식 호출도 위 호출처럼 즉각 복귀한다.
    - 이 호출에서 되돌아온 스레드는 자신의 코드를 계속 수행한다.
    - 입출력이 완료되면, 그때 가서 운영체제가 입출력이 완료됐다는 사실을 알려준다.
        - *어떻게 알려주나?*
            - 스레드의 변수를 세팅해 주거나
            - 시그널을 보내거나
            - 소프트웨어 인터럽트를 걸거나
            - 스레드와는 별도로 수행되는 콜백 루틴을 수행함으로써!

<br/>

<br/>

## 벡터형 입출력

> **벡터형 입출력**은 하나의 시스템 콜을 호출해 복수의 위치에 여러 입출력 연산을 수행할 수 있게 한다.
> 
- ex) UNIX readv 시스템 콜은 여러 버퍼로 이루어진 벡터를 인자로 받아 벡터와 목적지 간의 읽기 혹은 쓰기 작업을 수행한다.
    - 동일한 전송은 시스템 콜을 여러 번 호출하여 수행할 수 있지만, 여러 이유로 이러한 **분산-수집** 방식이 유용하다.

<br/>

<br/>

# 💡 커널 입출력 서브 시스템

## I/O 스케줄링

> 운영체제 개발자들은 각각의 장치마다 대기 큐를 유지함으로써 스케줄링을 구현하고 있다.
> 
- 응용 프로그램이 봉쇄형 입출력 시스템 콜을 하면, 그 입출력 요청은 해당 장치의 큐에 넣어진다.
- 입출력 스케줄러는 시스템의 성능과 각 응용에 대한 평균 응답 시간을 향상하기 위해 큐 안의 순서를 재배치한다.
- 운영체제는 통상 공평하게 일을 처리하려고 하지만, 때에 따라서는 시간이 급한 작업을 먼저 하기도 한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-7.png" width = 500/>

> 커널이 비동기적 입출력을 제공한다면, 커널은 동시에 많은 입출력 요청을 추적해야 한다.
> 
- 이를 위해 운영체제는 각 **장치 상태 테이블**에 대기 큐를 연동한다.
    - 위 그림에서 보듯 테이블에는 각 입출력 장치에 대한 정보가 있다.
    - 만약 장치가 요청을 처리하느라 “동작 중” 상태이면, 같은 장치에 대한 요청은 그 장치에 해당하는 테이블 항목에 저장될 것이다.

<br/>

<br/>

## 버퍼링

> **버퍼**란?
> 
- 두 장치 사이 또는 장치와 응용 사이에 데이터가 전송되는 동안 임시로 저장하는 메모리 영역이다.

<br/>

<br/>

> 버퍼링이 필요한 이유 세 가지
> 
1. 데이터의 생산자와 소비자 사이에 속도가 다른 것에 대처한다.
    1. 때에 따라 **이중 버퍼링**을 제공할 수 있다.
2. 데이터 전송 크기가 다른 장치들 사이의 완충을 제공할 때이다.
3. 응용 프로그램의 입출력 **복제 시맨틱**을 지원하기 위함이다.

<br/>

<br/>

## 캐싱

> **캐시**란?
> 
- 자주 사용될 자료의 복사본을 저장하는 빠른 메모리 영역

<br/>

<br/>

> 캐싱과 버퍼링은 서로 다른 기능이지만 때로는 메모리 영역을 두 가지 용도로 모두 사용할 수 있다.
> 
- ex) 복사 시맨틱을 유지하고 디스크 I/O 의 효율적인 스케줄링을 가능하게 하려고 운영체제는 메인 메모리의 버퍼를 사용해 디스크 데이터를 유지한다.
    - 이 버퍼는 캐시로도 사용되어 응용 프로그램들이 공유하거나 기록된 후 곧바로 다시 읽히는 파일의 I/O 효율을 향상한다.

<br/>

<br/>

## 스풀링 및 장치 예약

> **스풀(spool)**이란?
> 
- 인터리브하게 동작할 수 없는 프린터 같은 장치를 위해 출력 데이터를 보관하는 버퍼이다.
    - 즉, 프린터는 한번에는 하나의 작업만을 그것이 다 끝나기까지 처리해야 하고,
    여러 응용의 출력을 섞어 번갈아 가며 출력시킬 수는 없다.

<br/>

<br/>

> 운영체제는 응용 프로그램으로부터 프린터로 가는 모든 출력을 가로챔으로써 이 문제를 해결한다.
> 
- 각 응용 프로그램의 출력은 각각 대응되는 보조저장장치 파일에 저장(스풀)된다.
    - 응용 프로그램이 출력 데이터 만들어내기를 끝내게 되면?
        - → 스풀링 시스템은 그때까지 모아 놓은 출력 데이터를 프린터 출력용 대기 열에 삽입한다.
    - 스풀링 시스템은 큐에서 대기 중인 스풀 파일을 한 번에 하나씩 프린터에 내보낸다.

<br/>

<br/>

## 오류 처리

> 보호되는 메모리를 사용하는 운영체제는 많은 종류의 하드웨어 및 응용 프로그램 오류에 대처할 수 있다.
> 
- 또한 오류가 일어나도 시스템 전체의 마비로까지 확대되지는 않는다.
- 입출력 장치나 네트워크 전송은 일시적인 원인 때문에 또는 영구적인 원인 때문에 고장날 수 있다.

<br/>

<br/>

> 일반적으로 입출력 시스템 콜은 성공-실패를 나타내는 한 비트 정보를 반환한다.
> 
- UNIX → 반환 값 이외에도 `errno`라 부르는 변수를 사용한다.
    - 이 변수는 100가지 종류의 오류를 구분하여 준다.

<br/>

<br/>

> 운영체제에 비하면 몇몇 하드웨어는 보다 훨씬 자세한 오류 정보를 제공해 주고 있다.
> 
- 그러나 이러한 자세한 정보는 운영체제에 의해 응용 프로그램에까지 전달되지는 않는다.
- ex) SCSI 장치에 문제가 생기면 해당 프로토콜에 의해 `sense key` 형태로 보고된다.
    - 이외에도 추가적인 `sense code` 가 있어 명령어 인자의 문제점이라든지 하드웨어 자가 진단 실패 등과 같은 자세한 정보를 알려준다.
    - 그리고 추가로 `sense-code qualifier` 라는 더욱 자세한 정보를 제공해주기도 한다.

<br/>

<br/>

## 입출력 보호

> 오류는 보호 문제와 밀접한 관계가 있다.
> 
- 사용자 프로세스는 고의적이든 아니든 불법적인 입출력 명령을 시도함으로써 정상적인 동작을 방해할 수 있다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-8.png" width = 500/>

> 사용자가 불법적인 입출력을 못하게 하기 위해, 모든 입출력 명령은 특권 명령으로 정의한다.
> 
- 따라서 사용자는 입출력 명령을 직접 수행할 수 없다.
    - 대신에 운영체제가 입출력을 대신 수행하도록 시스템 콜을 수행한다.

<br/>

<br/>

## 커널 자료구조

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/12-9.png" width = 500/>

> 커널은 입출력 구성요소에 대한 상태 정보를 유지해야 한다.
> 
- 커널은 네트워크 연결, 문자 장치 통신 그리고 다른 입출력 활동을 관리하기 위해 여러 비슷한 구조를 사용한다.
    - UNIX는 파일 시스템 인터페이스를 사용해 다양한 것에 access 할 수 있게 해준다.

<br/>

<br/>

> 일부 운영체제들은 객체지향 기법을 한 단계 더 확대하여 적용하기도 한다.
> 
- ex) Windows NT → 입출력 서비스를 커널이 직접 해주지 않고 커널 밖의 입출력 manager라는 프로그램에 넘겨준다!
    - → 커널에 입출력 요청이 오면 그것은 메시지로 바뀌어 커널을 통해 이 입출력 manager에게 전달된다.

<br/>

<br/>

## 전원 관리

> 운영체제는 전력 사용에서 중요한 역할을 한다.
> 
- 클라우드 컴퓨팅 환경에서 모니터링과 시스템에서 모든 사용자 프로세스를 대피하고, 해당 시스템을 유휴상태로 만들고 부하가 필요할 때까지 전원을 끌 수 있는 관리 도구를 사용하면 처리 부하를 조정할 수 있다.

<br/>

<br/>

> 시스템 부하가 필요로 하지 않는 경우
> 
- CPU 코어는 일시 중단될 수 있고, 부하가 증가하고 스레드 큐를 실행하기 위해 더 많은 코어가 필요할 때까지 재개될 수 있다.
    - *물론 코어의 상태는 일시 중단시 저장되고 재개 시 복원되어야 한다!*
    - 이 기능은 서버로 가득 찬 데이터 센터는 대량의 전기를 사용하고, 불필요한 코어를 비활성화하면 전기의 필요를 줄일 수 있기 때문에 서버에 필요하다.


<br/>

<br/>

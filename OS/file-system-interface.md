# 파일 시스템 인터페이스

## 🔥 파일 개념 

컴퓨터는 정보를 NVM 장치, HDD, 자기 디스크 같은 각기 다른 저장 매체에 저장할 수 있다.

운영체제는 컴퓨터 시스템을 편리하게 사용하기 위해 저장된 정보에 대한 일관된 논리적 관점을 제공하고,
저장장치의 물리적 특성을 추상화하여 논리적 저장 단위, 즉 **파일**을 정의한다.

<br/>

<br/>

> 파일이란?
> 

보조 저장장치에 기록된 관련 정보의 집합으로 정의할 수 있다.

- 사용자의 관점에서 볼 때 파일은 논리적 보조저장장치의 가장 작은 할당 요소이다.
    - → 즉, 자료가 파일 안에 존재해야만 보조저장장치에 기록될 수 있다!
- 일반적으로 파일은 프로그램과 자료를 나타낸다.

<br/>

<br/>

> 파일 내의 정보는 작성자에 의해 정의된다.
> 

프로그램, 숫자, 사진 등 다양한 정보들이 파일 내에 저장되고, 유형에 따라 특별히 정의된 구조를 가진다.

- **텍스트 파일** : 행들로 구성된 연속된 문자들
- **소스 파일** : 함수들의 연속으로, 각 함수는 선언과 실행문의 순서로 구성된다.
- **실행 파일** : 로더가 메모리로 가져와 실행시킬 수 있는 연속된 코드 부분들

<br/>

<br/>

### 파일 속성

사용자의 편의를 위해 파일에 이름을 부여하고, 그 이름으로 파일을 참조한다.

- 일단 파일이 만들어지면 그 파일을 생성한 프로세스, 사용자, 심지어 시스템으로부터도 독립하게 된다.
- 파일은 운영체제마다 다른 속성을 갖지만 전형적으로 다음과 같은 속성들을 가진다.
    - 이름
    - 식별자
    - 유형
    - 위치
    - 크기
    - 보호
    - 타임스탬프와 사용자 식별

<br/>

<br/>

> 모든 파일에 대한 정보는 파일 자신과 같은 장치에 상주하는 디렉토리 구조에 의해서 유지된다.
> 
- 전형적으로, 디렉토리 항목은 파일의 이름과 고유의 식별자로 구성된다.
    - 식별자는 다른 파일 속성을 찾는 데 사용된다.
    - 디렉토리는 파일의 휘발성과 일치해야 하므로 파일과 같이 장치에 저장되어야 하고, 
    필요할 때마다 메모리로 조금씩 반입된다.

<br/>

<br/>

### 파일 연산

파일이란 추상적인 데이터 유형이다. → 따라서 적절히 정의하려면 파일 실행 연산들을 고려해보자.

<br/>

<br/>

> 파일 생성
> 

파일을 생성하기 위해선 2단계가 필요하다.

1. 파일을 저장할 수 있도록 파일 시스템 내에서 공간을 찾아야 한다.
2. 새로 생성된 파일에 대한 항목이 디렉터리에 만들어져야 한다.

<br/>

<br/>

> 파일 열기
> 

모든 파일 연산에서 파일 이름을 지정하면? → OS는 이름을 검사하고, 접근 권한을 매 실행시마다 해야한다.

- 따라서 새엉과 삭제를 제외한 모든 연산을 하기 전에 반드시 파일을 `open()` 해야 한다.

<br/>

<br/>

> 파일 쓰기
> 

파일을 쓰기 위해서는 열린 파일 핸들과 파일에 기록될 정보를 명시하는 시스템 콜을 실행한다.

- 시스템은 다음 순차적 쓰기가 일어날 위치를 가리키는 **쓰기 포인터**를 유지해야 한다.

<br/>

<br/>

> 파일 읽기
> 

파일을 읽기 위해서는 파일 핸들과 파일이 읽혀야 할 블록의 위치를 기술하는 시스템 콜을 사용한다.

- 시스템은 다음 순차적 읽기가 일어날 위치를 가리키는 **읽기 포인터**를 유지해야 한다.

<br/>

<br/>

> 파일 안에서의 위치 재설정
> 

열린 파일의 현재 파일 위치를 주어진 값으로 설정한다. (= **탐색**으로도 알려져 있다.)

<br/>

<br/>

> 파일 삭제
> 

파일을 삭제하기 위해 지정된 파일을 디렉터리에서 찾는다.

*위 기본 연산은 파일 조작에 필요한 최소 연산이다. → 필요에 따라 연산들이 결합되기도 한다!*

ex) 복사본 만들기 : 파일 생성 + 파일 읽기 + 파일 기록

<br/>

<br/>

> 운영체제는 모든 파열린 파일에 대한 정보를 갖는 **열린 파일 테이블**을 유지한다.
> 

임의의 파일 연산이 요구되면, 이 테이블에 대한 인덱스로 그 파일을 지정한다. → 따라서 탐색이 필요x

<br/>

<br/>

> 여러 프로세스가 동시에 파일을 열 수 있는 환경에서 `open()` 과 `close()` 연산들의 구현은 더 복잡하다
> 

보통 운영체제는 두 단계 내부 테이블, 즉 프로세스 별 테이블과 범 시스템 테이블을 사용한다.

- **프로세스 별 테이블** : 각 프로세스가 연 모든 파일을 기록
    - 이 테이블에 저장된 내용은 프로세스가 파일을 어떻게 사용하는가에 관한 정보이다.
- **범 시스템 테이블** : 프로세스의 독립적인 정보(즉, 디스크상의 파일 위치, 접근 날짜 등)들을 갖는다.

<br/>

<br/>

> 열린 파일과 관련된 정보들 요약
> 
- *파일 포인터*
    - 읽기와 쓰기 시스템 콜의 일부분
    - 파일 오프셋을 포함하지 않는 시스템은 현재 파일 위치 포인터로서 가장 최근의 읽기/쓰기 위치를 추적해야 한다.
- *파일 열린 계수*
    - 파일이 닫히면, 운영체제는 열린 파일 테이블 항목들을 재사용해야 한다.
- *접근 권한*
    - 각 프로세스는 한 파일을 하나의 접근 모드로 연다.
    - 이 정보는 프로세스 별 테이블에 저장되며 운영체제는 이 정보를 후속 요구를 허용하거나 불허하는 데 사용한다.

<br/>

<br/>

#### 파일 락

파일 락은 7장에서 다룬 읽기-쓰기 락과 유사한 기능을 제공한다.

- 공유 락
    - 여러 프로세스가 동시에 락을 획득할 수 있다. (= 읽기 락과 비슷)
- 베타적인 락
    - 한 번에 한 프로세스만 락을 획득할 수 있다. (= 쓰기 락과 비슷)

<br/>

*→ 모든 운영체제가 두 종류의 락을 모두 지원하지는 않는다는 것을 기억하자.*

<br/>

<br/>

운영체제는 **강제적** 또는 **권고적** 파일 락 방법을 제공할 수 있다.

- 강제적 락
    - 어떠한 프로세스가 배타적 락을 획득하면, 운영체제는 다른 프로세스가 잠겨진 파일에 접근하는 것을 막는다.
- 권고적 락
    - 락이 적절히 획득되고 해제되는 것에 대한 보장은 소프트웨어 개발자의 몫이다.

<br/>

<br/>

### 파일 유형

운영체제 설계 시 중요 사항 중 하나 : 운영체제가 파일 유형들을 인식하고 지원할 지를 결정하는 것

- 만일 OS가 파일 유형을 지원한다면?
    - → 파일에 대해 합리적인 연산을 수행할 수 있다.
- 흔히 잘 알려진 방법 : 파일 이름의 한 부분이 파일 유형을 나타내도록 하는 것.
    - ex) 마침표 뒤에 확장자를 적는다.

<br/>

<br/>

> UNIX 시스템은 매직 넘버를 사용해 파일의 데이터 유형을 나타낸다.
> 

하지만 모든 파일이 매직 넘버를 갖고 있지는 않다. → 시스템의 모든 기능이 매직 넘버에만 기반을 둘 순 없다.

- 따라서 UNIX는 파일 이름 확장자 힌트를 허용하지만, 이러한 확장자는 운영체제에 의해 강제되거나 운영체제가 이에 의존하지도 않는다.
- 주로 사용자가 파일에 포함된 콘텐츠 유형을 결정하는 데 도움을 주려는 것이다.

<br/>

<br/>

### 파일 구조

파일의 유형을 사용하여 파일의 내부 구조 형태를 짐작할 수 있다.

→ 각각의 파일들은 그 파일을 다루는 프로그램에 의해 인식 가능한 내부 구조를 일정한 형태로 가지게 된다.

<br/>

<br/>

> 운영체제가 여러 파일 구조를 지원하는 경우에 발생 가능한 단점 : OS의 크기가 커지고, 관리가 힘들다.
> 
- 어떤 운영체제들은 파일 형태, 구조에 대해 제한을 거의 두지 않는다.
    - 덕분에 시스템은 어떠한 목적으로도 자유롭게 파일을 사용할 수 있게 되며, 유연성은 극대화된다.
    - 그 대신 시스템 차원에서의 파일 유형 지원은 상대적으로 적다.
    - → 이에 따라 각 응용 프로그램들이 각자의 프로그램에서 사용하는 파일 운용을 책임져야 한다.

<br/>

<br/>

# 🔥 접근 방법

## 순차 접근

파일에 있는 정보는 저장되어 있는 레코드 순서대로 접근하는 방식으로, 가장 일반적이다.

<br/>

<br/>
s
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/13-1.png" width = 500/>

> 파일에 대한 대부분의 연산은 읽기와 쓰기이다.
> 
- 읽기 : 파일의 다음 부분을 읽은 후 자동으로 파일 포인터 증가
- 쓰기 : 파일의 끝에 첨가하고 새롭게 기록된 내용의 끝으로 포인터이동

<br/>

<br/>

## 직접 접근

파일을 특정한 순서없이 빠르게 레코드를 판독/기록하기 위해 고정길이 논리적 레코드로 구성한다.

<br/>

> 모든 운영체제가 직접 접근 파일과 순차 접근 파일을 둘 다 제공하지는 않는다.
> 
- 직접 접근 파일에서 순차 접근을 모의하는 것은 쉽지만, 반대는 비능률적이다!
- 직접 접근 파일에서 순차 접근 시뮬레이션 (아래 그림)

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/13-2.png" width = 500/>

<br/>

<br/>

## 기타 접근 방법

직접 접근을 기반으로 여러 가지 다른 파일 접근 방법을 제공할 수 있다.

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/13-3.png" width = 500/>

> 색인 파일
> 
- 색인은 여러 블록에 대한 포인터를 포함한다.
- 어떤 항목을 찾기 위해서 먼저 색인을 탐색 후, 포인터를 사용하여 파일을 직접 접근하여 항목을 찾아낸다.


<br/>

<br/>

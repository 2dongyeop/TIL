# 운영체제 구조

>💡 이 장의 목표
>
>- 운영체제에서 제공하는 서비스를 식별한다.
>- 운영체제 서비스를 제공하기 위해 시스템 콜을 사용하는 방법을 설명한다.
>- 운영체제 설계를 위한 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략을 비교 및 대조한다.
>- 운영체제 부팅 프로세스를 설명한다.
>- 운영체제 성능을 모니터링하기 위한 도구를 적용한다.
>- Linux 커널과 상호 작용하기 위한 커널 모듈을 설계하고 구현한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/view.png" width = 700/>

<br/>

<br/>

- 운영체제를 살펴보기 위한 유리한 관점 몇 가지가 있다.
    1. 운영체제가 제공하는 서비스에 초점을 맞추자.
    2. 운영체제가 사용자와 프로그래머에게 제공하는 인터페이스에 초점을 맞추자.
    3. 시스템의 구성요소와 그들의 상호 연결에 초점을 맞추자.

<br/>

<br/>

## 💡 운영체제 서비스

> 💡 운영체제는 프로그램 실행 환경을 제공한다. 또한 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다. 다양한 운영체제 서비스에 대한 한 가지 관점과 그들의 상호관계를 살펴보자.

<br/>

<br/>

- ***사용자 인터페이스***
    - 거의 모든 운영체제는 사용자 인터페이스(UI)를 제공한다.
    - 가장 일반적으로 그래픽 사용자 인터페이스(GUI)가 사용된다.
    - 휴대전화 및 모바일 시스템은 터치스크린 인터페이스를 제공한다.
    - 명령어 라인 인터페이스(CLI)도 제공한다.

<br/>

<br/>

- ***프로그램 수행***
    - 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다.
    - 프로그램은 정상적이든, 비정상적이든 실행을 끝낼 수 있어야 한다.

<br/>

<br/>

- ***입출력 연산***
    - 수행 중인 프로그램은 입출력을 요구할 수 있어야 한다.

<br/>

<br/>

- ***파일 시스템 조작***
    - 파일 시스템은 특히 중요한 분야이다. 프로그램은 파일을 읽고 쓸 필요가 있다.
    - 프로그램은 이름에 의해 파일을 생성, 삭제할 수 있고 지정된 파일을 찾을 수 있어야 한다.
    - 파일 소유권에 기반을 둔 권한 관리를 이용해 접근을 허부하거나 거부할 수 있어야 한다.

<br/>

<br/>

- ***통신***
    - 한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있는 여러 상황이 있다.
    - 통신을 수행하는 두 가지 중요한 방법
        - 동일한 컴퓨터에서 수행되고 있는 프로세스 사이에서 일어나기
        - 네트워크에 의해 함께 묶여 있는 서로 다른 컴퓨터 시스템상에서 수행되는 프로세스 사이에서 발생
    - 통신은 **공유 메모리**를 통해 구현될 수 있고, **메시지 전달 기법**을 사용해 구현될 수 있다.

<br/>

<br/>

- ***오류 탐지***
    - 운영체제는 모든 가능한 오류를 항상 의식하고 있어야 한다.
    - 운영체제는 올바르고 일관성 있는 계산을 보장하기 위해 각 유형의 오류에 대해 적당한 조치를 해야 한다.

<br/>

<br/>

> 사용자에 도움을 주는 것이 목적이 아니라, 시스템 자체의 효율적인 동작을 보장하기 위한 기능도 있다.
> 

<br/>

<br/>

- ***자원 할당***
    - 다수의 프로세스나 다수의 작업이 동시에 실행될 때, 그들 각각에 자원을 할당해 주어야 한다.
    - CPU를 최대한 효율적으로 이용하기 위해 운영체제는 CPU 스케줄링 루틴이 CPU의 속도, 반드시 실행해야 할 프로세스들, CPU의 처리 코어의 개수와 다른 요인들을 고려해야 한다.

<br/>

<br/>

- ***기록 작성(logging)***
    - 우리는 어떤 프로그램이 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지를 추적할 수 있길 원한다.
    - 이와 같은 기록 관리는 회계, 또는 단순히 사용 통계를 내기 위해 사용된다.

<br/>

<br/>

- ***보호와 보안***
    - 다중 사용자 컴퓨터 시스템과 네트워크로 연결된 컴퓨터 시스템에 저장된 정보의 소유자는 그 정보의 사용을 통제하길 원한다.
    - 한 프로세스가 다른 프로세스나 운영체제 자체를 방해해서는 안된다.
    - 보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 한다.
    - 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록하는 것으로 범위를 넓힌다.


<br/>

<br/>

## 💡 사용자와 운영체제 인터페이스

> 💡 사용자가 운영체제와 접촉하는 방식 중 명령어 라인 인터페이스(CLI) 또는 명령 인터프리터를 제공하는 방식에 대해 알아보자.


<br/>

<br/>

### 명령 인터프리터

- 운영체제 대부분은 명령 인터프리터를 프로세스가 시작되거나 사용자가 처음 로그온할 때 수행되는 특수한 프로그램으로 취급한다.
    - 선택할 수 있는 여러 명령 인터프리터를 제공하는 시스템에서 해석기는 **셸(shell)**이라고 불린다.
    - 대부분의 셸은 유사한 기능을 제공한다.

<br/>

<br/>

- 명령 인터프리터의 중요한 기능은 사용자가 지정한 명령을 가져와 수행하는 것이다.
    - 이 수준에서 제공된 많은 명령은 파일을 조작한다.

<br/>

<br/>

- 명령어들은 두 가지 일반적인 방식으로 구현될 수 있다.
    1. 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우
        1. 이 경우 제공될 수 있는 명령의 수가 명령 인터프리터의 크기를 결정하는데, 각 명령이 자신의 구현 코드를 요구하기 때문이다.
    2. 시스템 프로그램에 의해 대부분의 명령을 구현하는 경우
        1. 이 경우 인터프리터는 명령을 전혀 알지 못한다.
        2. 단지 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용한다.
        3. 이때 명령 인터프리터 프로그램은 아주 작아질 수 있고, 새로운 명령을 위해 변경될 필요가 없다.

<br/>

<br/>

### 그래픽 기반 사용자 인터페이스

> 💡 운영체제와 접촉하는 두 번째 방식이다.

<br/>

<br/>

- 데스크톱이라고 특징지어지는 마우스를 기반으로 하는 윈도 메뉴 시스템을 사용한다.
    - 마우스를 움직여 화면상의 아이콘에 위치시킨다.

<br/>

<br/>

### 터치스크린 인터페이스

>💡 모바일 시스템에서는 CLI나 GUI가 실용적이지 않아 터치스크린 인터페이스를 사용한다.

<br/>

<br/>

- 터치스크린에서 손가락으로 누르거나 스와이프하는 등의 **제스처**를 취하여 상호작용한다.

<br/>

<br/>

### 인터페이스의 선택

> 💡 명령어 라인 또는 그래픽 기반 인터페이스를 사용할 것인지는 개인의 선호에 달려있다.

<br/>

<br/>

- 컴퓨터를 관리하는 **시스템 관리자**와 시스템에 대해 깊게 아는 **파워 유저**
    - 하고자 하는 작업에 빨리 접근하기 위해 명령어 라인 인터페이스가 효율적이다.
    - 게다가 명령어 라인 인터페이스는 보통 반복적으로 해야 하는 작업을 쉽게 작업할 수 있는데, 이는 프로그래밍이 가능하다는 사실이 한 몫을 차지한다.

<br/>

<br/>

## 💡 시스템 콜

> 💡 시스템 콜은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.

<br/>

<br/>

### 예제

- 한 파일로부터 데이터를 읽어서 다른 파일로 복사하는 명령어

```bash
cp in.text out.txt
```

<br/>

<br/>

- 두 번째 방법은 프로그램이 사용자에게 이름을 요청하는 것이다.
    - 대화형 시스템에서 이 방법은 일련의 시스템 콜이 필요하다.


<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/system-call-example.png" width = 700/>

- 일단 두 개의 파일 이름이 얻어지면, 프로그램은 반드시 입력 파일을 오픈하고 출력 파일을 생성한 후 오픈한다.
    - 각각의 이러한 연산은 또 다른 시스템 콜을 필요로 하며, 각 시스템 콜에서 오류가 발생하면 처리가 필요하다.

<br/>

<br/>

- 동일한 이름을 가진 출력 파일이 이미 존재하면?
    - 프로그램을 중단(abort)하게 하거나, 기존 파일을 삭제한 후 생성할 수도 있다.
    - 대화형 시스템에서 또 다른 방법은 기존의 파일을 대체할 것인지, 프로그램을 중단할 지 물어보는 것이다.

<br/>

<br/>

### 응용 프로그래밍 인터페이스

- 대부분의 응용 개발자들은 응용 프로그래밍 인터페이스(**API**)에 따라 프로그램을 설계한다.
    - API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함한다.

<br/>

<br/>

- 프로그래머는 운영체제가 제공하는 코드의 라이브러리를 통하여 API를 활용한다.
    - UNIX와 Linux → `libc` 라이브러리를 이용

<br/>

<br/>

- 통상 API 함수들은 응용 프로그래머를 대신해 실제 시스템 콜을 호출한다.
    - 왜 프로그래머는 실제 시스템 콜을 부르는 것보다 API에 따라 프로그래밍하는 것을 선호하는가?
    - 프로그램과 호환성이 좋다!
        - 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일되고 실행되는 것을 기대한다.
        - 시스템 콜은 종종 좀 더 자세한 명세가 필요할 때가 있어 어렵다.

<br/>

<br/>

- 시스템 콜을 처리하는데 있어 또 다른 중요한 요소는 실행시간 환경(RTE)이다.
    - 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는 데 필요한 전체 소프트웨어를 가리킨다.
    - RTE는 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 **시스템 콜 인터페이스**를 제공한다

<br/>

<br/>


<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/handling.png" width = 700/>

<br/>

<br/>

- 이 시스템 콜 인터페이스는 API 함수의 호출을 가로채어 필요한 운영체제 시스템 콜을 부른다.
    - 통산 각 시스템 콜에는 번호가 할당되고, 인터페이스는 이 번호에 따라 색인되는 테이블을 유지한다.

<br/>

<br/>

- 호출자는 시스템 콜이 어떻게 구현되고 실행 중 무슨 작업을 하는지 아무것도 알 필요가 없다.
    - 단지 API를 준수하고 시스템 콜의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다.
    - 따라서 운영체제 인터페이스에 대한 자세한 내용은 API에 의해 프로그래머로부터 숨겨지고 RTE에 의해 관리된다.

<br/>

<br/>

- 시스템 콜은 사용되는 컴퓨터에 따라 다른 방법으로 발생한다.
    - 종종, 단순히 원하는 시스템 콜이 무엇인지보다 더 많은 정보가 요구될 수도 있다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/passing.png" width = 700/>

<br/>

<br/>

- 운영체제에 매개변수를 전달하기 위해서 세 가지 일반적인 방법을 제공한다.
    1. **레지스터** 내에 전달하기
        1. 데이터가 레지스터보다 사이즈가 클 경우 이용할 수 없다.
    2. 매개변수를 메모리 내의 **블록**이나 테이블에 저장하고, 블록의 주소를 전달하기
    3. **스택**에 넣고, 운영체제에 의해 **꺼내지기**

<br/>

<br/>

### 시스템 콜의 유형

>💡 시스템 콜은 다섯 가지 중요한 범주로 묶을 수 있다.
>- 프로세스 제어
>- 파일 조작
>- 장치 조작
>- 정보 유지 보수, 통신, 보호


<br/>

<br/>

**프로세스 제어**

- 실행중인 프로그램은 수행을 정상적으로 종료(`end()`) 또는 비정상적으로 종료(`abort()`) 할 수 있어야 한다.
    - 비정상으로 중지하기 위해 시스템 콜을 호출하거나 오류 트랩을 유발할 경우 → 오류 메시지 생성
    - 이때 행해지는 덤프는 특별한 로그 파일이나 디스크에 기록되고, 문제의 원인을 결정하기 위해 **디버거**에 의해 검사될 수 있다!

<br/>

<br/>

- 대화식 시스템에서 명령 인터프리터는 단순히 다음 명령을 계속 수행하며, 사용자가 오류에 응답하는 적절한 명령을 내릴 것을 가정한다.
    - 일부 시스템에서는 오류가 발생할 경우 특별한 복구 행위를 지시하는 제어 카드를 허용한다.

<br/>

<br/>

- 한 프로그램을 실행하고 있는 프로세스가 다른 프로그램을 적재(`load()`)하고 실행(`execute()`) 하기를 원할 수 있다.
    - 이 기능은 명령 인터프리터가 사용자 명령 또는 마우스의 클릭을 통해 지시된 프로그램 실행을 허용한다.

<br/>

<br/>

> 여기서 재밌는건, 적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려 주느냐이다!
>- 기존 프로그램이 유실될지, 보관될지
>- 새로운 프로그램과 병행 실행을 허용할 지 등등
> 

<br/>

<br/>

- 만약 새로운 프로그램이 종료되었을 때 제어가 기존 프로그램으로 되돌아간다면?
    - 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다.
    - 따라서 우리는 실질적으로 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이 된다.
    - 만약 두 프로그램이 병행수행한다면 → 다중 프로그래밍 될 새 프로세스를 생성한 것!

<br/>

<br/>

- 만약, 새로운 잡이나 프로세스, 혹은 프로세스의 집합들을 생성한다면 그들을 제어해야 한다.
    - 이러한 제어는 우선순위, 최대 허용 실행 시간 등을 포함하여 프로세스 속성들을 결정해야 한다.

<br/>

<br/>

- 새로운 프로세스를 생성한 후에는, 우리는 이들의 실행이 끝나기를 기다려야 할 필요가 있다.
    - 일정 시간만큼만 기다리기를 원할 수 있다. → 이벤트를 기다린다.

<br/>

<br/>

- 빈번하게 둘 이상의 프로세스들은 데이터를 공유한다.
    - 공유되는 데이터의 일관성을 보장하기 위해, 운영체제는 종종 프로세스가 **공유 데이터를 잠글** 수 있는 시스템 콜을 제공한다.

<br/>

<br/>

- 프로세스 제어는 너무 많은 측면과 다양성이 있으므로 단일 태스킹과 다중 태스킹으로 예를 들어보자.
    - Arduino는 마이크로 컨트롤러와 여러 센서로 구성된 간단한 하드웨어 플랫폼이다.
    - Arduino 응용 프로그램을 작성하려면?
        - PC에서 프로그램을 작성 → USB 연결 → 컴파일된 프로그램(스케치)를 메모리에 업로드
    
<br/>

<br/>


<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/arduino.png" width = 700/>

<br/>

<br/>

- 표준 Arduino 플랫폼은 운영체제를 제공하지 않는다.
    - 대신 **부트 로더**라고 불리는 작은 소프트웨어가 스케치를 메모리의 특정 영역으로 적재한다.
    - 스캐치가 적재되면 실행되기 시작하고, 반응하도록 프로그램된 이벤트를 기다린다.

<br/>

<br/>

- 한 순간에 하나의 스케치만 메모리에 존재할 수 있으므로 단일 태스킹 시스템으로 간주된다.
    - 다른 스케치가 적재되면 기존 스케치를 대체한다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/FreeBSD.png" width = 700/>

<br/>

<br/>

- FreeBSD는 다중 태스킹 시스템의 예이다.
    - 사용자가 시스템에 로그인할 때 사용자가 선택한 셸이 수행되어 명령을 기다렸다가 사용자가 요청한 프로그램을 수행한다.
    - 그렇지만 다중 태스킹 시스템이기 때문에 명령 인터프리터는 다른 프로그램이  실행되는 동안 수행을 계속 할 수 있다.

<br/>

<br/>

- 새로운 프로세스를 시작하기 위해 셸은 `fork()` 시스템 콜을 실행한다.
    - 이후 선택된 프로그램이 `exec()` 시스템 콜을 통해 메모리에 적재되고, 이후에 수행된다.

<br/>

<br/>

- 명령이 내려진 방법에 다라 프로세스가 종료하기를 기다리거나, 백그라운드에서 실행된다.
    - 후자의 경우, 셸은 바로 다른 명령이 입력되기를 기다린다.

<br/>

<br/>

**파일 관리**

- 파일은 생성(`create()` )하고, 삭제(`delete()`) 할 수 있어야 한다.
    - 생성을 했으면 열(`open()`) 고 닫을(close) 수 있어야 한다.
    - 또한 읽고(read), 쓰고(read), 위치 변경(reposition)할 수 있어야 한다.
    
<br/>

<br/>


- 파일 시스템이 디렉토리 구조를 가진다면, 디렉토리에 대해 속성을 결정할 수 있어야 한다.
    - 파일의 속성을 획득할 줄 알아야 하고, 설정할 수 있어야 한다.
    - 파일을 이동하고 복사할 수 있어야 한다.

<br/>

<br/>

**장치 관리**

- 프로세스는 작업을 계속 수행하기 위해 추가 자원이 필요할 수 있다.
    - 이러한 추가 자원은 주 기억장치, 디스크 드라이브, 파일에 접근 등이 될 수 있다.

<br/>

<br/>

- 운영체제에 의해 제어되는 다양한 자원들을 장치로 간주될 수 있다.
    - 이 장치들의 일부는 물리 장치이고, 다른 장치들은 추상적 혹은 가상적 장치일 수 있다.
    - 장치의 사용이 끝나면 반드시 방출(release)해야 한다.

<br/>

<br/>

**정보 유지 관리**

- 많은 시스템 콜은 단순히 사용자 프로그램과 운영체제 간의 정보 전달을 위해 존재한다.
    - 다른 시스템 콜 집합은 프로그램 디버깅에 도움이 된다.
    - 많은 시스템이 메모리를 덤프(dump)하기 위해 시스템 콜을 제공한다.

<br/>

<br/>

- 많은 운영체제는 프로그램의 시간 프로파일을 제공한다.
    - 시간 프로파일은 그 프로그램이 특정 위치에서 수행한 시간의 양을 나타낸다.
    - 시간 프로파일은 추적 설비나 정규 타이머 인터럽트가 필요하다.

<br/>

<br/>

**통신**

- 통신 모델에는 메시지 전달과 공유 메모리의 두 가지 일반적인 모델이 있다.

<br/>

<br/>

- **메시지 전달** 모델
    - 통신하는 두 프로세스가 정보를 교환하기 위해 서로 메시지를 주고 받는다.
    - 메시지는 두 프로세스 사이에서 직접 교환되거나 우편함을 통하여 간접적으로 교환된다.
    - 상대 통신자가 누구든 간에 그 이름을 반드시 알고 있어야 한다.
    - 연결을 받아들일 프로세스들의 대부분은 특수 목적의 디먼(daemon)으로, 그 목적으로만 제공된 프로그램들이다.
    - **클라이언트**로 알려진 통신의 출발지와 **서버**로 알려진 수신 디먼은 명령어를 통해 메시지를 교환한다.

<br/>

<br/>

- **공유 메모리** 모델
    - 프로세스는 다른 프로세스가 소유한 메모리 영역에 접근할 수 있다.
    - 정상적으로 운영체제는 다른 프로세스의 메모리에 접근하는 것을 막는다고 배웠다!
        - **공유 메모리는 두 개 이상의 프로세스가 이러한 제한을 제거하는 데 동의할 것을 필요로 한다.**
    - 데이터 형식은 운영체제의 제어 하에 있는 것이 아니라, 이들 프로세스에 의해 결정딘다.
    - 프로세스는 또한 동시에 동일한 위치에 쓰지 않도록 보장할 책임을 진다.

<br/>

<br/>

- 이러한 두 가지 방법은 보편적이며, 시스템 대부분은 둘 다 구현한다.
    - 메시지 전달 : 소량의 데이터를 교환할 때 유용
        - 컴퓨터 간의 통신을 위해 메모리 공유보다 구현하기가 쉽다.
    - 공유 메모리 : 한 컴퓨터 내에서 메모리 전송 속도로 수행 → 속도가 빠르고 통신이 편리
        - 단, 보호와 동기화 부분에서 여러 문제점을 가진다.

<br/>

<br/>

**보호**

- 컴퓨터 시스템이 제공하는 자원에 대해 접근을 제어하기 위한 기법을 지원한다.
    - 통상 보호를 지원하는 시스템 콜은 자원의 허가 설정하는 데에 이용된다.

<br/>

<br/>

## 💡 시스템 서비스

- 현대 시스템의 또 다른 면은 시스템 서비스의 집합체이다.
    - 최하위 수준은 하드웨어, 그 다음은 운영체제, 그 다음은 시스템 서비스, 마지막이 응용이다.

<br/>

<br/>

- 시스템 서비스는 시스템 유틸리티로도 알려진, 프로그램 개발과 실행을 위해 더 편리한 환경을 제공한다.
    - 이들 중 몇몇은 단순히 시스템 콜에 대한 사용자 인터페이스이며, 반면에 나머지는 훨씬 더 복잡하다.
    - 이들을 몇 가지 범주로 분류해보자

<br/>

<br/>

- **파일 관리**
    - 프로그램은 파일과 디렉토리를 생성, 삭제, 복사, 개명, 인쇄, 열거, 조작한다.

<br/>

<br/>

- **상태 정보**
    - 어떤 프로그램은 단순히 시스템에게 날짜, 시간, 사용 가능한 메모리 등의 상태를 묻는다.
    - 다른 프로그램은 더 복잡하여 상세한 성능, 로깅 및 디버깅 정보를 제공한다.
    - 몇몇 시스템은 환경 설정 정보를 저장하고 검색할 수 있는 **등록** 기능을 지원하기도 한다.

<br/>

<br/>

- **파일 변경**
    - 디스크나 다른 저장 장치에 저장된 파일의 내용을 생성하고 변경하기 위해 다수의 문장 편집기를 사용할 수 있다.
    - 파일의 내용을 검색하거나 변환하기 위한 특수 명령어가 제공되기도 한다.

<br/>

<br/>

- **프로그래밍 언어 지원**
    - 일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 해석기가 종종 운영체제와 함께 사용자에게 제공되기도 한다.

<br/>

<br/>

- **프로그램 적재와 수행**
    - 프로그램이 어셈블되거나 컴파일된 후, 그것이 수행되려면 반드시 메모리에 적재되어야 한다.
    - 시스템은 절대 로더, 배치 가능 로더, 링키지 에디터와 중첩 로더 등을 제공할 수 있다.
    - 또한 고급어나 기계어를 위한 디버깅 시스템도 필요하다.

<br/>

<br/>

- **통신**
    - 이들 프로그램은 프로세스, 사용자, 그리고 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 제공한다.
    - 이들 프로그램은 사용자가 메시지를 전송하거나, 원거리에서 로그인을 할 수 있도록 한다.

<br/>

<br/>

- **백그라운드 서비스**
    - 모든 범용 시스템은 부트할 때 특정 시스템 프로그램을 시작시킬 수 있는 방법을 가지고 있다.
    - 이러한 프로세스 중 일부는 자신들의 할 일을 완수하면 종료하는 반면에, 일부는 시스템이 정지될 때까지 계속해서 실행되는 프로세스도 존재한다.
    - 항상 실행되는 시스템 프로그램 프로세스는 **서비스**, **서브시스템**, 또는 디먼으로 알려져 있다.

<br/>

<br/>

- 운영체제 대부분은 시스템 프로그램과 함께 일반적인 문제점을 해결하거나 일반적인 연산을 수행하는 데 유용한 프로그램들도 제공한다.
    - 이러한 응용 프로그램에는 웹브라우저, 컴파일러 등등이 포함된다.

<br/>

<br/>

- 사용자 대부분이 보는 운영체제의 관점은 실제의 시스템 콜에 의해서보다는 시스템 프로그램과 응용에 의해 정의된다.
    - ex) 컴퓨터를 켰을때 보이는 GUI와 CLI는 모두 동일한 시스템 콜이지만, 다르게 보이고 동작한다.


<br/>

<br/>

## 💡 링커와 로더

>💡 일반적으로 프로그램은 디스크에 이진 실행 파일로 존재한다. CPU에서 실행하려면 프로그램을 메모리로 가져와 프로세스 형태로 배치되어야 하는데, 이 절차들을 단계별로 살펴보자.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/linker-and-loader.png" width = 700/>

<br/>

<br/>

- 소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일된다.
    - 이러한 형식을 **재배치 가능 오브젝트 파일**이라고 한다.

<br/>

<br/>

- 다음으로 **링커**는 이러한 재배치 가능 오브젝트 파일을 하나의 **이진** 파일로 결합한다.
    - 링킹 단계에서 표준 C 또는 수학 라이브러리와 같은 다른 파일들이 포함될 수 있다.

<br/>

<br/>

- 로더는 이진 실행 파일을 메모리에 적재하는 데 사용되며, CPU 코어에서 실행할 수 있는 상태가 된다.
    - 링크 및 로더와 관련된 활동은 **재배치**로, 프로그램 부분에 최종 주소를 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 조정하여야 한다.

<br/>

<br/>

- 위 그림(2.11)에서 로더를 실행하려면 명령어 라인에 실행 파일을 입력하기만 하면 된다는 것을 알 수 있다!
    - 프로그램 이름 입력 → `fork()` : 새 프로세스 생성 → `exec()` : 로더를 호출 후 실행 파일 이름 전달 → 로더 : 주소 공간을 사용해 메모리에 적재

<br/>

<br/>

- 실제로 시스템 대부분에서는 프로그램이 적재될 때 라이브러리를 동적으로 링크할 수 있게 한다.
    - ex) Windows는 동적 링킹 라이브러리(**DLL**)를 지원한다.
    - 이 방법의 장점은 실행 파일에서 사용되지 않을 수 있는 라이브러리를 링크하고 로드하지 않아도 된다는 것이다.
    - 대신, 라이브러리는 조건부로 링크되며 프로그램 실행 시간에 필요한 경우 적재된다.

<br/>

<br/>

- 오브젝트 파일 및 실행 파일은 일반적으로 표준화된 형식을 가진다.
    - 이 표준 형식은 컴파일된 기계 코드 및 프로그램에서 참조되는 함수 및 변수에 대한 메타데이터를 포함하는 기호 테이블을 포함한다.
    - UNIX 및 Linux의 경우 이 표준을 ELF(**Executable and Linkable Format**)이라고 한다.
    - Windows는 PE**(Portable Executable)** 형식을, macOS는 **Mach-O** 형식을 사용한다.


<br/>

<br/>

## 💡 응용 프로그램이 운영체제마다 다른 이유

- 각 운영체제는 고유한 시스템 콜 집합을 제공한다.
    - 시스템 콜은 응용 프로그램이 사용할 수 있도록 운영체제가 제공하는 서비스 집합의 일부이다.
    - 시스템 콜은 어느 정도 같더라도 다른 장벽으로 인해 응용 프로그램을 다른 운영체제에선 실행이 어렵다.

<br/>

<br/>

- 아래 세 가지 방법 중 한 가지를 사용하여 응용 프로그램이 여러 운영체제에서 실행될 수 있게 만들수 있다.
    1. 응용 프로그램은 운영체제마다 인터프리터가 제공되는 인터프리터 언어로 작성될 수 있다.
        1. 인터프리터는 소스 프로그램의 각 라인을 읽고, 상응하는 기계어 명령을 하고, 해당 운영체제의 시스템 콜을 호출한다.
        2. 기계어 코드로 구성된 응용에 비해 성능이 떨어지고, 인터프리터는 각 운영체제 기능의 일부만 제공하므로 관련 응용의 기능도 제한될 수 있다.
    2. 응용 프로그램은 실행 중인 응용을 포함하고 있는 가상 머신을 가진 언어로 작성될 수 있다.
        1. 가상 머신은 언어의 RTE 중 일부이다. 예를 들면 Java의 JVM
        2. 이 RTE는 메인 프레임에서 스마트폰에 이르기까지 많은 운영체제에 **이식**되었다.
    3. 응용 프로그램 개발자는 컴파일러가 기기 및 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API를 사용할 수 있다.
        1. 응용은 실행될 각 운영체제로 이식되어야 한다. 이 이식은 많은 시간이 소요되며, 많은 시험과 디버깅을 거쳐 응용 프로그램의 새로운 버전마다 수행되어야 한다.

<br/>

<br/>

- 이론적으로 세 가지 접근 방식은 다양한 운영체제에서 실행될 솔루션을 제공하는 것 같다.
    - 단, 응용의 이동성이 부족한 데에는 여러 가지 원인이 있다 → 이로 인해 크로스 플랫폼 개발이 어렵다.

<br/>

<br/>

- 아래를 포함하여 시스템의 낮은 수준에는 다른 어려운 점이 존재한다.
    - 각 운영체제에는 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 이진 형식이 있다.
        - 이러한 구성요소는 명시된 구조 형태로 실행 파일 내의 특정 위치에 있어야 운영체제가 파일을 열고 응용을 적재하여 올바르게 실행할 수 있다.
    - CPU는 다양한 명령어 집합을 가지며 해당 명령어가 포함된 응용 프로그램만 올바르게 실행할 수 있다.
    - 운영체제는 응용 프로그램이 파일 생성과 네트워크 연결 열기와 같은 다양한 활동을 요청할 수 있는 시스템 콜을 제공한다.
        - 이러한 시스템 콜은 사용되는 피연산자, 순서, 호출방법 등이 운영체제마다 다르다.

<br/>

<br/>

- 이러한 구조적 차이점을 완전히 해결하지는 못했지만 해결하는 데 도움이 되는 몇 가지 방법이 있다.
    - ex) Linux와 거의 모든 UNIX 시스템에서 이진 실행 파일은 ELF 형식을 채택했다.
    - API는 응용 프로그램 수준에서 특정 기능을 지정한다.
        - 아키텍처 수준에서 이진 코드의 여러 구성요소가 주어진 아키텍처에서 특정 운영체제와 상호 작용할 수 있는 방법을 정의하는데 ABI(**Application Binary Interface**)가 사용된다.
        - ABI는 주소 길이, 시스템 콜에 매개변수를 전달하는 방법 등 세부 정보를 명시한다.

<br/>

<br/>

- 일반적으로 ABI는 특정 아키텍처 수준의 API이다.
    - 이진 실행 파일이 특정 ABI에 따라 컴파일되고, 링크된 경우 해당 ABI를 지원하는 다른 시스템에서 실행될 수 있어야 한다.
    - 그러나 특정 아키텍처에서 실행되는 특정 운영체제에 대해 ABI가 정의되어 있기 때문에 ABI는 플랫폼 간 호환성을 거의 제공하지 않는다.

<br/>

<br/>

- 요약하면, 이러한 모든 차이점은 특정 CPU 유형의 특정 운영체제에서 인터프리터, RTE 또는 이진 실행 파일을 작성하고 컴파일하지 않으면 응용이 실행되지 않는다는 것을 의미한다.

<br/>

<br/>

## 💡 운영체제 설계 및 구현

> 💡 운영체제를 설계하고 구현할 때 우리가 당면하는 문제점을 논의한다. 이들 설계 문제점에 대한 완전한 해결책은 없지만, 성공적인 접근 방법들을 나타낸다.

<br/>

<br/>

### 설계 목표

- 설계에서 첫째 문제점은 시스템의 목표와 명세를 정의하는 일이다.
    - 시스템  설계는 최상위 수준에서는 하드웨어와 시스템 유형의 선택에 의해 영향을 받을 거이다.

<br/>

<br/>

- 이 최상위 설계 수준을 넘어서면 요구 조건들을 일일이 명시하는 것이 훨씬 어려워진다.
    - 그러나 이러한 요구 조건은 근본적으로 **사용자 목적**과 **시스템 목적**의 두 가지 기본 그룹으로 나눌 수 있다.

<br/>

<br/>

- 사용자들이 시스템에 기대하는 특징들이 존재한다.
    - 사용하기 쉽고, 편리하며, 배우기 쉽고, 믿을 수 있고, 안전하고, 신속해야 한다.
    - 이런 요구 조건들이 시스템을 설계, 생성, 유지, 조작해야 하는 사람들에 의해 정의될 수 있다.

<br/>

<br/>

- 요약하면 운영체제에 대한 요구를 정의하는 문제를 해결하는 유일한 해법은 없다.
    - 많은 시스템에서 다른 요구 조건들이 다른 환경을 위해 다양한 해결 방법을 낳을 수 있음을 보여준다.

<br/>

<br/>

### 기법과 정책

- 한가지 중요한 원칙은 ***기법으로부터 정책을 분리***하는 것이다.
    - ***기법*** : 어떤 일을 어떻게 할 것인가를 결정
    - ***정책*** : 무엇을 할 것인가를 결정

<br/>

<br/>

- 정책과 기법의 분리는 융통성을 위해 아주 중요하다.
    - 정책은 장소가 바뀌거나 시간이 흐름에 따라 변경될 수 있따.
    - 최악의 경우, 정책의 각 변경이 저변에 깔린 기법의 변경을 요구하게 된다.
    - 여러 정책에서 사용되기에 충분한 융통성 있는 일반적인 기법이 더 바람직하다.

<br/>

<br/>

- 마이크로 커널 기반 운영체제는, 프리미티브 빌딩 블록의 기본 집합을 구현함으로써 기법과 정책의 분리를 극단적으로 추구한다.
    - 이 블록들은 정책으로부터 거의 자유로우며, 더 고급의 기법과 정책들이 사용자 생성 커널 모듈이나 사용자 프로그램 자체를 통해 첨가될 수 있도록 한다.

<br/>

<br/>

- 정책 결정은 모든 자원 할당 문제에 있어 중요하다.
    - 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야 한다.
    - 질문이 ***무엇(what)***이 아니라 ***어떻게(how)***일 때마다, 반드시 결정되어야 하는 것이 ***기법***이다.

<br/>

<br/>

### 구현

- 운영체제 설계가 완료되면 구현되어야 한다.
    - 운영체제는 많은 사람에 의해 오랫동안 개발된 많은 프로그램의 집합체이기 때문에 구현 방법에 대해 일반적으로 언급하는 것은 어렵다.

<br/>

<br/>

- 초기 운영체제는 어셈블리 언어로 작성되었다.
    - 이제 대부분은 C 또는 C++와 같은 고급 언어로 작성되며, 극히 일부의 시스템이 어셈블리 언어로 작성된다.
    - 실제로 둘 이상의 고급 언어가 종종 사용된다.
        - 커널의 최하위 레벨은 어셈블리 언어 및 C로 작성될 수 있다.
        - 상위 레벨 루틴은 C 및 C++로 작성될 수 있다.

<br/>

<br/>

- Android는 좋은 예를 제공한다.
    - 커널은 대부분 약간의 어셈블리 언어를 함께 사용하고 C로 작성되었다.
    - 안드로이드는 대부분은 C 또는 C++로, 개발자 인터페이스를 제공하는 프레임워크는 대부분 Java다.

<br/>

<br/>

- 운영체제를 구현하기 위한 **고급 언어나 최소한 시스템 구현 언어를 사용함으로써 생기는 장점**은 그 언어가 응용 프로그램을 위해 사용될 때 생기는 장점과 마찬가지다.
    - 즉, 코드를 빨리 작성할 수 있으며, 더욱 간결하고, 이해하기 쉽고, 디버그하기도 쉽다.
    - 추가로, 컴파일러 기술의 향상은 단순한 재 컴파일에 의해 코드를 향상시킬 것이다.
    - 마지막으로 운영체제가 고급언어로 작성된 경우 다른 하드웨어로 이식하는 것이 훨씬 쉽다.

<br/>

<br/>

- 운영체제를 **고급 수준 언어로 구현하는 것에 대해 주로 주장되는 단점**은 속도가 느리고 저장 장치가 많이 소요되는 것이다.
    - 그러나 이것은 현재 시스템에서는 주된 문제가 아니다.

<br/>

<br/>

- 다른 시스템에서도 알려진 사실이지만, ***운영체제의 주요 성능 향상***은 우수한 어셈블리어 코드보다는 ***좋은 자료구조와 알고리즘***일 가능성이 크다.
    - 게다가 운영체제가 크긴 하지만, 단지 소량의 코드만이 고성능이 중요하다.
    - 아마도 인터럽트 핸들러, 입출력 관리자, 메모리 관리자와 CPU 스케줄러가 가장 긴급한 루틴이다.


<br/>

<br/>

## 💡 운영체제 구조

> 💡 운영체제와 같이 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있으려면 신중해야 한다.
>
>일반적인 접근 방법은 한 개의 일관된 시스템보다는 태스크를 작은 구성요소로 분할하는 것이다.

### 모놀리식 구조

- 운영체제를 구성하는 가장 간단한 구조는 구조가 아예 없는 것이다.
    - 즉, 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것이다.
    - 모놀리식 구조라고 하는 이 방법은 운영체제를 설계하는 일반적인 기술이다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/UNIX-structure.png" width = 700/>

<br/>

<br/>

- 제한적인 구조를 가진 운영체제의 예는 최초의 UNIX 운영체제로, 커널과 시스템 프로그램의 두 부분으로 구성된다.
    - 커널은 여러 가지 인터페이스와 장치 드라이버로 다시 분리되는데, 이들은 UNIX가 발전해 오면서 여러 해 동안 추가되고 확장된 것이다.

<br/>

<br/>

- 커널은 시스템 콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리 그리고 다른 운영체제 기능을 제공한다.
    - 요약하면, 그것은 하나의 주소 공간으로 결합하기에는 엄청나게 많은 기능이다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/Linux-structure.png" width = 700/>

<br/>

<br/>

- Linux 운영체제는 UNIX에 기반을 두고 있다.
    - Linux 커널은 단일 주소 공간에서 커널 모드로 전부 실행된다는 점에서 모놀리식이지만, 런타임 중에 커널을 수정할 수 있는 모듈식 설계를 갖추고 있다.

<br/>

<br/>

- 모놀리식 커널은  성능 면에서 뚜렷한 이점이 있다.
    - 시스템 콜 인터페이스에는 오버헤드가 없고 커널 안에서의 통신 속도가 빠르다.
    - 따라서 모놀리식 커널의 단점에도 불구하고, 속도와 효율성은 이 구조의 증거를 여전히 UNIX, Linux 및 Windows 운영체제에서 발견할 수 있는 이유를 설명한다.

<br/>

<br/>

### 계층적 접근

> 💡 모놀리식 : 한 부분의 변경이 다른 부분에 영향을 줄 수 있음 → **밀접하게 결합**
>
> 대안으로 제시되는 **느슨한 결합** → 계층적 접근 방식

<br/>

<br/>

- 이 시스템은 기능이 특정 기능 및 한정된 기능을 가진 개별적이며 작은 구성요소로 나뉜다.
    - 이 모든 구성요소가 합쳐져 커널을 구성한다.

<br/>

<br/>

- 이 모듈 방식의 장점은 한 구성요소의 변경이 다른 구성요소에는 영향을 미치지 않는다.
    - 따라서 시스템 구현자가 시스템의 내부 작동을 더 자유롭게 생성하고 변경할 수 있다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/layered.png" width = 700/>

- 시스템은 다양한 방식으로 모듈화될 수 있다.
    - 한가지 방식이 계층적 접근 방식인데, 이 방식은 운영체제가 여러 개의 층으로 나뉜다.

<br/>

<br/>

- 운영체제 층은 데이터와 이를 조작하는 연산으로 구성된 추상된 객체의 구현이다.
    - 전형적인 운영체제 층(편의상 M층)은 자료구조와 상위층에서 호출할 수 있는 루틴의 집합이다.
    - 층 M은 다시 하위층에 대한 연산을 호출할 수 있다.

<br/>

<br/>

- 계층된 접근 방식의 주된 장점은 구현과 디버깅의 간단함에 있다.
    - 층들은 단지 자신의 하위층들의 서비스와 기능들만을 사용하도록 선택된다.
    - 이러한 접근 방식은 시스템의 검증과 디버깅 작업을 단순화한다.

<br/>

<br/>

- 첫번째 층의 정의에 의해 하드웨어만을 사용하여 이 층을 구현하기 때문에, 나머지 시스템에 아무런 신경을 쓰지 않고 디버깅할 수 있다.
    - 첫번째 층의 디버깅이 끝나면, 두번째 층을 디버깅하는 동안 그것이 정확하게 동작한다고 가정될 수 있으며, 이러한 과정이 반복된다!
    - 만일 어느 층의 디버깅 중 오류가 발견되면 그 하위의 층은 이미 디버깅되었기 때문에 오류는 반드시 그 층에 있다.
    - 따라서 시스템을 계층으로 나누면 시스템의 설계나 구현이 간단해진다.

<br/>

<br/>

- 각 층은 자신보다 하위 수준의 층에 의해 제공된 연산들만 사용해 구현한다.
    - 한 층은 이러한 연산들이 어떻게 구현되는 지 알 필요가 없고, 다만 이러한 연산들이 무엇을 하는지만 알면 된다.
    - 그러므로 각 층은 특정 데이터 구조, 연산, 그리고 하드웨어의 존재를 상위층에 대해 숨기게 된다.

<br/>

<br/>

- 계층화된 시스템은 컴퓨터 네트워크 및 웹 응용 프로그램에서 성공적으로 사용됐다.
    - 그럼에도 불구하고 순수한 계층 접근 방식을 사용하는 운영체제는 비교적 적다.
    - 한 가지 이유는 각 계층의 기능을 적절히 정의해야 하는 문제와 관련이 있다.
    - 또한 이러한 시스템의 전반적인 성능은 운영체제 서비스를 얻기 위해 사용자 프로그램이 여러 계층을 통과해야 하는 오버헤드로 인해 열악하다.

<br/>

<br/>

- 그러나 어느 정도의 계층화는 현재 운영체제에서 공통적이다.
    - 일반적으로 시스템은 더 많은 기능을 가진 더 적은 개수의 층을 가지므로 층 기능의 정의 및 상호작용의 문제를 피하면서 모듈화된 코드의 장점을 최대한 활용할 수 있다.

<br/>

<br/>

### 마이크로커널

>💡 1980년대 중반, 한 대학 연구자들이 **마이크로커널** 접근 방식을 사용해 커널을 모듈화한 **Mach**라 불리는 운영체제를 개발하였다.


<br/>

<br/>

- 이 방법은 모든 중요치 않은 구성요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다. → 결과는 더 작은 커널!
    - 어느 서비스가 커널에 남아 있어야 하고, 어느 서비스가 사용자 공간에 구현되어야 할지에 대해서는 의견이 일치하지 않는다.

<br/>

<br/>

- 마이크로커널의 주 기능
    - 클라이언트 프로그램과 역시 사용자 공간에서 수행되는 다양한 서비스 간에 통신을 제공한다.

<br/>

<br/>

- 마이크로 커널 접근법의 장점
    - 운영체제의 확장이 쉽다!
    - 모든 새로운 서비스는 사용자 공간에 추가되며, 따라서 커널은 변경할 필요가 없다.
    - 커널이 변경되어야만 할 때는, 마이크로커널이 작은 커널이기 때문에 변경할 대상이 비교적 적은 경향이 있다.
        - 결과적으로 운영체제는 한 하드웨어로부터 다른 하드웨어로의 이식이 쉽다!

<br/>

<br/>

- 마이크로커널은 서비스 대부분이 커널이 아니라 사용자 프로세스로 수행된다.
    - 따라서 높은 보안성과 신뢰성을 제공한다.
    - 만일 한 서비스가 잘못되더라도, 운영체제의 다른 부분은 아무런 영향을 받지 않는다.

<br/>

<br/>

- 마이크로커널 운영체제의 잘 알려진 예시
    - macOS 및 iOS의 커널 구성요소인 Darwin
    - 실시간 운영체제인 QNX

<br/>

<br/>

- 안타깝게도 마이크로커널은 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다.
    - 두 개의 사용자 수준 서비스가 통신해야 하는 경우 별도의 주소 공간에 서비스가 존재하기 때문에 메시지가 복사되어야 한다.
    - 또한 운영체제는 메시지를 교환하기 위해 한 프로세스에서 다음 프로세스로 전환해야 할 수도 있다.

<br/>

<br/>

### 모듈

> 💡 운영체제를 설계하는데 이용되는 최근 기술 중 최선책은 아마 **적재가능 커널 모듈(LKM)** 기법이다.


<br/>

<br/>

- 이 접근법에서는 커널은 핵심적인 구성요소의 집합만 가지고 있고 부팅 때 또는 실행 중에 부가적인  서비스들을 모듈을 통하여 링크할 수 있다.

<br/>

<br/>

- 설계의 주안점은 커널은 핵심 서비스를 제공하고 다른 서비스들은 실행되는 동안 동적으로 구현하는 것이다
    - 서비스를 동적으로 링크하는 것은 새로운 기능을 직접 커널에 추가하는 것보다 바람직하다.

<br/>

<br/>

- 전체적인 결과는 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조를 닮았다.
    - 그러나 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층 구조보다 유연하다.
    - 중심 모듈은 단지 핵심 기능만 가지고, 다른 모듈들과 어떻게 통신하는지 안다는 점에서는 마이크로 커널과 유사하다.

<br/>

<br/>

### 하이브리드 시스템

- 사실 엄격하게 정의된 하나의 구조를 채택한 운영체제는 거의 존재하지 않는다.
    - 대신 다양한 구조를 결합해 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조로 구성된다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/macOS-and-iOS.png" width = 700/>

<br/>

<br/>

**macOS와 iOS**

- 구조적으로 macOS와 iOS는 공통점이 많으므로 공유하는 내용과 서로 다른점을 강조한다.
    - 다양한 층의 주요 특징은 다음과 같다.

<br/>

<br/>

- **사용자 경험 층**
    - 이 층은 사용자가 컴퓨팅 장치와 상호 작용할 수 있는 소프트웨어 인터페이스를 정의한다.

<br/>

<br/>

- **응용 프로그램 프레임워크 층**
    - Cocoa 및 Cocoa Touch 프레임워크가 포함되며, Objective-C 및 Swift 프로그래밍 언어에 대한 API를 제공한다.

<br/>

<br/>

- **핵심 프레임워크**
    - 이 층은 Quicktime 및 OpenGL을 포함한 그래픽 및 미디어를 지원하는 프레임워크를 정의한다.

<br/>

<br/>

- **커널 환경**
    - **Darwin**이라고 불리는 이 환경에는 Mach 마이크로커널과 BSD UNIX 커널이 포함된다.

<br/>

<br/>

- 응용 프로그램은 사용자 경험 기능을 이용하거나 이 기능을 우회하여 응용 프로그램 프레임워크 또는 핵심 프레임워크와 직접 상호작용하도록 설계될 수 있다.
    - 또한 응용 프로그램은 프레임워크를 완전히 버리고 커널 환경과 직접 통신할 수 있다.

<br/>

<br/>

- macOS와 iOS의 중요한 차이점은 아래와 같다.
    - macOS : 컴퓨터용 시스템이므로 Intel 아키텍처에서 실행되도록 컴파일된다.
    iOS : 모바일 장치용으로 설계되었으므로 ARM 기반 아키텍처용으로 컴파일된다.
    - iOS는 일반적으로 macOS보다 개발자에게 훨씬 더 제한적이며 폐쇄적이다

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/darwin.png" width = 700/>

<br/>

<br/>

- Darwin은 주로 Mach 마이크로커널과 BSD UNIX 커널로 구성된 계층화된 시스템이다.
    - Mach 시스템 콜(**트랩**이라고 함)과 BSD 시스템 콜 ***두 개***의 시스템 콜 인터페이스를 제공한다.
    - 이러한 시스템 콜에 대한 인터페이스는 표준 C 라이브러리 뿐만 아니라 네트워킹, 보안 및 프로그래밍 언어 자원을 제공하는 라이브러리를 포함하는 풍부한 집합이다.

<br/>

<br/>

- 시스템 콜 인터페이스 아래에서 Mach는 메모리 관리, CPU 스케줄링 및 메시지 전달 및 원격 프로시저 호출과 같은 프로세스 간 통신(IPC) 기능을 포함한 기본 운영체제 서비스를 제공한다.
    - Mach에서 제공하는 대부분의 기능은 **커널 추상화**를 통해서 사용 가능하다.
    - 이 추상화에는 태스크, 스레드, 메모리 객체 및 포트가 포함된다.

<br/>

<br/>

**Android**

- 안드로이드는 스마트폰과 태블릿을 위해 개발되었다.
- iOS와 반대로, Android는 다양한 모바일 플랫폼에서 실행되며 공개 소스이다!

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/android-architecture.png" width = 700/>

<br/>

<br/>

- Android는 그래픽, 오디오 및 하드웨어 기능을 지원하는 다양한 프레임워크를 제공하는 계층화된 소프트웨어 스택이라는 점에서 iOS와 유사하다.

<br/>

<br/>

- Android 장치의 소프트웨어 설계자는 Java 언어로 응용 프로그램을 개발하지만, 일반적으로 표준 Java API를 사용하지 않는다.
    - Google은 Java 개발을 위해 별도의 Android API를 설계하였다.

<br/>

<br/>

- ART는 Android용으로 설계되어 메모리와 CPU 처리 능력이 제한적인 모바일 장치에 최적화된 가상 머신이다.
    - 많은 Java 가상 머신이 응용 프로그램 효율성을 향상시키기 위해 JIT 컴파일을 수행하는 반면,
    - ART는 **AOT(ahead-of-time)** 컴파일을 수행한다.


<br/>

<br/>

## 💡 운영체제 빌딩과 부팅

>💡 하나의 특정 기기 구성에 맞게 운영체제를 설계, 코딩 및 구현할 수 있다. 
>
> 그러나 보다 일반적으로 운영체제는 다양한 주변장치 구성을 가진 모든 종류의 컴퓨터에서 실행되도록 설계된다.

<br/>

<br/>

### 운영체제 생성

- 가장 일반적으로 컴퓨터 시스템은 구매 시 운영체제가 이미 설치되어 있다.
    - 예외적으로 운영체제가 없는 컴퓨터를 샀다고 가정하자.

<br/>

<br/>

- 운영체제를 처음부터 생성하는 경우 다음 절차를 밟아야 한다.
    1. 운영체제 소스 코드를 작성한다.
    2. 운영ㅔ제가 실행될 시스템의 운영체제를 구성한다.
    3. 운영체제를 컴파일한다.
    4. 운영체제를 설치한다.
    5. 컴퓨터와 새 운영체제를 부팅한다.

<br/>

<br/>

- 시스템을 구성하려면 어떤 기능이 포함되는지 명시해야 하며, 이는 운영체제마다 다르다.
    - 일반적으로 시스템 구성 방법을 설명하는 매개변수는 특정 유형의 구성 파일에 저장된다.

<br/>

<br/>

- 한편으로는 시스템 관리자가 이를 사용하여 운영체제 소스 코드의 사본을 수정할 수 있다.
    - 그런 다음 운영체제가 완전히 컴파일된다.(**시스템 빌드**라고 함)
    - 컴파일 시 주어진 데이터 선언, 초기화 및 상수는 구성 파일에 설명된 시스템에 맞는 운영체제를 생성한다.

<br/>

<br/>

- 상세한 조정을 할 수 없는 수준에서는?
    - 시스템 설명을 통하여 기존 라이브러리에서 사전 컴파일된 오브젝트 모듈을 선택할 수 있다.
    - 이 모듈들이 서로 링크되어 새 운영체제가 생성된다.
    - 이 과정을 통해 지원되는 모든 I/O 장치의 장치 드라이버를 포함한 라이브러리에서 필요한 것만 선택하여 운영체제에 링크할 수 잇다!

<br/>

<br/>

- 다른 극단적인 경우에는 완전히 모듈 방식으로 시스템을 구성할 수 있다!
    - 여기서 선택은 컴파일 또는 링크 시간이 아닌 실행 시간에 일어난다.
    - 시스템 생성은 단순히 시스템 구성을 설명하는 매개변수의 설정만 하면 된다.

<br/>

<br/>

- 이러한 접근 방식의 주요 차이점
    - 생성된 시스템의 크기 및 일반성과 하드웨어 구성이 변경될 때 ***변경될 때 변경이 얼마나 쉬운가***에 있다.
    - 임베디드 시스템의 경우 첫 번째 접근 방식을 채택하고, 특정 정적 하드웨어 구성을 위한 운영체제를 생성하는 것은 드문 일이 아니다.
    - 데스크톱 및 랩톱 컴퓨터와 모바일 장치를 지원하는 최신 운영체제는 두 번째 방식을 채택한다.
    
<br/>

<br/>


> 즉, 운영체제는 여전히 특정 하드웨어 구성을 위해 생성되지만, 적재가능 커널 모듈과 같은 기술을 사용하면 시스템의 동적 변경을 위한 모듈 방식을 지원할 수 있다!
> 

<br/>

<br/>

    

- 시스템이 재부팅되면 이 새 운영체제가 실행되기 시작한다.
    - 대안으로 Linux 가상 머신을 설치하여 기존 시스템을 수정할 수 있다.
    - 그러면 호스트 운영체제가 Linux를 실행하는 방식이다.

<br/>

<br/>

- Linux를 가상 머신으로 설치하기 위한 몇 가지 옵션이 있다.
    - 한 가지 대안은 처음부터 가상 머신을 빌드하는 것이다.
        - 이는 Linux 시스템을 처음부터 빌드하는 것과 유사하지만, 운영체제는 컴파일 할 필요가 없다!
    - 또 다른 방법은 이미 빌드 및 구성된 운영체제인 Linux 가상 머신 어플라이언스를 이용하자!
        - 이 옵션을 사용하려면 단순 다운로드하고, VirtualBox 같은 가상화 소프트웨어를 사용하면 된다.

<br/>

<br/>

### 시스템 부트

- 운영체제가 생성된 후에는 하드웨어에서 새 운영체제를 사용할 수 있어야 한다.
    - 그럼 하드웨어는 커널의 위치 또는 커널을 적재하는 방법을 어떻게 알까?
    - 커널을 적재하여 컴퓨터를 시작하는 과정을 **시스템 부팅**이라고 한다.

<br/>

<br/>

- 시스템 대부분에서 부팅 과정은 아래와 같다.
    1. **부트스트랩 프로그램** 또는 **부트 로더**라고 불리는 작은 코드가 커널의 위치를 찾는다.
    2. 커널이 메모리에 적재되고 시작된다.
    3. 커널은 하드웨어를 초기화한다.
    4. 루트 파일 시스템이 마운트 된다.

<br/>

<br/>

→ 이번 절에서 이 부팅 과정에 대해 자세히 알아보자!

<br/>

<br/>

- 일부 컴퓨터 시스템은 다단계 부팅 과정을 사용한다.
    - 컴퓨터 전원을 처음 켜면 **BIOS**라고 하는 비휘발성 펌웨어에 있는 소형 부트 로더가 실행된다.
    - 이 초기 부트 로더는 일반적으로 부트 블록이라고 하는 디스크의 정해진 위치에 있는 두 번째 부트 로더를 적재하는 작업만 한다.

<br/>

<br/>

- 부트 블록에 저장된 프로그램은 전체 운영체제를 메모리에 적재하고, 실행을 시작하기에 충분히 정교하다.
    - 더 일반적으로, 이 부트 로더는 간단한 코드로서 디스크의 주소와 부트스트랩 프로그램 나머지의 길이만 알고 있다.

<br/>

<br/>

- 많은 최신 컴퓨터 시스템이 BIOS 기반 부팅 과정을 **UEFI**로 대체하였다.
    - ***UEFI : Unified Extensible Firmware Interface)***
    - UEFI의 BIOS에 비해 가지는 가장 큰 장점?

        → UEFI가 하나의 완전한 부팅 관리자이므로, 다단계 BIOS보다 ***부팅 과정이 빠르다!***
        

<br/>

<br/>

- 부트스트랩 프로그램은 BIOS에서 부팅하든 UEFI에서 부팅하든 다양한 작업을 수행할 수 있다.
    - 커널 프로그램이 포함된 파일을 메모리에 적재하는 것 외에도 진단을 실시하여 메모리와 CPU를 점검하고 장치 검색과 같은 시스템 상태를 확인한다.
    - 진단을 통과하면 프로그램을 부팅 과정을 계속 진행할 수 있다.

<br/>

<br/>

- 부트스트랩은 CPU 레지스터에서 장치 컨트롤러 및 메인 메모리의 내용에 이르기까지 시스템의 모든 측면을 초기화 할 수 있다.
    - 조만간 운영체제를 시작하고 루트 파일 시스템을 마운트 한다.
    - 바로 **이 시점에서 시스템이 실행 중**이라고 말할 수 있다.

<br/>

<br/>

- **GRUB**은 Linux 및 UNIX 시스템을 위한 공개 소스 부트스트랩 프로그램이다.
    - 시스템의 부트 매개변수는 GRUB 구성 파일에 설정되며 GRUB의 실행 시작 시점에 적재된다.
    - GRUB는 융통성이 있어 부팅 시 커널 매개변수를 수정하거나 부팅 가능한 다른 커널 중 하나를 선택하는 것도 가능하다.

<br/>

<br/>

- 공간을 절약하고 부팅 시간을 줄이기 위해 Linux 커널 이미지는 압축 파일이며, 메모리에 적재된 후 압축이 풀어진다.
    - 부팅 과정에서 부트 로더는 일반적으로 **initramfs**로 알려진 임시 RAM 파일 시스템을 생성한다.
    - 이 파일 시스템에는 ***실제*** 루트 파일 시스템을 지원하기 위해 설치해야 하는 드라이버와 커널 모듈이 저장되어 있다.

<br/>

<br/>

- 커널이 시작되고 필요한 드라이버가 설치되면 커널은 루트 파일 시스템을 임시 RAM 위치에서 적절한 루트 파일 시스템 위치로 전환한다.
    - 마지막으로 Linux는 시스템의 초기 프로세스인 systemd 프로세스를 생성한 다음 다른 서비스를 시작한다!
    - 궁극적으로 시스템은 사용자에게 로그인 프롬프트를 표시한다.

<br/>

<br/>

- ***부트 메커니즘은 부트 로더와 독립적이지 않다는 사실에 주의할 필요가 있다.***
    - 따라서 BIOS와 UEFI용 특정 GRUB 부트 로더 버전이 있으며 펌웨어는 어떤 특정 부트 로더가 사용되는지 알아야 한다.

<br/>

<br/>

- 모바일 시스템의 부팅 과정은 기존 PC의 부팅 과정과 약간 다르다.
    - ex) 커널은 Linux 기반이지만 Android는 GRUB를 사용하지 않고 대신 부트 로더의 제공을 벤더에게 맡긴다.

<br/>

<br/>

- 대부분의 운영체제 부트 로더의 공통 기능
    - 하드웨어 문제 진단, 손상된 파일 시스템 복구 및 운영체제 재설치 등의 작업을 할 수 있는 **복구 모드** 또는 **단일 사용자 모드**로 부팅할 수 있는 기능을 제공한다.

<br/>

<br/>

## 💡 운영체제 디버깅

> 💡 넓게는 디버깅은 하드웨어와 소프트웨어에서의 시스템의 오류를 발견하고 수정하는 행위이다. 
>
> 성능 문제는 버그로 간주되므로 시스템에서 처리 중에 발생하는 병목 현상을 제거하여 성능을 향상시키려는 성능 조정(performance tuning)도 디버깅에 포함된다.
>
>이 절에서는 커널과 프로세스 오류 및 성능 문제의 디버깅에 관해 알아보자!


<br/>

<br/>

### 장애 분석

- 만일 프로세스가 실패했다면, 운영체제는 시스템 관리자 또는 문제를 발생시킨 사용자에게 경고하기 위해 ***오류 정보를 로그 파일에 기록***한다.
- 운영체제는 또한 프로세스가 사용하던 메모리를 캡쳐한 ***코어 덤프***를 취하고, 차후 분석을 위해 저장한다.
    - 실행 중인 프로그램과 코어 덤프는 디버거에 의해 검사될 수 있으며, 이는 장애 발생 시 프로그래머가 코드와 메모리를 분석할 수 있도록 한다.

<br/>

<br/>

- 사용자 수준 프로세스 코드를 디버깅하는 것은 도전적인 일이다.
    - 커널의 크기와 복잡도, 하드웨어 제어 및 사용자 수준 디버깅 도구가 없기 때문!

<br/>

<br/>

- 커널 장애는 **크래시(crash)**라고 불린다.
    - 프로세스 장애와 마찬가지로, 로그 파일에 저장되고 메모리의 상태가 **크래시 덤프**에 저장된다.

<br/>

<br/>

- 운영체제 디버깅과 프로세스 디버깅은 두 태스크의 근본적인 차이에 의해 서로 다른 도구와 기법을 사용한다.
    - 파일 시스템 코드로 인한 커널 장애는 재부팅 전에 커널의 상태를 파일 시스템에 저장하려는 시도를 위험하게 한다?
    - 가장 일반적인 기법 → 커널의 메모리 상태를 이 용도를 위해 예약된 파일 시스템을 가지지 않은 디스크의 특정 부분에 저장하는 것이다.

<br/>

<br/>

- 커널이 복구 불가능한 오류를 탐지하면 메모리의 전체 내용 또는 적어도 시스템 메모리의 커널이 소유한 부분만이라도 이 디스크 영역에 저장한다.
    - 시스템이 재부팅되면 프로세스는 이 영역으로부터 데이터를 수집하고 분석을 위해 파일 시스템의 크래시 덤프 파일에 기록한다.
    - 분명하게 이러한 전략은 사용자 수준 프로세스를 디버깅 할 땐 필요하지 않다!

<br/>

<br/>

### 성능 관찰 및 조정
> 💡 위에서 처리 병목 지점을 제거함으로써 성능을 향상시키려 한다고 언급했다.

<br/>

<br/>

- 병목 지점을 발견하기 위하여 시스템 성능을 감시할 수 있다.
    - 따라서 시스템 동작을 측정하고 표시할 수 있는 방법을 가지고 있어야 한다.

<br/>

<br/>

- 도구는 ***프로세스별*** 또는 ***시스템 전체***의 관찰을 제공하느냐로 특징이 묘사될 수 있다.
    - 이러한 관찰을 위해 도구는 ***카운터*** 또는 ***추적***의 두 가지 접근 방식 중 하나를 사용할 수 있다.

<br/>

<br/>

**카운터**

- 운영체제는 일련의 카운터를 통해 호출된 시스템 콜 횟수와 같은 활동을 추적한다.

<br/>

<br/>

- 다음은 카운터를 사용하는 Linux 도구의 예이다.
    - 프로세스별
        - `ps` : 하나의 ㅍ로세스에 대한 정보를 보고
        - `top` : 현재 프로세스에 대한 실시간 통계를 보고
    - 시스템 전체
        - `vmstat` : 메모리 사용량 통계를 보고
        - `netstat` : 네트워크 인터페이스에 대한 통계를 보고
        - `iostat` : 디스크의 I/O 사용량을 보고

<br/>

<br/>

- Windows 시스템은 **작업 관리자**를 제공하여 프로세스, CPU, 메모리 사용 등의 통계를 보여준다.

<br/>

<br/>

>💡 *Kernighan’s 법칙*
>
> *”애초에 디버깅은 코드를 작성하는 것보다 두 배 어렵다. 그러므로 가능한 영리하게 코드를 작성한다면, 정의에 따라 디버깅할 만큼 똑똑할 수는 없다.”*


<br/>

<br/>

### 추적

- 카운터 기반 도구는 커널에서 유지 관리하는 특정 통계의 현재 값에 대해 문의한다.
- 반면에, 추적 도구는 시스템 콜과 관련된 단계와 같은 특정 이벤트에 대한 데이터를 수집한다.

<br/>

<br/>

- 다음은 이벤트를 추적하는 Linux 도구의 예이다.
    - 프로세스별
        - strace : 프로세스에 의해 호출된 시스템 콜을 호출한다.
        - gdb : 소스 레벨 디버거
    - 시스템 전체
        - perf : 리눅스 성능 도구 모음
        - tcpdump : 네트워크 패킷을 수집

<br/>

<br/>

- 운영체제가 실행됨에 따라 이해, 디버그 및 조정을 더 쉽게 하는 것은 활발한 연구 및 실무 영역이다.
    - 새로운 세대의 커널 가능 성능 도구는 이 목표를 달성하는 방법을 크게 개선했다.
    - 아래에서 Linux 동적 커널 추적을 위한 툴킷인 BCC를 배워보자!

<br/>

<br/>

### BCC

- 사용자 수준과 커널 코드의 상호 작용을 디버깅하는 것은 양쪽의 코드를 이해하고 상호작용을 계측할 수 있는  도구의 집합 없이는 불가능하다.

<br/>

<br/>

- 이런 도구 집합이 유용하려면?
    - 디버깅을 염두에 두지 않고 작성된 부분을 포함한 시스템의 어느 부분도 디버깅할 수 있어야 한다!
    - 또한 그 작업을 시스템의 안정성을 해치지 않고 할 수 있어야 한다.

<br/>

<br/>

- 즉, 이상적으로는 사용하지 않을 경우에는 성능에 전혀 영향을 주지 않고, 사용중일 때에는 그에 비례하게 성능에 영향을 주어야 한다!
    
    ***→ BCC 도구 집합은 이러한 요구 조건을 만족하면서, 동적이고 안전하며 낮은 영향력을 미친다.***
    
<br/>

<br/>


- **BCC**(BPF Compiler Collection)는 Linux 시스템을 위한 추적 기능을 제공하는 풍부한 툴킷이다.
    - 이는 eBPF 도구에 대한 프런트엔드 인터페이스이다.
    

<br/>

<br/>

- eBPF 프로그램은 C의 부분집합을 사용하여 작성되며 eBPF 명령어로 컴파일된다.
    - eBPF 명령어는 특정 이벤트를 캡쳐하거나 시스템 성능을 관찰하는데 사용될 수 있다.
    - 올바르게 동작하는지 보장하려면 Linux 커널에 삽입하기 전에 **검증기**를 통과해야 한다.

<br/>

<br/>

## 💡 요약

- 운영체제는 사용자 및 프로그램에 서비스를 제공하여 프로그램 실행 환경을 제공한다.

<br/>

- 시스템 콜은 운영체제에서 제공하는 서비스에 대한 인터페이스를 제공한다.

<br/>

- 프로그래머는 시스템 콜 서비스에 액세스하기 위해 시스템 콜의 API를 사용한다.

<br/>

- 링커는 재배치 가능한 여러 오브젝트 모듈을 하나의 이진 실행 파일로 결합한다.

<br/>

- 로더는 실행 파일을 메모리에 적재하여 사용 가능한 CPU에서 실행할 수 있게 된다.

<br/>

- 모놀리식 운영체제는 구조가 없다.
    - 모든 기능은 하나의 주소 공간에서 실행되는 단일 정적 바이너리 파일로 제공된다.
    - 수정하기 어렵다는 단점과 효율성이 좋다는 장점을 가진다.

<br/>

- 계층화된 운영체제는 여러 개의 개별 층으로 나뉜다.
    - 여기서 하위층은 하드웨어 인터페이스이고 상위층은 사용자 인터페이스이다.
    - 일반적으로 성능 문제로 운영체제를 설계하는 데에는 적합하지 않다.

<br/>

- 마이크로커널 접근 방식은 최소한의 커널을 사용한다.
    - 대부분의 서비스는 사용자 수준 응용 프로그램으로 실행된다.

<br/>

- 모듈식 접근 방식은 실행 시간 중에 적재 및 제거할 수 있는 모듈을 통해 운영체제 서비스를 제공한다.

<br/>

- 부트 로더는 운영체제를 메모리에 적재하고 초기화를 수행하며 시스템 실행을 시작한다.
# CPU 스케줄링

CPU 스케줄링(`scheduling`)은 다중 프로그램 운영체제의 기본이다!

- 운영체제는 CPU를 프로세스 간에 교환함으로써, 컴퓨터를 보다 생산적으로 만든다!
- “프로세스 스케줄링”과 “스레드 스케줄링”은 상호 교환적으로 사용되곤 한다.
    - 이 장에서는 일반적 스케줄링 개념을 논의할 때는 “프로세스 스케줄링”을 사용하고,
    - 스레드에 국한된 개념을 가리키는 경우에는 “스레드 스케줄링”이라는 용어를 사용하기로 한다.

<br/>

<br/>

# 💡 기본 개념 _Basic Concepts

앞서 **다중 프로그래밍의 목적**은 **CPU 이용률을 최대화**하기 위해 항상 실행 중인 프로세스를 가진다고 했다.

- 코어가 하나인 시스템에서, 하나의 프로세스가 I/O 요청을 기다린다면?
- CPU는 시간을 낭비하며, 어떤 유용한 작업도 진행하지 못한다! → **CPU 이용률 낭비!**

<br/>

<br/>

다중 프로그래밍은 이러한 낭비를 줄이고, 시간을 생산적으로 활용하려 한다.

- 어떤 프로세스가 대기해야 할 경우, **CPU를 회수**해 다른 프로세스에 할당하고, 이러한 패턴은 반복된다.

<br/>

<br/>

## CPU-I/O 버스트 사이클

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/CPU-IO-burst.png" width = 600/>


CPU 스케줄링의 성공은 프로세스들의 다음과 같은 관찰된 성질에 의해 좌우된다.

- 프로세스 실행은 CPU 실행과 I/O 대기의 **사이클**로 구성된다.
    
    → 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다 한다.
    
- 프로세스 실행은 **CPU 버스트(burst)**로 시작된다.

    → 이후, **I/O 버스트**가 발생하고, 두 버스트의 발생이 반복된다.
    

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/CPU-burst.png" width = 600/>


CPU 버스트들의 지속 시간을 광범위하게 측정한 결과는 아래와 같다.

- 일반적으로 지수형 또는 초지수형으로 특성화된 곡선을 찾아볼 수 있다.
- **짧은 CPU 버스트가 많이 있으며, 긴 CPU 버스트는 적다.**
    - I/O 중심의 프로그램 : 짧은 CPU 버스트를 많이 가짐
    - CPU 지향 프로그램 : 다수의 긴 CPU 버스트를 가짐

<br/>

<br/>

## CPU 스케줄러

- CPU가 유휴 상태가 될 때마다, OS는 준비 큐의 프로세스 중 하나를 선택해 실행한다.
    - 이 선택은 **CPU 스케줄러**에 의해 수행된다.
    - ***이때, 준비 큐는 반드시 FIFO 방식의 큐가 아니어도 되는 것에 유의하자!***

<br/>

<br/>

## 선점 및 비선점 스케줄링

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/process-state.png" width = 600/>


CPU 스케줄링 결정은 다음의 네 가지 상황에서 발생할 수 있다.

1. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (`running → waiting`) : **비선점**
    
    → ex) I/O 요청을 대기해야 할 때
    
2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 (`running → ready`) : **선점**
    
    → ex) 인터럽트가 발생할 때
    
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 (`waiting → ready`) : **선점**
    
    → ex) I/O 작업 완료 시
    
4. 프로세스가 종료할 때 (`running → terminated`) : **비선점**

<br/>

<br/>

> 비선점 스케줄링
> 
- 아래의 두 경우, CPU를 점유한다
    - CPU가 한 프로세스에 할당되면 프로세스가 종료하든지 (위 상황에서 4번)
    - 또는 대기 상태로 전환해 CPU를 방출하든지! (위 상황에서 1번)

<br/>

<br/>

> 선점 스케줄링
> 
- 데이터가 다수의 프로세스에 의해 공유될 때 **경쟁 조건을 초래**할 수 있다.
- 운영체제 커널 설계에 영향을 줄 수 있다.
    - 시스템 콜을 처리할 동안, 중요한 커널 자료가 변경될 경우 커널이 프로세스를 선점!
    - 단, 이러한 기능을 지원하려면 설계가 복잡해지지만, 비선점 커널은 좋은 모델은 아니다.

<br/>

<br/>

### 디스패처

CPU 스케줄링 기능에 포함된 또 하나의 요소는 **디스패처(dispatcher)**이다.

<br/>

> 디스패처란?
> 
- CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에게 주는 모듈
- 아래의 작업들을 포함한다.
    - 프로세스 사이에서의 문맥 교환
    - 사용자 모드로 전환
    - 프로그램을 다시 시작하기 위해 적절한 위치로 이동(jump)

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/dispatch-latency.png" width = 600/>


- 디스패치 지연(`dispatch latency`)란?
    - 디스패처가 하나의 프로세스를 정지하고, 다른 프로세스의 수행을 시작하는데 까지 걸린 시간
    - ***디스패처는 모든 프로세스의 문맥 교환시 호출된다. → 속도가 생명!***
    - 이때, 중요한 건 “문맥 교환이 얼마나 자주 발생하는가?” 이다.

<br/>

<br/>

- Linux에서 제공하는 문맥 교환 횟수를 얻는 명령어 
    ```bash
    $ vmstat 1 3 #1초 지연 단위로 3줄의 출력을 제공!
    ```
    

<br/>

<br/>

- 특정 프로세스에 대한 문맥 교환 횟수를 결정하기
    
    ```bash
    $ cat /proc/2166/status #pid = 2166인 프로세스에 대한 통계를 보기
    
    # 정상 출력 결과
    # voluntary_ctxt_switches 150
    # nonvoluntary_ctxt_switches 8
    ```
    
    
    - 위 결과에서 **자발적 문맥 교환과 비자발적 문맥 교환**의 차이점에 주목하자!
    - ***자발적*** 문맥 교환
        - 현재 사용 불가능한 자원을 요청하여 프로세스가 CPU 제어를 포기한 경우
    - ***비자발적*** 문맥 교환
        - 타임 슬라이스가 만료되었거나 다른 프로세스에게 CPU를 빼았겼을 경우


<br/>

<br/>


# 파일 시스템 구현
## 💡 파일 시스템 구조 _File-System Structure

파일 시스템을 유지하기 위한 보조저장장치로 대부분 디스크가 사용되는데, 아래 두 특성이 있기 때문이다.

1. 디스크는 추가 장소를 사용하지 않고 재기록이 가능하다.
2. 디스크에 있는 임의의 블록의 정보를 직접 접근할 수 있다.

<br/>

<br/>

> ***파일 시스템**은 쉽게 데이터를 저장하고, 인출할 수  있게 함으로써 저장장치를 효율적으로 사용하게 한다.*
> 

단, 파일 시스템은 크게 두 가지의 설계 문제를 제기한다.

1. 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의한다.
2. 논리 파일 시스템을 물리적인 2차 저장장치로 사상하는 알고리즘과 데이터 구조를 만드는 것이다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-1.png" width = 500/>

> *파일 시스템은 여러 층으로 이루어져 있다.*
> 
- **입/출력 제어 층**
    - 장치 드라이버 루틴들과 인터럽트 핸들러로 이루어져, 메모리와 디스크 간의 정보 전송을 담당한다.
- **기본 파일 시스템**
    - 장치 드라이버에게 저장장치 상의 블록을 읽고 쓰도록 일반적인 명령을 내리는 층이다.
    - 이 층은 또한 다양한 파일 시스템, 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시를 관리한다.
- **파일-구성 모듈**
    - 파일과 상응하는 논리 블록을 알고 있는 층
    - 이 모듈은 어느 디스크 공간이 비어있는 지를 파악하는 가용 공간 관리자도 포함한다.
- **논리 파일 시스템**
    - 메타데이터 정보를 관리한다.
    - 메타데이터란? → 파일의 내용 자체인 데이터를 제외한 모든 파일 시스템 구조를 말한다.

<br/>

<br/>

> *파일 시스템 구현을 위해 계층 구조를 사용함으로써, 코드의 중복이 최소화되었다.*
> 
- 다수의 파일 시스템에 의해 I/O 제어와 때로는 기본 파일 시스템 코드가 사용될 수 있다.
- 그 경우 각 파일 시스템은 자신의 논리 파일 시스템과 파일 구조 모듈을 가지고 있다.


<br/>

<br/>

# 💡 파일 시스템 구현 _File-System Implementation

## 개요

> *파일 시스템은 저장장치에 저장된 운영체제를 어떻게 부트시키는지, 디렉터리의 구조 등등의 정보를 디스크 상에 가지고 있다. 이 디스크의 구조는 다음을 포함한다.*
> 
- **부트 제어 블록**
    - 시스템이 그 파티션으로부터 운영체제를 부트시키는 데 필요한 정보를 가진다.
    - UFS에서는 **부트 블록**, NTFS에서는 **파티션 부트 섹터**라 불린다.
- **볼륨 제어 블록**
    - 볼륨의 블록의 수, 블록의 크기, 가용 블록의 수와 포인터, 그리고 가용 FCB 수와 포인터 같은 볼륨 정보를 포함한다.
    - UFS에서는 **슈퍼 블록**, NTFS에서는 **마스터 파일 테이블**이라 불린다.

<br/>

<br/>

> *메모리 내의 정보는 파일 시스템 관리와 캐싱을 통한 성능 향상을 위해 사용된다.
이 정보들은 마운트 시점에 적재되고, 파일 시스템 동작 중에 갱신되며, 마운트 해제 시에 제거된다!
다수의 자료구조 유형이 이 안에 포함된다.*
> 
- 메모리 내 **파티션 테이블**은 마운트된 모든 파티션 정보를 포함한다.
- 메모리 내 디렉토리 구조는 최근 접근된 디렉터리의 정보를 가진다.
- **범 시스템 오픈 파일 테이블**은 다른 정보와 더불어 오픈된 각 파일의 FCB의 복사본을 가진다.
- **프로세스별 오픈 파일 테이블**은 프로세스가 연 모든 파일에 대해 다른 정보뿐만 아니라 범 시스템 오픈 파일 테이블 내의 해당 항목에 대한 포인터를 포함한다.

<br/>

<br/>

## 사용법

- 파일 오픈
    
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-2.png" width = 500/>
    
- 파일 읽기
    
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-3.png" width = 500/>


<br/>

<br/>

# 💡 디렉터리 구현 _Directory Implementation

## 선형 리스트

> *가장 간단한 방법으로, 파일 이름과 데이터 블록에 대한 포인터들의 선형 리스트를 디렉터리에 사용!*
> 
- 이 방법은 프로그램이 쉽지만, 실행 시간이 길다.
- 새로운 파일을 생성하려면 디렉터리의 끝 부분에 항목을 추가한다.
- 파일을 찾기 위해 선형 탐색을 해야 하므로 비효율적이다!

<br/>

<br/>

## 해시테이블

> *파일 이름을 제시하면 해시로부터 값을 얻어서 그것을 포인터로 활용해 리스트에 직접 접근할 수 있다!*
> 
- 해시의 특성상 성능은 크게 개선된다. → 탐색시간 개선!
- 다만 충돌 문제를 고려해야 하고, 해시 테이블 크기에 의한 제한 문제는 항상 제시된다.


<br/>

<br/>

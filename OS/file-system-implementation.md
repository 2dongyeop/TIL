# 파일 시스템 구현
## 💡 파일 시스템 구조 _File-System Structure

파일 시스템을 유지하기 위한 보조저장장치로 대부분 디스크가 사용되는데, 아래 두 특성이 있기 때문이다.

1. 디스크는 추가 장소를 사용하지 않고 재기록이 가능하다.
2. 디스크에 있는 임의의 블록의 정보를 직접 접근할 수 있다.

<br/>

<br/>

> ***파일 시스템**은 쉽게 데이터를 저장하고, 인출할 수  있게 함으로써 저장장치를 효율적으로 사용하게 한다.*
> 

단, 파일 시스템은 크게 두 가지의 설계 문제를 제기한다.

1. 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의한다.
2. 논리 파일 시스템을 물리적인 2차 저장장치로 사상하는 알고리즘과 데이터 구조를 만드는 것이다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-1.png" width = 500/>

> *파일 시스템은 여러 층으로 이루어져 있다.*
> 
- **입/출력 제어 층**
    - 장치 드라이버 루틴들과 인터럽트 핸들러로 이루어져, 메모리와 디스크 간의 정보 전송을 담당한다.
- **기본 파일 시스템**
    - 장치 드라이버에게 저장장치 상의 블록을 읽고 쓰도록 일반적인 명령을 내리는 층이다.
    - 이 층은 또한 다양한 파일 시스템, 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시를 관리한다.
- **파일-구성 모듈**
    - 파일과 상응하는 논리 블록을 알고 있는 층
    - 이 모듈은 어느 디스크 공간이 비어있는 지를 파악하는 가용 공간 관리자도 포함한다.
- **논리 파일 시스템**
    - 메타데이터 정보를 관리한다.
    - 메타데이터란? → 파일의 내용 자체인 데이터를 제외한 모든 파일 시스템 구조를 말한다.

<br/>

<br/>

> *파일 시스템 구현을 위해 계층 구조를 사용함으로써, 코드의 중복이 최소화되었다.*
> 
- 다수의 파일 시스템에 의해 I/O 제어와 때로는 기본 파일 시스템 코드가 사용될 수 있다.
- 그 경우 각 파일 시스템은 자신의 논리 파일 시스템과 파일 구조 모듈을 가지고 있다.


<br/>

<br/>

# 💡 파일 시스템 구현 _File-System Implementation

## 개요

> *파일 시스템은 저장장치에 저장된 운영체제를 어떻게 부트시키는지, 디렉터리의 구조 등등의 정보를 디스크 상에 가지고 있다. 이 디스크의 구조는 다음을 포함한다.*
> 
- **부트 제어 블록**
    - 시스템이 그 파티션으로부터 운영체제를 부트시키는 데 필요한 정보를 가진다.
    - UFS에서는 **부트 블록**, NTFS에서는 **파티션 부트 섹터**라 불린다.
- **볼륨 제어 블록**
    - 볼륨의 블록의 수, 블록의 크기, 가용 블록의 수와 포인터, 그리고 가용 FCB 수와 포인터 같은 볼륨 정보를 포함한다.
    - UFS에서는 **슈퍼 블록**, NTFS에서는 **마스터 파일 테이블**이라 불린다.

<br/>

<br/>

> *메모리 내의 정보는 파일 시스템 관리와 캐싱을 통한 성능 향상을 위해 사용된다.
이 정보들은 마운트 시점에 적재되고, 파일 시스템 동작 중에 갱신되며, 마운트 해제 시에 제거된다!
다수의 자료구조 유형이 이 안에 포함된다.*
> 
- 메모리 내 **파티션 테이블**은 마운트된 모든 파티션 정보를 포함한다.
- 메모리 내 디렉토리 구조는 최근 접근된 디렉터리의 정보를 가진다.
- **범 시스템 오픈 파일 테이블**은 다른 정보와 더불어 오픈된 각 파일의 FCB의 복사본을 가진다.
- **프로세스별 오픈 파일 테이블**은 프로세스가 연 모든 파일에 대해 다른 정보뿐만 아니라 범 시스템 오픈 파일 테이블 내의 해당 항목에 대한 포인터를 포함한다.

<br/>

<br/>

## 사용법

- 파일 오픈
    
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-2.png" width = 500/>
    
- 파일 읽기
    
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-3.png" width = 500/>


<br/>

<br/>

# 💡 디렉터리 구현 _Directory Implementation

## 선형 리스트

> *가장 간단한 방법으로, 파일 이름과 데이터 블록에 대한 포인터들의 선형 리스트를 디렉터리에 사용!*
> 
- 이 방법은 프로그램이 쉽지만, 실행 시간이 길다.
- 새로운 파일을 생성하려면 디렉터리의 끝 부분에 항목을 추가한다.
- 파일을 찾기 위해 선형 탐색을 해야 하므로 비효율적이다!

<br/>

<br/>

## 해시테이블

> *파일 이름을 제시하면 해시로부터 값을 얻어서 그것을 포인터로 활용해 리스트에 직접 접근할 수 있다!*
> 
- 해시의 특성상 성능은 크게 개선된다. → 탐색시간 개선!
- 다만 충돌 문제를 고려해야 하고, 해시 테이블 크기에 의한 제한 문제는 항상 제시된다.


<br/>

<br/>

# 💡 할당 방법 _Allocation Methods

## 연속 할당

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-4.png" width = 500/>

> ***연속 할당**은 각 파일이 저장장치 내에서 연속적인 공간을 차지하도록 요구한다.*
> 
- 연속된 블록의 이동 시에 헤드의 이동이 필요하지 않다!
- 또한 파일에 접근하기도 쉽다.
- 순차적 접근과 직접 접근 두 가지를 모두 지원한다.

<br/>

<br/>

> 연속 할당 기법의 문제 : **동적 공간 할당 문제**
> 
- 새로운 파일을 위한 가용 공간을 찾아야 한다.
    - → 최초, 최상, 최악 적합 알고리즘을 사용!
- 단편화
    - 파일들이 할당되고 삭제되면서 자유 디스크 공간들이 빈 조각들로 나누어진다.
- 파일이 필요한 공간 확장이 어렵다.
- 공간의 낭비가 심하다.

<br/>

<br/>

## 연결 할당

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-5.png" width = 500/>

> ***연결 할당**은 연속 할당의 모든 문제를 해결한다.*
> 
- 파일은 저장장치 블록의 연결 리스트 형태로 저장되고, 이 블록들은 장치 내에 흩어져 저장될 수 있다.
- 파일을 생성하려면?
    - → 단순히 디렉터리 내에 새로운 항목을 생성

<br/>

<br/>

> *연결 할당의 단점*
> 
- 순차적 접근 파일에만 효과적이다!
    - → 직접 접근 기능을 지원할 수 없다.
- 포인터들을 위한 공간이 필요하다.
    - → 블록을 모아 클러스터라고 하는 단위로 만들고, 블록이 아닌 클러스터로 할당하자!
- 신뢰성 문제가 발생할 수 있다.
    - → 포인터를 잃어버리거나, 잘못된 포인터 값을 가지게 되면 결국 모든 데이터를 잃는다.

<br/>

<br/>

> *연결 할당의 변형 : **파일 할당 테이블(FAT)** 사용*
> 
- MS-DOS에서 사용
    
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-6.png" width = 500/>
    

<br/>

<br/>


## 색인 할당

> *모든 포인터들을 하나의 장소인 색인 블록으로 관리함으로써 연결 할당의 문제를 해결한 방식이다.*
> 
- 직접 접근이 가능하다!
- 공간의 낭비가 심하다.
    - → 색인 블록의 포인터 부담
- 커다란 파일을 표현할 수 없다.
    - 해결 방법들
        1. 연결 기법
        2. 다중 단계 색인
        3. 결합 기법 → UNIX에서 사용

<br/>

<br/>

### 연결 기법

> *하나의 색인 블록은 통상 한 저장장치 블록이다. → 여러 개의 색인 블록을 연결!*
> 

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-7.png" width = 500/>

<br/>

<br/>

### 다중 단계 색인

> *분리된 색인 블록들을 사용해 다른 색인 블록에 연결하는 방식이다.*
> 

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-8.png" width = 500/>

<br/>

<br/>

### 결합 기법

> *UNIX에서 사용하는 기법으로, 직접 블록과 간접 블록을 혼합해 사용하는 기법이다.*
> 

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-9.png" width = 500/>


<br/>

<br/>

# 💡 가용 공간의 관리 _Free-Space Management

저장장치 공간은 제한되어 있어, 삭제된 파일들이 차지하던 공간을 다시 재사용하여야 한다.

시스템은 이러한 가용 공간을 리스트로 유지하고 관리한다. → **가용 공간 리스트**

⇒ 가용 공간 리스트는 그 명칭과 달리 반드시 리스트 형태로만 구현될 필요는 없음을 알아두자!

<br/>

<br/>

## 비트 벡터

> *가용 공간 리스트는 흔히 비트맵, 또는 비트 벡터로서 구현된다.*
> 

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-10.png" width = 500/>

<br/>

<br/>

*여기서 각 블록은 1비트로 표현된다.*

- *블록이 비어 있으면 1, 블록이 할당되었으면 0이다.*

이 방식의 장점은, 연속된 가용 블록들을 찾는 일이 상대적으로 간편하고 효율적이라는 점이다!

<br/>

<br/>

## 연결 리스트

> 모든 가용 블록들을 함께 연결하는 방식이다.
> 
- 첫번째 자유 블록은 다음 자유 블록을 가리키는 포인터를 가진다.
- 리스트를 순회하려면 매번 다시 디스크를 접근해야 한다. → 굉장히 비효율적!

<br/>

<br/>

- 동작 그림
    
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/14-11.png" width = 500/>
    
<br/>

<br/>


### 그룹핑

> *자유 리스트 방식의 변형이다.*
> 

첫 번째 자유 블록 내에 n개의 자유 블록들의 번지를 저장한다.

- 이때 처음 n-1은 실제로 빈 것이고,
- 마지막 1개는 다른 n개의 자유 블록들의 주소를 포함하고 있는 다른 블록의 디스크 주소다.

<br/>

<br/>

### 계수

> *연속된 블록들이 동시에 할당되거나 해제되는 이점을 이용한 방식이다.*
> 
- 첫번째 자유 블록의 주소와 그 첫번째 블록에 연속된 자유 블록들의 개수를 보존한다.


<br/>

<br/>

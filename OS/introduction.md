# chapter 1. 서론

<br/>

#### 운영체제(`operating system`)란?
- 컴퓨터 하드웨어를 관리하는 소프트웨어이다.
- 응용 프로그램을 위한 기반을 제공한다.
- 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다.

<br/>

#### **운영체제의 놀라운 점?**
- 광범위한 컴퓨팅 환경에서 여러 일들을 매우 다양한 방법으로 수행한다.
- 운영체제는 “*사물 인터넷(IoT)*”부터 클라우드 컴퓨팅 환경까지 어느 곳에나 존재한다.

<br/>

#### **운영체제의 역할을 탐구하려면? → 먼저 컴퓨터 하드웨어의 구성과 구조를 이해하는 것이 중요하다.**
- 운영체제의 근본적인 책임은 자원들을 프로그램에 할당하는 것이다.
- 구성과 구조 : CPU, 메모리 및 입출력 장치와 저장장치 등등..

<br/>


#### **운영체제는 덩치가 매우 크고 복잡하므로 부분으로 나눈다.**
- 이 하나의 부분은 전체 시스템 윤곽에 잘 맞는 일부여야 한다.
- 이 부분들의 입력과 출력, 동작은 주의를 기울여 정의해야 한다.

<br/>


### 💡 ***이 장의 목표***
- *컴퓨터 시스템의 일반적인 구성과 인터럽트의 역할을 기술한다.*
- *현대 다중 처리기 컴퓨터 시스템의 구성요소에 관해 기술한다.*
- *사용자 모드에서 커널 모드로의 전환에 대해 설명한다.*

<br/>


<br/>


<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/computer-components.png" width = 500/>
→ 컴퓨터 시스템 구성요소에 대한 개략적 구성도 : 대개 위처럼 네 가지 구성요소로 나뉨.

<br/>

## 💡 운영체제가 할 일

- 하드웨어
    - 중앙 처리 장치(CPU), 메모리 및 입출력(I/O) 장치로 구성되어, 기본 계산용 자원을 제공
- 응용 프로그램
    - 계산 문제를 해결하기 위해 자원이 어떻게 사용될지를 정의
    - ex) 컴파일러, 웹 브라우저, 워드 프로세서 등등..
- **운영체제**
    - 다양한 사용자를 위해 다양한 **응용 프로그램 간의 하드웨어 사용을 제어하고 조정**

<br/>

- 또한 컴퓨터 시스템이 HW, SW 및 데이터로 구성되어 있다고 볼 수 있다.
    - 운영체제는 컴퓨터 시스템이 동작할 때 이들 자원을 적절하게 사용할 수 있는 방법을 제공!
        - 정부와 유사하게 그 자체로는 유용한 기능을 수행하지 못하지만, **환경을 제공**한다.

<br/>

→ 운영체제의 역할을 사용자 관점과 시스템 관점으로 살펴보자.

<br/>

### 사용자 관점
- 사용자 관점은 사용되는 인터페이스에 따라 달라진다.

<br/>

- 랩톱 혹은 모니터, 키보드, 마우스로 구성된 PC
    - 한 사용자가 **자원을 독점하도록 설계**되어, **사용자가 수행하는 작업을 최대화하는 것이 목표**
    - 이 경우, 운영체제는 **사용의 용이성**을 위해 설계되고, **자원의 이용**에는 전혀 신경을 쓰지 않는다.

<br/>

- 모바일 장치(스마트폰 및 태블릿)
    - 일반적으로 셀룰러 또는 기타 무선 기술을 통해 네트워크에 연결된다.
    - 키보드와 마우스를 사용하지 않음 → **터치스크린 + 음성 인식**

<br/>
    
- 일부 컴퓨터는 사용자 관점이 존재하지 않거나 매우 작은 예도 있다.
    - ex) 가전제품이나 자동차 내의 내장형 컴퓨터

<br/>

### 시스템 관점
- 컴퓨터의 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다.
    - 따라서 운영체제를 **자원 할당자**로 볼 수 있다.
    - 자원 할당자 : 문제를 해결하기 위해 요구되는 여러 자원들을 관리
    - 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 할당할 지 결정해야 함

<br/>

- 다소 다른 관점은 여러 가지 입출력 **장치**와 사용자 **프로그램을 제어할 필요성을 강조**한다.
    - 이러한 시점에서는 운영체제는 **제어 프로그램**이다.
    - 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어한다.

<br/>

### 운영체제의 정의

<br/>

#### **컴퓨터의 역사**
1. 컴퓨팅은 처음엔 무엇을 할 수 있을지 알기 위한 실험으로 시작
2. 추후 고정 목적 시스템으로 전용되었다.
3. 초기의 컴퓨터들이 범용의 다기능 대형컴퓨터로 발전 → 운영체제 탄생

<br/>

> 무어의 법칙(`Moore’s Law`)
>
> → 직접회로의 트랜지스터 수가 18개월마다 배가할 것이라고 예측.


<br/>

#### **그래서 운영체제의 정의가 뭔데?**
- 일반적으로 적합한 정의는 없다!
- 다만, 문제를 해결할 수 있는 합리적인 방법을 제공하기 때문에 존재한다.
- 이는 컴퓨터 시스템의 기본 목표에 적합하다.

<br/>
 
#### **또한 운영체제에 포함되는 요소도 보편적인 정의는 없다.**
- 다만, 우리가 지지하는 것은 **운영체제는 컴퓨터에서 항상 실행되는 프로그램(= 커널)**이다.
- 커널 이외에는 두 가지 프로그램이 더 있다.
    - 시스템 프로그램 : 운영체제와 반드시 관련되어 있지만 반드시 커널의 일부는 아니다.
    - 응용 프로그램 : 시스템 작동과 관련되지 않은 모든 프로그램을 포함

<br/>

#### **운영체제는 종종 핵심 커널뿐만 아니라 “미들웨어”도 포함된다.**

<br/>

#### 💡 **요약**
- 운영체제에는 아래 프로그램들이 포함된다.
  - 항상 실행중인 커널
  - 응용 프로그램 개발을 쉽게 하고 기능을 제공하는 미들웨어 프레임워크
  - 시스템 실행 중에 시스템을 관리하는 데 도움이 되는 프로그램*

<br/>

### 💡 **운영체제는 왜 공부해야 하는가?**
- 모든 코드는 운영체제 위에서 실행되므로, 작동방식에 대한 지식을 효율적이고 효과적이다!
- 프로그램에 제공하는 내용을 이해하는 것은 코드를 작성하는 사람들에게도 매우 유용하다.*

<br/>

<br/>
 
## 💡 컴퓨터 시스템의 구성

- 현대의 범용 컴퓨터 시스템은 공통 **버스**를 통해 연결된 여러 장치 컨트롤러로 구성된다.
    - 이 버스는 하나 이상의 CPU와 구성요소와 공유 메모리 사이의 액세스를 제공한다.

<br/>
 
- 각 장치 컨트롤러는 특정 유형의 장치를 담당한다.
    - 또한 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합을 유지 관리한다.
    - 제어하는 주변 장치와 로컬 버퍼 저장소 간에 데이터를 이동한다.

<br/>
 
- 일반적으로 각 장치 컨트롤러마다 **장치 드라이버**가 있다.
    - 장치 드라이버는 장치 컨트롤러의 동작을 잘 알고, 운영체제 장치에 대한 일관된 인터페이스를 제공

<br/>
 
- CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다.
    - 공유 메모리를 질서있게 액세스하기 위해 메로리 컨트롤러는 메모리에 대한 액세스를 동기화한다.

<br/>
 
### 인터럽트

일반적인 입출력 수행 프로그램 동작 방식은 아래와 같다.
1. 입출력 작업을 시작하기 위해 장치 드라이버는 자이 컨트롤러의 적합한 레지스터에 값을 적재
2. 장치 컨트롤러는 값을 검사하고 수행할 작업을 결정
3. 컨트롤러는 데이터 전송을 시작 (장치 → 로컬 버퍼)
4. 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료됨을 **알림**
5. 장치 드라이버는 읽기 요청시 데이터에 대한 포인터를 반환

<br/>
 
> → 작업을 완료했다는 사실을 어떻게 알릴까? : 인터럽트!

<br/>
 
### **개요**
- 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 **인터럽트를 발생**시킬 수 있다.
- 인터럽트는 다른 많은 목적으로도 사용되며 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.

<br/>
 
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/interrupt-timeline.png" width = 500/>

- 인터럽트 동작 방식
    1. CPU가 인터럽드되면, 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다.
        - 고정된 위치는 인터럽트를 위한 서비스 루틴이 시작 주소를 가지고 있다.
    2. 인터럽트 서비스 루틴의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 재개한다.

<br/>
 
- 인터럽트는 컴퓨터 구조의 중요한 부분이다.
    - 각 컴퓨터 설계는 자신의 인터럽트 메커니즘을 가지고 있으며, 몇 가지 기능은 공통적이다.
    - 인터럽트는 적절한 서비스 루틴으로 제어를 전달한다.

<br/>
 
- 전달을 관리하는 직선적인 방법
    1. 인터럽트 정보를 조사하는 일반적인 루틴을 호출하기
    2. 이어서 인터럽트 고유의 핸들러를 호출한다. 
        - 인터럽트는 매우 빈번하게 발생하기 때문에 빠르게 처리되어야 한다.
    3. 필요한 속도를 제공하기 위해 인터럽트 루틴에 대한 포인터들의 테이블을 대신 이용할 수도 있다.
        - 이 경우 중간 루틴을 둘 필요 없이, 테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다.

<br/>
 
- 인터럽트가 요청 생기는 내부 과정
    - 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열,
    - 즉 **인터럽트 벡터**가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.

<br/>
 
- 인터럽트 구조
    - 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다.
    - 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요가 있다면?
        
        → 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하고, 복귀하기 전 상태를 복원해야 한다!
        

### **구현**

- 기본 인터럽트 메커니즘은 아래와 같이 동작한다.
    1. CPU는 하나의 명령어의 실행을 완료할 때마다 **인터럽트 요청 라인을 감지**한다.
    2. CPU가 컨트롤러가 인터럽트 요청 라인에 신호를 보냄을 감지하면?

        → 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용: **인터럽트 핸들러 루틴**으로 점프
    3. 해당 인덱스와 관련된 주소에서 실행을 시작한다.

<br/>
 
- 인터럽트 처리기
    - 작업 중에 변경될 상태를 저장하고, 인터럽트 원인을 확인한 뒤 필요한 처리를 수행한다.
    - 상태 복원을 수행하고, `return_from_interrupt` 명령어로 CPU를 인터럽트 전 상태로 되돌린다.

<br/>
 
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/interrupt-driven-cycle.png" width = 500/>

<br/>
 
최신 운영체제에서는 더욱 정교한 인터럽트 처리 기능이 필요하다. → **인터럽트 컨트롤러 하드웨어**가 제공 
1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
3. 운영체제가 인터럽트의 우선순위를 구분하고 적절한 긴급도로 대응할 수 있어야 한다.

<br/>
 
- 대부분의 CPU에는 2개의 인터럽트 요청 라인이 존재한다.
    - 마스크 불가능 인터럽트(`nonmaskable interrupt`)
        - 복구할 수 없는 메모리 오류와 같은 이벤트를 위해 예약됨
    - 마스크 가능(`maskable`)
        - 장치 컨트롤러가 서비스를 요청하기 위해 사용

<br/>
 
- 벡터 방식 인터럽트 기법의 목적
    - 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이기 위함! → 해결법 :  **인터럽트 체인을 사용**하기

<br/>
 
- 동작 방식
    - 인터럽트 벡터의 각 요소는 인터럽트 핸들러 리스트의 헤드를 가리킨다.
    - 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다.
    - 이러한 구조는 큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치하는 비효율성의 절충안이다.

<br/>
 
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/event-vector-table.png" width = 500/>

- 마스크 불가능한 0 ~ 31까지의 이벤트는 다양한 오류 조건을 알리는 데 사용된다.
- 마스크 가능한 32 ~ 255까지의 이벤트는 장치가 생성한 인터럽트 같은 그 외 인터럽트를 처리한다.

<br/>
 
- 인터럽트 기법은 또한 인터럽트 **우선순위 레벨(interrupt priority level)을 구현**한다!
    - 이 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위를 판단해 동작한다.

<br/>
 
> ### *요약*
> - 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 뤼해 사용된다.
> - 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생한다.
> - 가장긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 인터럽트 우선순위 시스템을 사용한다.
> - 인터럽트는 시간에 민감한 처리에 빈번하게 사용된다.
> 
>   → 시스템 성능을 좋게하려면 효율적인 인터럽트 처리가 필요하다.*

<br/>
 
### 저장장치 구조

- CPU는 메모리에서만 명령을 적재할 수 있다.
  - 실행하려면 프로그램을 먼저 메모리에 적재해야 한다.
    
<br/>
 
- 범용 컴퓨터는 프로그램 대부분을 메인 메모리(**RAM**)라 불리는 재기록 가능한 메모리에서 가져온다.
    - 메인 메모리는 DRAM(Dynamic RAM)라 불리는 반도체 기술로 구현된다.

<br/>
 
- 컴퓨터는 다른 형태의 메모리도 사용된다.
    - ex) **부트스트랩 프로그램**은 전원을 키면 가장 먼저 실행되고, 운영체제를 적재한다.
        - RAM은 **휘발성**이므로 부트스트랩 프로그램에 적합하지 않다!
    - 대신 다른 목적으로, 전기적으로 소거 가능한 프로그램 가능 읽기 전용 메모리(EEPROM) 및 기타 형태의 **펌웨어**(쓰기 작업이 자주 발생하지 않고 비휘발성인 저장장치)를 사용한다.
        - EEPROM은 변경할 수는 있지만 자주 변경할 수는 없다!

<br/>
 
- 모든 형태의 메모리는 바이트의 배열을 제공한다.
    - 각 바이트는 자신의 주소를 가지고 있다.
    - 상호 작용은 특정 메모리 주소들에 대한 **적재(load)**, 또는 **저장(store)** 명령을 통해 이루어진다.
        - 적재 : 메인 메모리로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것.
        - 저장 : 레지스터의 내용을 메인 메모리로 옮기는 것.

<br/>
 
- **폰 노이만 구조 시스템**에서 실행되는 전형적인 `명령 - 실행` 사이클
    1. 메모리로부터 명령을 인출하고, 그 명령을 **명령 레지스터**에 저장한다.
    2. 명령을 해독하고, 이는 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발한다.
    3. 피연산자에 대해 명령을 실행한 후 결과가 메모리에 다시 저장된다.
        

<br/>


> ***→ 이때, 메모리 장치는 단지 일련의 메모리 주소만을 인식한다는 사실에 유의하자!***
> 
> → 메모리는 이들의 주소(명령 카운터, 색인, 간접 주소 등등..)가 어떻게 생성되었는지 알지 못한다.
>
> → 또한 그것이 무엇인지(명령인지 데이터인지)도 알지 못한다!
>
> → 그러므로 우리는 메모리 주소가 프로그램에 의해 ***어떻게*** 생성되었는지 무시할 수 있다.
> 
> : 우리는 단지 실행 중인 프로그램에 의해 생성된 일련의 메모리 주소에만 흥미가 있다.

<br/>
 
- 이상적으로는, 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다.
    - 단, 이는 대부분의 시스템에서 두 가지 이유로 불가능하다.
        1. 메인 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.
        2. 메인 메모리는 이미 언급한 것처럼 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성이다.

<br/>
 
- 그러므로 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 **보조저장장치**를 제공한다.
    - 주요 요건은 대량의 데이터를 영구히 보존할 수 있어야 한다는 점이다.
    - 가장 일반적인 보조저장장치는 **하드 디스크 드라이브(HDD)와 비휘발성 메모리(NVM) 장치**이다.

<br/>
 
- 대부분의 프로그램은 메모리에 적재될 때까지 보조저장장치에 저장된다.
    - 따라서 많은 프로그램이 보조저장장치를 처리 소스 및 대상으로 모두 사용한다.

<br/>
 
- **3차 저장장치**
    - 다른 장치에 저장된 자료의 백업 사본을 저장하기 위해 특수 목적으로만 사용하기에 매우 느리고 충분히 큰 장치를 말한다.

<br/>
 
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/storage-device-hierarchy.png" width = 500/>

저장장치 계층 구조
- 다양한 저장장치 시스템은 저장 용량 및 액세스 시간에 따라 계층 구조로 구성될 수 있다.
    - 일반적으로 크기와 속도 사이에는 상충하는 측면이 있어 메모리가 작고 빠를수록 CPU에 더 가깝다!

<br/>
 
- 그림에서 최상위 4단계 메모리는 반도체 기반 전자회로로 구성된 **반도체 메모리**를 사용하여 구성된다.
    - 네 번째 수준의 NVM 장치에는 여러 가지 변형이 있지만 일반적으로 하드 디스크보다 빠르다.

<br/>
 
> 🌱 *저장장치는 운영체제 구조에서 중요한 역할을 하므로 자주 참조된다. 아래 용어를 기억하자.*
>
> - 휘발성 저장장치를 단순히 **메모리**라고 표현할 것이다.
> - 비휘발성 저장장치를 **NVS**라고 표현할 것이고, 이는 두 가지 유형으로 분류된다.
>    - **기계적** : ex) HDD, 광 디스크, 홀로그램 저장장치
>    - **전기적** : ex) 플래시 메모리, FRAM, NRAM 및 SSD → **NVM**
>
>  → 기계적 저장장치는 일반적으로 전기적 저장장치보다 용량이 크고 바이트당 비용이 저렴하다.
>
>  → 반대로 전기적 저장 장치는 일반적으로 기계적 저장장치보다 비싸고 용량이 적으며 빠르다.


<br/>
 
### 입출력 구조

- 운영체제 코드의 상당 부분은 아래 내용으로 인해 I/O 관리에 할애된다.
  - 시스템의 안정성
  - 성능에 대한 중요성
  - 장치의 다양한 특성

<br/>
 
- 앞에서 설명한 인터럽트 구동 I/O 형태는 소량의 데이터를 이동하는 데는 좋다!
    - 하지만 NVS I/O 와 같은 대량 데이터 이동에 사용될 때는 높은 오버헤드를 유발한다.
    - 이 문제를 해결하기 위해 **직접 메모리 액세스(DMA)**가 사용된다.

<br/>
 
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/modern-computer-works.png" width = 500/>

- DMA 동작 방식
    - 장치에 대한 버퍼 및 포인터, 입출력 카운터를 세팅한 후 장치 제어기는 CPU의 개입 없이 [메모리로부터 자신의 버퍼 장치로] 또는 [버퍼로부터 메모리로] 데이터 블록 정체를 전송한다.
    - 속도가 느린 장치와 달리 블록 전송이 완료될 때마다 인터럽트가 발생한다.

<br/>
 
- 몇몇 고가의 시스템은 버스 대신에 스위치 구조를 사용한다.
    - 공용 버스를 사용하기 위한 사이클을 경쟁하지 않고 다수의 구성요소가 동시에 통신이 가능하다.
    - 이 경우 DMA의 사용은 더욱 효과적이다!

<br/>
 
<br/>
 
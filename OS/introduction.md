# chapter 1. 서론

<br/>

#### 운영체제(`operating system`)란?
- 컴퓨터 하드웨어를 관리하는 소프트웨어이다.
- 응용 프로그램을 위한 기반을 제공한다.
- 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다.


<br/>

<br/>

#### **운영체제의 놀라운 점?**
- 광범위한 컴퓨팅 환경에서 여러 일들을 매우 다양한 방법으로 수행한다.
- 운영체제는 “*사물 인터넷(IoT)*”부터 클라우드 컴퓨팅 환경까지 어느 곳에나 존재한다.


<br/>

<br/>

#### **운영체제의 역할을 탐구하려면? → 먼저 컴퓨터 하드웨어의 구성과 구조를 이해하는 것이 중요하다.**
- 운영체제의 근본적인 책임은 자원들을 프로그램에 할당하는 것이다.
- 구성과 구조 : CPU, 메모리 및 입출력 장치와 저장장치 등등..


<br/>

<br/>


#### **운영체제는 덩치가 매우 크고 복잡하므로 부분으로 나눈다.**
- 이 하나의 부분은 전체 시스템 윤곽에 잘 맞는 일부여야 한다.
- 이 부분들의 입력과 출력, 동작은 주의를 기울여 정의해야 한다.

<br/>


### 💡 ***이 장의 목표***
- *컴퓨터 시스템의 일반적인 구성과 인터럽트의 역할을 기술한다.*
- *현대 다중 처리기 컴퓨터 시스템의 구성요소에 관해 기술한다.*
- *사용자 모드에서 커널 모드로의 전환에 대해 설명한다.*

<br/>


<br/>


<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/computer-components.png" width = 500/>
→ 컴퓨터 시스템 구성요소에 대한 개략적 구성도 : 대개 위처럼 네 가지 구성요소로 나뉨.


<br/>

<br/>

## 💡 운영체제가 할 일

- 하드웨어
    - 중앙 처리 장치(CPU), 메모리 및 입출력(I/O) 장치로 구성되어, 기본 계산용 자원을 제공
- 응용 프로그램
    - 계산 문제를 해결하기 위해 자원이 어떻게 사용될지를 정의
    - ex) 컴파일러, 웹 브라우저, 워드 프로세서 등등..
- **운영체제**
    - 다양한 사용자를 위해 다양한 **응용 프로그램 간의 하드웨어 사용을 제어하고 조정**


<br/>

<br/>

- 또한 컴퓨터 시스템이 HW, SW 및 데이터로 구성되어 있다고 볼 수 있다.
    - 운영체제는 컴퓨터 시스템이 동작할 때 이들 자원을 적절하게 사용할 수 있는 방법을 제공!
        - 정부와 유사하게 그 자체로는 유용한 기능을 수행하지 못하지만, **환경을 제공**한다.


<br/>

<br/>

→ 운영체제의 역할을 사용자 관점과 시스템 관점으로 살펴보자.


<br/>

<br/>

### 사용자 관점
- 사용자 관점은 사용되는 인터페이스에 따라 달라진다.


<br/>

<br/>

- 랩톱 혹은 모니터, 키보드, 마우스로 구성된 PC
    - 한 사용자가 **자원을 독점하도록 설계**되어, **사용자가 수행하는 작업을 최대화하는 것이 목표**
    - 이 경우, 운영체제는 **사용의 용이성**을 위해 설계되고, **자원의 이용**에는 전혀 신경을 쓰지 않는다.


<br/>

<br/>

- 모바일 장치(스마트폰 및 태블릿)
    - 일반적으로 셀룰러 또는 기타 무선 기술을 통해 네트워크에 연결된다.
    - 키보드와 마우스를 사용하지 않음 → **터치스크린 + 음성 인식**


<br/>

<br/>
    
- 일부 컴퓨터는 사용자 관점이 존재하지 않거나 매우 작은 예도 있다.
    - ex) 가전제품이나 자동차 내의 내장형 컴퓨터


<br/>

<br/>

### 시스템 관점
- 컴퓨터의 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다.
    - 따라서 운영체제를 **자원 할당자**로 볼 수 있다.
    - 자원 할당자 : 문제를 해결하기 위해 요구되는 여러 자원들을 관리
    - 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 할당할 지 결정해야 함


<br/>

<br/>

- 다소 다른 관점은 여러 가지 입출력 **장치**와 사용자 **프로그램을 제어할 필요성을 강조**한다.
    - 이러한 시점에서는 운영체제는 **제어 프로그램**이다.
    - 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어한다.


<br/>

<br/>

### 운영체제의 정의

<br/>

#### **컴퓨터의 역사**
1. 컴퓨팅은 처음엔 무엇을 할 수 있을지 알기 위한 실험으로 시작
2. 추후 고정 목적 시스템으로 전용되었다.
3. 초기의 컴퓨터들이 범용의 다기능 대형컴퓨터로 발전 → 운영체제 탄생


<br/>

<br/>

> 무어의 법칙(`Moore’s Law`)
>
> → 직접회로의 트랜지스터 수가 18개월마다 배가할 것이라고 예측.



<br/>

<br/>

#### **그래서 운영체제의 정의가 뭔데?**
- 일반적으로 적합한 정의는 없다!
- 다만, 문제를 해결할 수 있는 합리적인 방법을 제공하기 때문에 존재한다.
- 이는 컴퓨터 시스템의 기본 목표에 적합하다.


<br/>

<br/>
 
#### **또한 운영체제에 포함되는 요소도 보편적인 정의는 없다.**
- 다만, 우리가 지지하는 것은 **운영체제는 컴퓨터에서 항상 실행되는 프로그램(= 커널)**이다.
- 커널 이외에는 두 가지 프로그램이 더 있다.
    - 시스템 프로그램 : 운영체제와 반드시 관련되어 있지만 반드시 커널의 일부는 아니다.
    - 응용 프로그램 : 시스템 작동과 관련되지 않은 모든 프로그램을 포함


<br/>

<br/>

#### **운영체제는 종종 핵심 커널뿐만 아니라 “미들웨어”도 포함된다.**


<br/>

<br/>

#### 💡 **요약**
- 운영체제에는 아래 프로그램들이 포함된다.
  - 항상 실행중인 커널
  - 응용 프로그램 개발을 쉽게 하고 기능을 제공하는 미들웨어 프레임워크
  - 시스템 실행 중에 시스템을 관리하는 데 도움이 되는 프로그램*

<br/>

### 💡 **운영체제는 왜 공부해야 하는가?**
- 모든 코드는 운영체제 위에서 실행되므로, 작동방식에 대한 지식을 효율적이고 효과적이다!
- 프로그램에 제공하는 내용을 이해하는 것은 코드를 작성하는 사람들에게도 매우 유용하다.*

<br/>

<br/>
 
## 💡 컴퓨터 시스템의 구성

- 현대의 범용 컴퓨터 시스템은 공통 **버스**를 통해 연결된 여러 장치 컨트롤러로 구성된다.
    - 이 버스는 하나 이상의 CPU와 구성요소와 공유 메모리 사이의 액세스를 제공한다.

<br/>

<br/>

- 각 장치 컨트롤러는 특정 유형의 장치를 담당한다.
    - 또한 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합을 유지 관리한다.
    - 제어하는 주변 장치와 로컬 버퍼 저장소 간에 데이터를 이동한다.

<br/>

<br/>

- 일반적으로 각 장치 컨트롤러마다 **장치 드라이버**가 있다.
    - 장치 드라이버는 장치 컨트롤러의 동작을 잘 알고, 운영체제 장치에 대한 일관된 인터페이스를 제공

<br/>

<br/>

- CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다.
    - 공유 메모리를 질서있게 액세스하기 위해 메로리 컨트롤러는 메모리에 대한 액세스를 동기화한다.

<br/>

<br/>

### 인터럽트

일반적인 입출력 수행 프로그램 동작 방식은 아래와 같다.
1. 입출력 작업을 시작하기 위해 장치 드라이버는 자이 컨트롤러의 적합한 레지스터에 값을 적재
2. 장치 컨트롤러는 값을 검사하고 수행할 작업을 결정
3. 컨트롤러는 데이터 전송을 시작 (장치 → 로컬 버퍼)
4. 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료됨을 **알림**
5. 장치 드라이버는 읽기 요청시 데이터에 대한 포인터를 반환

<br/>

<br/>

> → 작업을 완료했다는 사실을 어떻게 알릴까? : 인터럽트!

<br/>

<br/>

### **개요**
- 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 **인터럽트를 발생**시킬 수 있다.
- 인터럽트는 다른 많은 목적으로도 사용되며 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/interrupt-timeline.png" width = 500/>

- 인터럽트 동작 방식
    1. CPU가 인터럽드되면, 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다.
        - 고정된 위치는 인터럽트를 위한 서비스 루틴이 시작 주소를 가지고 있다.
    2. 인터럽트 서비스 루틴의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 재개한다.

<br/>

<br/>

- 인터럽트는 컴퓨터 구조의 중요한 부분이다.
    - 각 컴퓨터 설계는 자신의 인터럽트 메커니즘을 가지고 있으며, 몇 가지 기능은 공통적이다.
    - 인터럽트는 적절한 서비스 루틴으로 제어를 전달한다.

<br/>

<br/>

- 전달을 관리하는 직선적인 방법
    1. 인터럽트 정보를 조사하는 일반적인 루틴을 호출하기
    2. 이어서 인터럽트 고유의 핸들러를 호출한다. 
        - 인터럽트는 매우 빈번하게 발생하기 때문에 빠르게 처리되어야 한다.
    3. 필요한 속도를 제공하기 위해 인터럽트 루틴에 대한 포인터들의 테이블을 대신 이용할 수도 있다.
        - 이 경우 중간 루틴을 둘 필요 없이, 테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다.

<br/>

<br/>

- 인터럽트가 요청 생기는 내부 과정
    - 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열,
    - 즉 **인터럽트 벡터**가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.

<br/>

<br/>

- 인터럽트 구조
    - 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다.
    - 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요가 있다면?
        
        → 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하고, 복귀하기 전 상태를 복원해야 한다!
        

### **구현**

- 기본 인터럽트 메커니즘은 아래와 같이 동작한다.
    1. CPU는 하나의 명령어의 실행을 완료할 때마다 **인터럽트 요청 라인을 감지**한다.
    2. CPU가 컨트롤러가 인터럽트 요청 라인에 신호를 보냄을 감지하면?

        → 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용: **인터럽트 핸들러 루틴**으로 점프
    3. 해당 인덱스와 관련된 주소에서 실행을 시작한다.

<br/>

<br/>

- 인터럽트 처리기
    - 작업 중에 변경될 상태를 저장하고, 인터럽트 원인을 확인한 뒤 필요한 처리를 수행한다.
    - 상태 복원을 수행하고, `return_from_interrupt` 명령어로 CPU를 인터럽트 전 상태로 되돌린다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/interrupt-driven-cycle.png" width = 500/>

<br/>

<br/>

최신 운영체제에서는 더욱 정교한 인터럽트 처리 기능이 필요하다. → **인터럽트 컨트롤러 하드웨어**가 제공 
1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
3. 운영체제가 인터럽트의 우선순위를 구분하고 적절한 긴급도로 대응할 수 있어야 한다.

<br/>

<br/>

- 대부분의 CPU에는 2개의 인터럽트 요청 라인이 존재한다.
    - 마스크 불가능 인터럽트(`nonmaskable interrupt`)
        - 복구할 수 없는 메모리 오류와 같은 이벤트를 위해 예약됨
    - 마스크 가능(`maskable`)
        - 장치 컨트롤러가 서비스를 요청하기 위해 사용

<br/>

<br/>

- 벡터 방식 인터럽트 기법의 목적
    - 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이기 위함! → 해결법 :  **인터럽트 체인을 사용**하기

<br/>

<br/>

 
- 동작 방식
    - 인터럽트 벡터의 각 요소는 인터럽트 핸들러 리스트의 헤드를 가리킨다.
    - 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다.
    - 이러한 구조는 큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치하는 비효율성의 절충안이다.


<br/>

<br/>

 
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/event-vector-table.png" width = 500/>

- 마스크 불가능한 0 ~ 31까지의 이벤트는 다양한 오류 조건을 알리는 데 사용된다.
- 마스크 가능한 32 ~ 255까지의 이벤트는 장치가 생성한 인터럽트 같은 그 외 인터럽트를 처리한다.


<br/>

<br/>

 
- 인터럽트 기법은 또한 인터럽트 **우선순위 레벨(interrupt priority level)을 구현**한다!
    - 이 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위를 판단해 동작한다.


<br/>

<br/>

 
> ### *요약*
> - 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 뤼해 사용된다.
> - 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생한다.
> - 가장긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 인터럽트 우선순위 시스템을 사용한다.
> - 인터럽트는 시간에 민감한 처리에 빈번하게 사용된다.
> 
>   → 시스템 성능을 좋게하려면 효율적인 인터럽트 처리가 필요하다.*


<br/>

<br/>

 
### 저장장치 구조

- CPU는 메모리에서만 명령을 적재할 수 있다.
  - 실행하려면 프로그램을 먼저 메모리에 적재해야 한다.
    

<br/>

<br/>

 
- 범용 컴퓨터는 프로그램 대부분을 메인 메모리(**RAM**)라 불리는 재기록 가능한 메모리에서 가져온다.
    - 메인 메모리는 DRAM(Dynamic RAM)라 불리는 반도체 기술로 구현된다.


<br/>

<br/>

 
- 컴퓨터는 다른 형태의 메모리도 사용된다.
    - ex) **부트스트랩 프로그램**은 전원을 키면 가장 먼저 실행되고, 운영체제를 적재한다.
        - RAM은 **휘발성**이므로 부트스트랩 프로그램에 적합하지 않다!
    - 대신 다른 목적으로, 전기적으로 소거 가능한 프로그램 가능 읽기 전용 메모리(EEPROM) 및 기타 형태의 **펌웨어**(쓰기 작업이 자주 발생하지 않고 비휘발성인 저장장치)를 사용한다.
        - EEPROM은 변경할 수는 있지만 자주 변경할 수는 없다!


<br/>

<br/>

 
- 모든 형태의 메모리는 바이트의 배열을 제공한다.
    - 각 바이트는 자신의 주소를 가지고 있다.
    - 상호 작용은 특정 메모리 주소들에 대한 **적재(load)**, 또는 **저장(store)** 명령을 통해 이루어진다.
        - 적재 : 메인 메모리로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것.
        - 저장 : 레지스터의 내용을 메인 메모리로 옮기는 것.


<br/>

<br/>
 
- **폰 노이만 구조 시스템**에서 실행되는 전형적인 `명령 - 실행` 사이클
    1. 메모리로부터 명령을 인출하고, 그 명령을 **명령 레지스터**에 저장한다.
    2. 명령을 해독하고, 이는 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발한다.
    3. 피연산자에 대해 명령을 실행한 후 결과가 메모리에 다시 저장된다.
        


<br/>

<br/>


> ***→ 이때, 메모리 장치는 단지 일련의 메모리 주소만을 인식한다는 사실에 유의하자!***
> 
> → 메모리는 이들의 주소(명령 카운터, 색인, 간접 주소 등등..)가 어떻게 생성되었는지 알지 못한다.
>
> → 또한 그것이 무엇인지(명령인지 데이터인지)도 알지 못한다!
>
> → 그러므로 우리는 메모리 주소가 프로그램에 의해 ***어떻게*** 생성되었는지 무시할 수 있다.
> 
> : 우리는 단지 실행 중인 프로그램에 의해 생성된 일련의 메모리 주소에만 흥미가 있다.


<br/>

<br/>
 
- 이상적으로는, 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다.
    - 단, 이는 대부분의 시스템에서 두 가지 이유로 불가능하다.
        1. 메인 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.
        2. 메인 메모리는 이미 언급한 것처럼 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성이다.


<br/>

<br/>
 
- 그러므로 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 **보조저장장치**를 제공한다.
    - 주요 요건은 대량의 데이터를 영구히 보존할 수 있어야 한다는 점이다.
    - 가장 일반적인 보조저장장치는 **하드 디스크 드라이브(HDD)와 비휘발성 메모리(NVM) 장치**이다.

<br/>
 
- 대부분의 프로그램은 메모리에 적재될 때까지 보조저장장치에 저장된다.
    - 따라서 많은 프로그램이 보조저장장치를 처리 소스 및 대상으로 모두 사용한다.

<br/>

<br/>

 
- **3차 저장장치**
    - 다른 장치에 저장된 자료의 백업 사본을 저장하기 위해 특수 목적으로만 사용하기에 매우 느리고 충분히 큰 장치를 말한다.

<br/>

<br/>

 
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/storage-device-hierarchy.png" width = 500/>

저장장치 계층 구조
- 다양한 저장장치 시스템은 저장 용량 및 액세스 시간에 따라 계층 구조로 구성될 수 있다.
    - 일반적으로 크기와 속도 사이에는 상충하는 측면이 있어 메모리가 작고 빠를수록 CPU에 더 가깝다!

<br/>
<br/>

<br/>

 
- 그림에서 최상위 4단계 메모리는 반도체 기반 전자회로로 구성된 **반도체 메모리**를 사용하여 구성된다.
    - 네 번째 수준의 NVM 장치에는 여러 가지 변형이 있지만 일반적으로 하드 디스크보다 빠르다.


<br/>

<br/>
 
> 🌱 *저장장치는 운영체제 구조에서 중요한 역할을 하므로 자주 참조된다. 아래 용어를 기억하자.*
>
> - 휘발성 저장장치를 단순히 **메모리**라고 표현할 것이다.
> - 비휘발성 저장장치를 **NVS**라고 표현할 것이고, 이는 두 가지 유형으로 분류된다.
>    - **기계적** : ex) HDD, 광 디스크, 홀로그램 저장장치
>    - **전기적** : ex) 플래시 메모리, FRAM, NRAM 및 SSD → **NVM**
>
>  → 기계적 저장장치는 일반적으로 전기적 저장장치보다 용량이 크고 바이트당 비용이 저렴하다.
>
>  → 반대로 전기적 저장 장치는 일반적으로 기계적 저장장치보다 비싸고 용량이 적으며 빠르다.



<br/>

<br/>
 
### 입출력 구조

- 운영체제 코드의 상당 부분은 아래 내용으로 인해 I/O 관리에 할애된다.
  - 시스템의 안정성
  - 성능에 대한 중요성
  - 장치의 다양한 특성


<br/>

<br/>
 
- 앞에서 설명한 인터럽트 구동 I/O 형태는 소량의 데이터를 이동하는 데는 좋다!
    - 하지만 NVS I/O 와 같은 대량 데이터 이동에 사용될 때는 높은 오버헤드를 유발한다.
    - 이 문제를 해결하기 위해 **직접 메모리 액세스(DMA)**가 사용된다.


<br/>

<br/>
 
<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/modern-computer-works.png" width = 500/>

- DMA 동작 방식
    - 장치에 대한 버퍼 및 포인터, 입출력 카운터를 세팅한 후 장치 제어기는 CPU의 개입 없이 [메모리로부터 자신의 버퍼 장치로] 또는 [버퍼로부터 메모리로] 데이터 블록 정체를 전송한다.
    - 속도가 느린 장치와 달리 블록 전송이 완료될 때마다 인터럽트가 발생한다.


<br/>

<br/>
 
- 몇몇 고가의 시스템은 버스 대신에 스위치 구조를 사용한다.
    - 공용 버스를 사용하기 위한 사이클을 경쟁하지 않고 다수의 구성요소가 동시에 통신이 가능하다.
    - 이 경우 DMA의 사용은 더욱 효과적이다!

<br/>
 
<br/>
 
 ## 💡 컴퓨터 시스템 구조

 컴퓨터 시스템은 사용된 범용 처리기 수에 따라 분류 가능한 다양한 방식으로 구성될 수 있다.


<br/>

<br/>

### 단일 처리기 시스템

몇년 전, 대부분의 컴퓨터는 단일 처리 코어를 가진 하나의 CPU를 포함하는 단일 프로세서를 사용했다.
- **코어** : 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성 요소
- 코어를 가진 하나의 메인 CPU : 프로세스의 명령어를 포함하여 범용 명령어 세트를 실행할 수 있다.


<br/>

<br/>

모든 전용 처리기들은 제한된 명령어 집합을 실행하고 사용자 프로세스를 실행하지는 않는다.
- 때로 이 처리기들은 운영체제에 의해 관리되기도 하는데, 운영체제는 이 처리기들이 수행할 다음 태스크에대한 정보를 보내고 처리기들의 상태를 감시한다.
  - ex) 디스크 컨트롤러 마이크로프로세서 : 주 CPU로부터 연속된 요청을 받아들이고, 자기 고유의 디스크 큐와 스케줄링 알고리즘을 구현한다.
  - 이 배합은 CPU가 직접 디스크 스케줄링을 해야 하는 오버헤드를 감소시킨다.


<br/>

<br/>


- PC의 키보드는 키스트로크를 CPU에 전송할 코드로 변환하는 마이크로프로세서를 가진다.
    - 이는 다른 환경에서는 전용 처리기가 하드웨어로 구현되는 저수준의 구성요소이다.
    - 운영체제는 이 처리기들과 통신할 수 없으며, 이 처리기들은 독립적으로 자신의 작업을 처리한다.


<br/>

<br/>

### 다중 처리기 시스템

최신 컴퓨터에서는 **다중 처리기 시스템**이 컴퓨팅 환경을 지배하고 있다.
- 일반적으로 이러한 시스템은 각각 단이 코어 CPU가 있는 두 개 이상의 프로세서가 있다.
- 프로세서는 컴퓨터 버스 및 클록, 메모리 및 주변 장치를 공유한다.


<br/>

<br/>

- 다중 처리기 시스템의 주요 장점 : **처리량 증가**
    - 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 수행할 수 있다.
    - 그러나 N 프로세서의 속도 향상 비율이 N은 아니다!
    
    → 여러 프로세서가 하나의 작업에 협력할 때 모든 프로세서가 올바르게 동작하는 데에 오버헤드가 발생
    

<br/>

<br/>

- 가장 일반적인 다중 처리기 시스템은 **SMP(Symmetric multiprocessing)**를 사용한다.
    - SMP : 각 CPU 프로세서가 운영체제 기능 및 사용자 프로세스를 포함한 모든 작업을 수행하는 방식


<br/>

<br/>


<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/smp.png" width = 500/>


- 각각 자체 CPU를 가지는 두 개의 프로세서가 있는 일반적인 SMP 구조이다.
    - 각 CPU 처리기에는 개별 또는 로컬 캐시뿐만 아니라 자체 레지스터 세트가 있다.
    - 그러나 모든 프로세서는 시스템 버스를 통해 물리 메모리를 공유한다.


<br/>

<br/>

- ***SMP의 장점 → 많은 프로세스를 동시에 실행할 수 있다!***
    - 이 형식의 다중 처리기 시스템을 사용하면 프로세스 및 메모리와 같은 자원을 동적으로 공유할 수 있다.
    - 또한 프로세서 간의 작업 부하 분산을 낮출 수 있다.


<br/>

<br/>

- **다중 처리기**의 정의는 여러 개의 컴퓨팅 코어가 단일 칩에 상주하는 **다중 코어** 시스템을 포함한다.
    - 칩 내 통신이 칩 간 통신보다 빠르다 → 다중 코어 시스템이 단일 코어의 여러 칩보다 효율적일 수 있다!
    - 또한 여러 개의 코어를 가지는 하나의 칩은 여러 개의 단일 코어 칩보다 훨씬 적은 전력을 사용한다.


<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/dual-code-design.png" width = 500/>

- 이 설계에는 각 코어에 자체 레지스터 세트와 레벨 1캐시라고 하는 자체 로컬 캐시가 있다.
- 또한 레벨 2 캐시는 칩에 국한되지만 두 처리 코어에서 공유한다.


<br/>

<br/>

***→ 아키텍처 대부분은 로컬 및 공유 캐시를 결합한 이 접근 방식을 채택한다!***


<br/>

<br/>

> 💡 ***컴퓨터 시스템의 구성요소 정의***
>
>- CPU : 명령을 실행하는 하드웨어
>- 프로세서 : 하나 이상의 CPU를 포함하는 물리적 칩
>- 코어 : CPU의 기본 계산 단위
>- 다중 코어 : 동일한 CPU에 여러 컴퓨팅 코어를 포함
>- 다중 처리기 : 여러 프로세서를 포함


<br/>

<br/>

- 다중 처리기 시스템에 CPU를 추가하면 컴퓨팅 성능이 향상된다.
    - 이러한 개념은 그다지 확장성이 좋지 않고, CPU를 너무 많이 추가할 경우
    - 시스템 버스에 대한 경합이 병목 현상이 되어 성능이 저하되기 시작한다.
    - 다른 방법은 각 CPU에 작고 빠른 로컬 버스를 통해 액세스되는 자체 로컬 메모리를 제공하기!
        - 모든 CPU가 **공유 시스템 연결**로 연결되어 모든 CPU가 하나의 물리 주소 공간을 공유한다.
        - 이 방식을 **NUMA(non-uniform memory access)**라고 한다.


<br/>

<br/>


<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/NUMA.png" width = 500/>

- ***NUMA 시스템의 장점***
    - CPU가 로컬 메모리에 액세스할 때 빠를 뿐만 아니라 시스템 상호 연결에 빠르다.
    - 시스템 상호 연결에 대한 경합도 없다!
    - 따라서 NUMA 시스템은 더 많은 프로세서가 추가될수록 더 효과적으로 확장할 수 있다!


<br/>

<br/>

- ***NUMA 시스템의 단점***
    - CPU가 시스템 상호 연결을 통해 원격 메모리에 액세스해야 할 때 지연 시간이 증가한다.
        
        → 성능 저하가 발생할 수 있다.
        

<br/>

<br/>

- **블레이드 서버**는 다수의 처리기 보드 및 입출력 보드 등이 하나의 섀시(chassis)안에 장착되는 형태다.
    - 전통적인 다중 처리기 시스템과의 차이점
        - 각 `블레이드-처리기 보드`는 독립적으로 부팅될 수 있고, 자신의 운영체제를 수행한다.
        - 어떤 `블레이드-서버 보드`는 자체가 다중 처리기이며, 이는 컴퓨터 유형 경계를 모호하게 한다.
        - 근본적으로 블레이드 서버는 여러 독립적인 다중 처리기 시스템으로 구성된다.


<br/>

<br/>

### 클러스형 시스템

- 클러스터형 시스템도 마찬가지로 여러 CPU를 가진 시스템이다.
    - 둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성한다는 점에서 다중 처리기 시스템과 차이가 난다.
    - 각 노드는 통상 다중 코어 시스템이고, 이러한 시스템은 **약결합(loosely coupled)**이라고 간주된다.

<br/>

<br/>

- 클러스터형(clustered)의 정의는 분명하지 않다.
    - 일반적으로 받아들여지는 정의에 의하면 클러스터 컴퓨터는 저장장치를 공유하고 근거리 통신망이나 InfiniBand와 같은 고속의 상호 연결망으로 연결된다.


<br/>

<br/>

- 클러스터링은 통상 높은 가용성(availability)을 제공하기 위해 사용된다.
    - 즉, 클러스터 내 하나 이상의 컴퓨터 시스템이 고장나더라도 계속 제공된다.
    - 일반적으로 높은 가용성은 시스템에 중복 기능을 추가함으로써 얻어진다.


<br/>

<br/>

- 동작 과정
    1. 클러스터 소프트웨어 중 한 층이 클러스터 노드에서 실행된다.
    2. 각 노드는 하나 이상의 다른 노드들을 감시한다.
    3. 만일 감시받던 노드가 고장나면 감시하던 노드가 고장 난 노드의 저장장치에 대한 소유권을 넘겨받고, 그 노드에서 실행 중이던 응용 프로그램을 다시 시작한다.
    
    <br/>
    → 사용자와 응용 프로그램의 클라이언트는 잠깐의 서비스 중단만을 경험하게 된다.
    

<br/>

<br/>

- 높은 가용성은 안정성을 향상해 많은 응용 프로그램에서 중요하다.
    - 남아 있는 하드웨어 수준에 비례하여 서비스를 계속 제공하는 기능을 **우아한 성능 저하**라고 한다
    - 일부 시스템은 정상적인 성능 저하를 넘어 단일 구성요서에 오류가 발생하여도 계속 동작할 수 있다.
        
        → 이를 **결함허용 시스템**이라고 한다.
        
        → 그리고 결함 허용에는 장애를 감지, 진단 및 가능한 경우 수정할 수 있는 기법이 필요하다.
        

<br/>

<br/>

- 클러스터링은 비대칭적으로 또는 대칭적으로 구성될 수 있다.
    - ***비대칭형 클러스터링***
        - 다른 컴퓨터들이 응용 프로그램을 실행하는 동안 한 컴퓨터는 **긴급 대기 모드 상태**를 유지한다.
        - 이 긴급 대기 모드의 호스트는 활성 서버들을 감시하는 작업만을 수행하고,
        - 서버가 고장난다면 긴급 대기 모드의 호스트가 활성 서버가 된다.
        
        <br/>

    - ***대칭형 클러스터링***
        - 둘 이상의 호스트들이 응용 프로그램을 실행하고 서로를 감시한다.
        - 가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이 더 효율적이다.
        

<br/>

<br/>

- 클러스터는 고성능 계산환경을 제공하도록 사용될 수 있다.
    - 한 클러스터가 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되기 때문!
    - 이러한 시스템은 클러스터 내의 모든 컴퓨터에서 응용을 병렬 수행할 수 있다.
        
        → 단일 처리기나 SMP 시스템보다 훨씬 큰 계산 능력을 제공할 수 있다.
        

<br/>

<br/>

- 또한 응용이 클러스터를 이용할 수 있도록 작성되어야 한다.
    - 이는 **병렬화**라는 기법으로, 프로그램을 컴퓨터의 개별 코어에서 수행되는 분리된 요소로 나누는 작업을 포함한다.
    - 전형적으로 응용은 클러스터의 각 계산 노드가 문제 일부를 해결한 후 모든 노드의 결과를 결합하여 최종 해답을 얻는다.


<br/>

<br/>

- 다른 형태의 클러스터로는 병렬 클러스터와 WAN을 이용한 클러스터가 있다.
    - 병렬 클러스터
        - 여러 호스트가 공유 저장장치 상의 동일한 데이터에 접근할 수 있게 한다.
        - 운영체제의 대부분이 여러 호스트에 의한 이러한 동시 접근을 지원하지 않는다.
        
            → 특수 소프트웨어 버전과 특별히 발매된 응용으로 달성된다.


<br/>

<br/>

- 데이터에 대한 공유 접근을 제공하기 위하여, 시스템은 접근 간의 충돌이 발생하지 않도록 보장한다.
    - 그러려면 접근 제어와 잠금 기법을 제공해야 하며, 이는 분산 잠금 관리자(DLM)가 수행한다.


<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/cluster-system.png" width = 500/>

- 클러스터 기술을 급변하고 있다.
    - 어떤 클러스터 제품은 수 킬로미터 떨어진 노드와도 지원한다.
    - 이러한 개선은 **스토리지 전용 네트워크(SAN)**에 의해 가능해졌다.


<br/>

<br/>

- SAN은 여러 호스트를 여러 저장장치에 부착할 수 있게 한다.
    - 만일 응용과 데이터가 SAN에 저장된다면?
    → 클러스터 소프트웨어는 SAN에 연결된 임의의 호스트에서 수행되도록 응용을 배정할 수 있다.
    - 호스트가 고장나면 다른 호스트가 그 응용을 넘겨 받는다. → **성능과 신뢰도를 매우 증가시킴!!**

<br/>

<br/>

## 💡 운영체제의 작동

- 운영체제는 프로그램이 실행되는 환경을 제공한다.
- 내부적으로 운영체제는 여러 경로를 거쳐 구성되기 때문에 운영체제마다 큰 차이를 보인다.
    - 그러나 많은 공통점이 존재하므로, 이 공통점에 대해서 논의해보자!


<br/>

<br/>

- 컴퓨터의 전원을 켜거나 재부팅 할 때와 같이 컴퓨터를 실행하려면 초기 프로그램을 실행해야 하는데,
    - 이 초기 프로그램(또는 부트스트랩)은 단순한 형태를 띠는 경향이 있다.
    
      → 일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장된다.


<br/>

<br/>

- CPU 레지스터에서 장치 컨트롤러, 메모리 내용에 이르기까지 시스템의 모든 측면을 초기화한다.
    - 부트스트랩 프로그램은 운영체제를 적재하는 방법과 해당 시스템 실행을 시작하는 방법을 알아야 한다.
    - 이 목표를 달성하려면 부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재해야 한다.


<br/>

<br/>

- 커널이 적재되어 실행되면 시스템과 사용자에게 서비스를 제공할 수 있다.
    - 일부 서비스는 커널이 실행되는 전체 시간 동안 실행되는 **시스템 데몬**이 되기 위해 부팅할 때 메모리에 적재되는 시스템 프로그램에 의해 커널 외부에서 제공된다.
    - ex) Linux의 첫 번째 프로그램인 `systemd`는 많은 데몬을 시작한다.


<br/>

<br/>

- 실행할 프로세스 및 응답할 사용자가 없는 경우 운영체제는 무언가 발생할 때까지 대기한다.
    - 이벤트는 거의 항상 인터럽트를 발생시켜 신호를 보낸다.
    - 다른 형태의 인터럽트는 **트랩**(또는 **예외**)으로, 오류 또는 사영자 프로그램의 특정 요청 때문에 발생한다.
    - 이 특정 요청은 ***시스템 콜***이라는 특수 연산을 실행하여 요청되고 운영체제가 제공하는 서비스가 수행될 것을 요구한다.


<br/>

<br/>

### 다중 프로그래밍과 다중 태스킹

> 💡 운영체제의 가장 중요한 측면 중 하나는 ***여러 프로그램을 실행***할 수 있다는 것이다.

<br/>

***다중 프로그래밍***

- CPU가 ***항상 한 개는 실행할 수 있도록 프로그램을 구성***하여 ***CPU 이용률을 높이고 만족도를 높인다.***
- 다중 프로그램 시스템에서 실행중인 프로그램을 **프로세스**라고 한다.


<br/>

<br/>

- 운영체제는 여러 프로세스를 동시에 메모리에 유지하고, 이 중 하나를 선택하여 실행하기 시작한다.
    - 결국 프로세스는 I/O 작업과 같이 일부 작업이 완료되기를 기다려야 할 수도 있다.
    - 다중 프로그래밍 되지 않은 시스템에선 CPU가 유휴 상태일 수 있다.


<br/>

<br/>

- 다중 프로그램 시스템에서 운영체제는 단순히 다른 프로세스로 전환하여 실행한다.
    - 해당 프로세스가 대기해야 하는 경우 CPU는 다른 프로세스로 전환한다.
    - 결국 첫 번째 프로세스는 대기를 마치고 CPU를 다시 돌려받는다.
    - 하나 이상의 프로세스를 실행해야 하는 한 CPU는 유휴 상태가 아니다.


<br/>

<br/>

- 이 아이디어는 다른 일상에서도 흔히 볼 수 있다.
    - 변호사는 여러 의뢰인을 담당할 수 있고, 재판을 기다리는 동안 다른 사건을 처리할 수 있다.


<br/>

<br/>

***다중 태스킹(multitasking)***

- 다중 프로그래밍의 논리적 확장
- CPU가 여러 프로세스를 전환하며 프로세스를 실행하지만 전환이 자주 발생하여, 사용자에게 빠른 응답시간을 제공한다. → 이는 입출력일 경우 컴퓨터에겐 상당히 느린 속도이다.


<br/>

<br/>

- 여러 프로세스가 동시에 실행할 준비가 되면 시스템은 다음에 실행할 프로세스를 선택해야 한다,
    - 이 결정을 내리는 것이 (5장에서 나올) **CPU 스케줄링**이다.


<br/>

<br/>

- 마지막으로, 여러 프로세스를 병행 실행하려면 프로세스 스케줄링, 디스크 저장장치 및 메모리 관리를 포함하여 운영체제의 모든 단계에서 서로 영향을 미치는 기능이 제한되어야 한다.


<br/>

<br/>

- 다중 태스킹 시스템에서 운영체제는 적절한 응답 시간을 보장해야 한다.
    - 일반적인 방법은 **가상 메모리**인데, 이는 일부만 메모리에 적재된 프로세스의 실행을 허용하는 기법이다.
    - 이 기법의 이점은 프로그램이 **물리 메모리**의 크기보다 더 커도 된다는 것이다.
    - 더욱이 가상 메모리는 메인 메모리보다 크고 균등한 저장장치의 배열로 추상화하여, 사용자에게 보이는 **논리 메모리**를 물리 메모리로부터 분리시킨다.
    - 이러한 기법이 프로그래머를 메모리 저장장치의 한계로부터 자유롭게 해준다.


<br/>

<br/>

- 다중 프로그래밍 및 다중 태스킹 시스템도 파일 시스템을 제공해야 한다.
    - 파일 시스템은 보조저장장치에 존재하므로, 저장장치 관리가 제공되어야 한다.
    - 또한 시스템은 부적절한 사용으로부터 자원을 보호해야 한다.
    - 질서있게 실행하려면? → 프로세스 동기화 및 통신을 위한 기법을 제공해야 함!
    - 프로세스가 서로를 영원히 기다리는 **교착 상태**에 빠지지 않도록 보장해야 한다!


<br/>

<br/>

### 이중-모드와 다중모드 운용

> 💡 운영체제와 사용자는 하드웨어 및 소프트웨어 자원을 공유한다. 
> 이를 위해선 운영체제 실행 코드와 사용자-정의 코드 실행을 구분할 수 있어야 한다.


<br/>

<br/>

- 안정성을 위해선 두 개의 독립된 연산모드를 필요로 한다.
    - ***사용자 모드***와 ***커널 모드(= 혹은 특권 모드)***가 존재한다.


<br/>

<br/>

- 모드 피트(mode bit)라고 하는 하나의 비트가 현재의 모드를 나타내기 위해 추가되었다.
    - 이 비트는 커널 모드(0) 또는 사용자 모드(1)를 나타낸다.


<br/>

<br/>


<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/mode-transition.png" width = 500/>


<br/>

<br/>

- 동작 과정
    - 시스템 부트 시, 하드웨어는 커널 모드에서 시작된다.
    - 이어서 운영체제가 적재되고, **사용자 모드에서 사용자 프로세스가 시작**된다.
    - 트랩이나 **인터럽트가 발생**할 때마다, 하드웨어는 **사용자 모드에서 커널 모드**로 전환한다.
        - 그러므로 운영체제가 컴퓨터의 제어를 얻을 때마다 항상 커널 모드에 있게 된다!


<br/>

<br/>

- 동작의 이중 모드는 잘못된 사용자로부터 운영체제를, 그리고 서로를 보호하는 방법을 제공한다.
    - 우리는 악영향을 끼칠 수 있는 일부 명령을 **특권 명령(privileged instruction)**으로 지정한다.
    - 하드웨어는 특권 명령이 커널 모드에서만 수행되도록 허용한다.


<br/>

<br/>

- 커널 모드로 전환하는 명령어가 특권 명령어의 예이다.
    - 다른 예로는 I/O 제어, 타이머 관리 및 인터럽트 관리가 있다.


<br/>

<br/>

- 모드의 개념은 두 가지 모드 이상으로 확장될 수 있다.
    - Intel 프로세서에는 4개의 분리된 **보호 링**이 있다.
        - 링 0은 커널 모드, 링 3은 사용자 모드이다. (그 외는 거의 사용되지 않는다.)
    - ARMv8 시스템에는 7가지 모드가 있다.
    - 가상화를 지원하는 CPU는 종종 `VMM(virtual machine manage)`이 시스템을 제어하는 시점을 표시하기 위한 별도의 모드를 가진다.


<br/>

<br/>

- 시스템 콜은 사용자 프로그램이 자신을 대신하여 요청할 수 있는 방법을 제공한다.
    - **무엇을(`what`)? → 운영체제가 수행하도록 지정되어 있는 작업!**


<br/>

<br/>

- 시스템 콜은 컴퓨터 시스템의 처리기가 지원하는 기능에 따라 다양한 방법으로 호출된다.
    - 어떠한 형태를 가지든 운영체제에 의해 수행될 동작을 사용자 프로세스가 요청할 수 있게 한다.
    - 일반적으로 인터럽트 벡터의 특정 위치로 트랩을 거는 형태를 취한다.

<br/>

<br/>

- 시스템 콜이 수행될 때, 시스템 콜은 하드웨어에 의해 하나의 소프트웨어 인터럽트로 취급된다.
    - 제어가 인터럽트 벡터를 통해 운영체제 내의 서비스 루틴으로 전달되고, 모드 비트가 커널 모드로 설정된다.
    - 커널은 인터럽트를 발생시킨 명령을 검사하여 어떤 시스템 콜이 발생했는지를 결정한다.

<br/>

<br/>

- 이때 전달된 인수가 사용자 프로그램이 요청하는 서비스 유형을 표시한다.
    - 요청이 필요로 하는 추가의 정보는 레지스터, 스택 또는 메모리로 전달될 수 있다.
    - 커널은 인수가 정확하고 합법적인지 검증하고 요청을 수행한 후 시스템 콜 다음 명령으로 복귀한다.

<br/>

<br/>

- 하드웨어 보호 기능이 제공되면 모드 규칙을 위반하는 오류가 탐지된다.
    - 이러한 오류는 일반적으로 운영체제가 처리한다.
    - 사용자 프로그램이 불법적인 명령을 수행하려 하거나, 어떤 오류를 발생시키면 트랩을 발생시킨다.
    - 트랩은 인터럽트 벡터를 통해 프로그램을 종료시킨다.

<br/>

<br/>

### 타이머

> 💡 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장해야 한다.
>
> 사용자 프로그램이 무한 루프에 빠지거나 시스템 서비스 호출에 실패하여, ***제어가 운영체제로 > 복귀하지 않는 경우가 없도록 방지***해야 한다. → ***타이머***를 이용해보자!


<br/>

<br/>

- 타이머는 지정된 시간 이후 컴퓨터를 인터럽트하도록 설정할 수 있다.
    - 가변 타이머는 일반적으로 고정률의 클록과 계수기로 구현한다.

<br/>

<br/>

- 사용자에게 제어를 양도하기 전에, 운영체제는 타이머가 인터럽트할 수 있도록 설정되었는지 확인한다.
    - 타이머의 값을 변경하는 명령은 명백히 특권 명령이다.

<br/>

<br/>

## 💡 자원 관리

> 💡 앞에서 보았듯, 운영체제는 자원관리자이며, 자원에는 CPU, 메모리 공간 등등이 속한다.

<br/>

<br/>

### 프로세스 관리

- 프로그램은 CPU에 의해 명령이 실행되지 않으면 아무것도 할 수 없다.
    - 지금은 프로세스가 실행 중인 프로그램의 인스턴스라고 생각할 수 있지만, 나중엔 개념이 더 일반적이라는 것을 알게 될 것이다.

<br/>

<br/>

- 프로세스는 자기 일을 수행하기 위해 여러 가지 자원을 필요로 한다.
    - 이러한 자원은 보통 실행되는 동안 할당된다.
    - 프로세스가 생성될 때 획득하는 여러 가지 물리적 논리적인 자원 외에, 여러 초기화 데이터도 아울러 전달될 수 있다.

<br/>

<br/>

- 우리는 프로그램 그 자체는 프로세스가 아님을 강조한다.
    - 프로그램은 디스크에 저장된 파일의 내용과 같이 수동적(passive) 개체지만,
    - 프로세스는 다음 수행할 명령을 지정하는 **프로그램 카운터**를 가진 능동적(active) 개체이다.

<br/>

<br/>

- 한 프로세스의 수행은 반드시 순차적이어야 한다.
    - CPU는 그 프로세스가 끝날 때까지 그 프로세스의 명령들을 차례대로 수행한다.
    - 게다가, 어느 한순간에는 많아야 그 프로세스를 위해 하나의 명령만  수행된다.

<br/>

<br/>

- 한 프로세스는 한 시스템 내의 작업의 단위이다.
    - 이러한 시스템은 프로세스의 집합으로 구성되는데, 프로세스 중 일부는 운영체제 프로세스들이며, 나머지는 사용자 프로세스들이다.
    - 이러한 모든 프로세스는 단일 CPU 코어에서 멀티플렉싱하거나 여러 CPU 코어에서 병렬로 실행할 수 있다.

<br/>

<br/>

- 운영체제는 프로세스 관리와 연관해 아래 활동에 대한 책임을 가진다.
    - 사용자 프로세스와 시스템 프로세스의 생성과 제거
    - CPU에 프로세스와 스레드 스케줄하기
    - 프로세스의 일시 중지와 재수행
    - 프로세스 동기화를 위한 기법 제공
    - 프로세스 통신을 위한 기법 제공

<br/>

<br/>

### 메모리 관리

- 메인 메모리는 현대 컴퓨터 시스템의 작동에 중추적인 역할을 한다.
    - 메인 메모리는 CPU와 입출력 장치에 의하여 공유되는, 빠른 접근이 가능한 데이터의 저장소이다.

<br/>

<br/>

- 폰 노이만 방식의 컴퓨터에서는 CPU가 명령어 인출 사이클(instruction fetch-cycle)동안 메인 메모리로부터 명령어를 읽고, 자료 인출 사이클(data fetch-cycle)동안 메인 메모리로부터 데이터를 읽고 쓴다.

<br/>

<br/>

- 메인 메모리는 일반적으로 CPU가 직접 주소를 지정할 수 있고, 직접 접근할 수도 있다.
    - 마찬가지로 CPU가 명령을 수행하려면 명령이 메인 메모리 내에 있어야 한다.

<br/>

<br/>

- 프로그램이 수행되기 위해서는 반드시 절대 주소로 매핑되고 메모리에 적재되어야  한다.
    - 프로그램을 수행하면서, 이러한 절대 주소를 생성하여 메모리의 프로그램 명령어와 데이터에 접근한다.

<br/>

<br/>

- CPU 이용률과 사용자에 대한 컴퓨터 응답 속도를 개선하기 위해, 메모리 관리 기법이 필요하다.
    - 메모리 관리 기법에는 여러 종류가 있다.
    - 메모리 관리에 대한 여러 접근 방법을 반영하는데, 각 알고리즘의 효율성은 특정 상황에 따라 다르다.

<br/>

<br/>

- 특정 시스템에 대한 ***메모리 관리 기법의 선택은 특히 시스템의 하드웨어 설계에 좌우***된다.
    - 각 알고리즘은 자기를 위한 하드웨어 지원이 필요하다.
    - 운영체제는 메모리 관리와 관련하여 아래와 같은 일을 담당해야 한다.
        - 메모리의 어느 부분이 현재 사용되고 있으며, 어느 프로세스에 의해 사용되고 있는지를 추적
        - 필요에 따라 메모리 공간을 할당하고 회수
        - 어떤 프로세스들을 메모리에 적재하고 제거할 것인가를 결정

<br/>

<br/>

### 파일 시스템 관리

- 편리를 위해, 운영체제는 정보 저장장치에 대한 균일한 논리적 관점을 제공한다.
- OS는 저장장치의 물리적 특성을 추상화하여 논리적인 저장 단위인 파일을 정의한다.
    - 이후 파일을 물리적 매체로 매핑하며, 저장장치를 통해 이들 파일에 접근한다.

<br/>

<br/>

- 파일 관리는 가장 눈에 띄눈 운영체제 구성요소 중의 하나이다.
    - 컴퓨터는 여러 유형의 물리적 매체에 정보를 저장할 수 있고, 각 매체는 자신의 특성과 물리적 구성을 가진다.

<br/>

<br/>

- 대부분의 매체는 디스크 드라이브와 같은 장치에 의해 제어되며, 이들 장치 또한 독특한 특성이 있다.
    - 이러한 속성에는 접근 속도, 용량, 데이터 전송률, 그리고 접근 방식 등이 있다.

<br/>

<br/>

- 파일은 파일 생성자에 의해 정의된 관련 정보의 집합체다.
    - 일반적으로 파일은 프로그램과 데이터를 나타낸다.
    - 파일은 텍스트 파일과 같은 자유 형태일 수도 있고, 엄격하게 포맷된 형태일 수도 있다.

<br/>

<br/>

- 운영체제는 대량 저장 매체와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을 구현한다.
    - 또한, 파일은 사용하기 쉽도록 통상 디렉토리들로 구성된다.
    - 다수의 사용자가 파일에 접근하려고 할 때는 누구에 의해서, 그리고 어떤 방법(읽기, 쓰기, 첨가 등)으로 파일이 접근되어야 하는가를 통제하는 것이 바람직하다.

<br/>

<br/>

- 운영체제는 파일 관리를 위하여 다음과 같은 일을 담당한다.
    - 파일의 생성 및 제거
    - 디렉터리 생성 및 제거
    - 파일과 디렉터리를 조작하기 위한 프리미티브의 제공
    - 파일을 보조저장장치로 매핑
    - 안정적인(비휘발성) 저장 매체에 파일을 백업

<br/>

<br/>

### 대용량 저장장치 관리

- 컴퓨터 시스템은 메인 메모리를 백업하기 위해 보조저장장치를 제공해야 한다.
    - 대부분의 최신 컴퓨터 시스템은 HDD와 NVM 장치를 프로그램과 데이터 모두에 대한 주요 온라인 저장 매체로 사용한다.

<br/>

<br/>

- 운영체제는 보조저장장치 관리와 관련하여 다음 활동을 담당한다.
    - 마운팅과 언마운팅
    - 사용 가능 공간(free-space)의 관리
    - 저장장소 할당
    - 디스크 스케줄링
    - 저장장치 분할
    - 보호

<br/>

<br/>

- 보조저장장치는 매우 빈번하고 폭넓게 사용되므로, 효율적으로 사용해야 한다.
    - 컴퓨터의 전체 동작 속도는 보조저장장치 서브시스템과 그것을 조작하는 알고리즘의 속도에 의해 결정될 수 있다.

<br/>

<br/>

- 보조저장장치보다 더 느리고 비용은 적게 들고 떄로는 용량이 더 큰 장치를 필요로 하는 경우도 많다.
    - ex) 디스크 데이터의 백업 등등

<br/>

<br/>

- 3차 저장장치는 시스템 성능에는 중요하지 않지만 운영체제에 의해 관리되어야만 한다.
    - 어떤 운영체제들은 이 역할을 직접 수행하며 다른 운영체제들은 이 역할을 응용 프로그램에게 맡기기도 한다.
    - 운영체제가 제공해야 할 기능에는 마운트와 언마운트 기능, 프로세스의 배타적 사용을 위한 장치의 할당과 반환 그리고 보조저장장치로부터 3차 저장장치로의 데이터 이주 등이 포함된다.

<br/>

<br/>

### 캐시 관리

- ***캐싱***은 컴퓨터 시스템의 중요한 원리이다.
    - 정보는 통상 어떤 저장장치에 보관되는데, 정보가 사용됨에 따라 더 빠른 장치인 **캐시에 일시적으로 복사**된다.
    - 그러므로 특정 정보가 필요할 경우, 먼저 캐시에 그 정보가 있는지 조사해 보아야 한다.

<br/>

<br/>

- 만약 캐시에 정보가 있다면 직접 사용하지만, 없다면 메인 메모리로부터 가져와야 한다.
    - 이때, 이 정보가 다음에 곧 다시 사용될 확률이 높다는 가정하에 캐시에 넣는다.

<br/>

<br/>

- CPU 내부의 프로그램 가능한 레지스터들은 메인 메모리를 위한 고속의 캐시로 볼 수 있다.
    - 프로그래머는 어느 정보를 메인 메모리에 두고, 어느 정보를 레지스터에 둘 지를 결정하는 레지스터 할당 정책과 교체 알고리즘을 구현한다.

<br/>

<br/>

- 전적으로 하드웨어로 구현된 캐시도 있다.
    - ex) 시스템 대부분은 다음에 수행될 것을 예상되는 명령을 넣어 두는 명령 캐시를 갖고 있다.
    - 만약 명령 캐시가 없다면, CPU는 메인 메모리로부터 다음 명령을 인출해 올 동안 몇 사이클을 기다려야 한다. → 이러한 이유로 대부분 하나 이상의 고속 데이터 캐시를 가진다.

<br/>

<br/>

- 캐시 크기가 제한이 되어 있으므로 ***캐시 관리***는 중요한 설계 문제이다.
    - 캐시 크기와 교체 정책을 신중하게 선택하면 성능이 크게 향상될 수 있다.

<br/>

<br/>

- 저장장치의 계층 구조에서 각 수준 간의 정보 이동은 하드웨어 설계나 제어하는 운영체제에 따라 명시적 또는 묵시적으로 이루어진다.
    - 캐시 → CPU 및 레지스터로의 전송 : 운영체제의 간섭 없이 하드웨어적으로 이루어짐
    - 디스크 → 메모리 간의 전송 : 운영체제에 의해 제어됨

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/migration.png" width = 500/>

<br/>

<br/>

- 메모리 계층 구조에서, 동일한 데이터가 서로 다른 수준의 저장장치 시스템에 나타나게 된다.
    - 따라서 A라는 값이 증가되면? 여러 계층에 존재하는 복사본들에 새로운 값들을 기록해주어야 한다.

<br/>

<br/>

- 어떤 시간에 오직 하나의 프로세스만 실행하는 환경에서는 이러한 기법이 아무런 문제가 없다.
    - 그러나, CPU가 여러 개의 프로세스 사이에서 이리저리 전환되는 다중 태스킹 환경이라면?
    - 여러 개의 프로세스가 A에 접근하기를 원할 경우, 갱신된 값을 얻도록 보장하기 위해 주의가 필요!!

<br/>

<br/>

- CPU가 내부 레지스터를 유지할 뿐만 아니라 로컬 캐시도 갖고 있다는 다중 처리기 환경이라면?
    - A의 복사본이 동시에 여러 캐시에 존재할 수 있고, 이런 경우는 A의 갱신된 값이 즉각 반영되어야 한다.
    - 이러한 상황을 **캐시 일관성 문제**라고 하며, 이는 일반적으로 하드웨어적 문제다.

<br/>

<br/>

- 분산 황경에서는 상황이 훨씬 더 복잡해진다.
    - 이 환경에서 동일한 파일의 여러 사본을 다른 컴퓨터에 보관할 수 있다.
    - 여러 복제본에 동시에 액세스하여 업데이트 할 수 있으므로 일부 분산 시스템은 복제본을 한 곳에서 업데이트 할 때 다른 모든 복제본을 가능한 빨리 최신 상태로 유지하는 것을 보장한다.

<br/>

<br/>

### 입출력 시스템 관리

- 운영체제의 목적 중의 하나는 사용자에게 특정 하드웨어 장치의 특성을 숨기는 것이다.
    - ex) UNIX에서 입출력 장치의 특성은 입출력 서브시스템에 의해 운영체제 자체의 대부분으로 숨겨져 있다.

<br/>

<br/>

- 입출력 시스템은 아래와 같이 구성되어 있다.
    - 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성요소
    - 일반적인 장치 드라이버 인터페이스
    - 특정 하드웨어 장치들을 위한 드라이버

<br/>

<br/>

## 💡 보안과 보호

- 만일 컴퓨터 시스템이 다수의 사용자를 가지며 다수의 프로세스 병행 수행을 허용한다면?
    - 데이터에 대한 접근은 반드시 규제되어야 한다!
    - 이를 위해 자원들에 대해 운영체제로부터 허가를 획득한 프로세스만이 작업할 수 있도록 보장해야 함.
    - ex) 타이머는 모든 프로세스가 CPU의 제어를 얻은 후 결국에는 제어를 양도하도록 보장한다.

<br/>

<br/>

- **보호(protection)**란 컴퓨터 시스템이 정의한 자원에 대해 접근을 제어하는 기법이다.
    - 이 기법은 시행될 제어에 대한 명세와 이들을 강제 시행하는 방법을 규정하는 수단을 제공해야 한다.

<br/>

<br/>

- 보호는 구성요소 서브시스템 간의 인터페이스에서 잠재적인 오류를 검출함으로써 시스템의 신뢰성을 증가시킨다.
    - 인터페이스 오류를 초기에 발견하면 종종 고장 난 서브시스템에 의해 정상적인 서브시스템이 오염되는 것을 발견할 수 있다.
    - 보호되지 않는 자원은 권한이 없거나 또는 무자격 사용자에 의해 사용되는 것을 방지할 수 없다.

<br/>

<br/>

- 컴퓨터 시스템은 충분한 보호 기능이 있더라도 여전히 고장이 나거나 부적절한 접근을 허용할 수 있다.
    - 사용자의 인증 정보가 도난당했다고 가정해보자.
    - 파일과 메모리 보호 기능이 작동하더라도 사용자의 데이터는 복사 또는 삭제될 수 있다.
    - 이러한 외부 또는 내부의 공격을 방어하는 것이 바로 **보안** 기능이다.

<br/>

<br/>

- 어떤 운영체제는 이 공격들의 일부를 막는 기능을 고려하고 있고, 어떤 운영체제는 이를 정책이나 부가적인 응용에 맡긴다.
    - 보안 사고의 놀랄만한 증가로 인하여 운영체제의 보안 기능에 관한 연구와 구현이 증가하고 있다.

<br/>

<br/>

- 보호와 보안을 제공하기 위해서는  시스템의 모든 사용자를 구분할 수 있어야 한다.
    - 운영체제의 대부분은 사용자 **식별자(user IDs)**의 리스트를 유지한다.
    - Windows 용어로는 **보안 식별자**(security ID, **SID**)라고 한다.

<br/>

<br/>

- 사용자가 로그인할 때 인증 단계에서 사용자에게 맞는 적절한 식별자를 결정한다.
    - 이 사용자 식별자는 사용자의 모든 프로세스나 스레드에 연관된다.

<br/>

<br/>

- 어떤 상황에서는 각 사용자가 아니라 사용자의 집합을 구분하기를 원한다.
    - ex) UNIX 시스템에서 파일의 소유주에게만 모든 연산을 허용하려 한다.
    - 이를 위해 그룹 이름과 그 그룹에 속한 사용자들을 정의할 필요가 있다.

<br/>

<br/>

- 그룹 기능은 시스템 전체에 존재하는 그룹 이름과 **그룹 식별자**의 리스트로 구현될 수 있다.
    - 사용자는 운영체제를 설계했을 때의 결정에 따라 하나 이상의 그룹에 속할 수 있다.
    - 사용자의 그룹 식별자는 역시 관련된 모든 프로세스나 스레드에 연관된다.

<br/>

<br/>

- 시스템을 정상적으로 사용하는 동안 사용자 식별자와 그룹 식별자만 있으면 충분하다.
    - 때때로 어떤 사용자는 작업을 수행하기 위해 권한을 상승해야 할 때가 있다.
    - 프로세스는 종료되거나 특권을 해제하기 전까지 **유효 사용자 식별자**를 이용하여 수행된다.

<br/>

<br/>

## 💡 가상화

> 💡 가상화는 단일 컴퓨터의 하드웨어를 여러 가지 실행 환경으로 추상화하여 개발 환경이 자신만의 컴퓨터에서 실행되고 있다는 환상을 만들 수 있는 기술이다.

<br/>

<br/>

- **가상 머신**의 사용자는 단일 운영체제 내에서 하나의 응용처럼 수행될 수 있게 한다.
    - 언뜻 보아서는 그러한 기능이 별 이유가 없는것 처럼 보이지만, 가상화 산업은 방대하게 성장하고 있다.

<br/>

<br/>

- 넓게 말하면 가상화 소프트웨어는 **에뮬레이션**을 포함하는 클래스의 구성원이다.
    - 소프트웨어로 컴퓨터 하드웨어  시뮬레이션하는 에뮬레이션은 일반적으로 소스 CPU 유형이 대상 CPU 유형과 다른 경우에 사용된다.
    - 이러한 개념이 한 기계를 위해 작성된 전체 운영체제를 다른 기계에서 수행되도록 확장할 수 있다.

<br/>

<br/>

- 그렇지만 에뮬레이션은 비용이 크다.
    - 소스 시스템에서 수행되는 기계어 수준의 모든 명령은 목표 시스템에서 동등한 기능으로 번역되어야 하고, 종종 이는 여러 개의 목표 명령어가 되기도 한다.

<br/>

<br/>

- 이와 달리 가상화에서는 특정 CPU를 위해 컴파일된 운영체제가 동일 CPU용의 다른 운영체제 내에서 수행된다.
    - ***가상화는 다수 사용자가 작업을 병행 수행하기 위해*** IBM 대형 컴퓨터에 처음 등장하였다.
    - 다수의 가상기계를 수행함으로써 많은 사용자들이 단일 사용자를 위해 설계된 시스템에서 작업을 수행할 수 있게 되었다.


<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/virtual-machines.png" width = 500/>

<br/>

<br/>

- 이 응용은 **게스트**라 불리는 하나 이상의 Windows나 다른 x86용 운영체제 복사본들을 수행하며 각 게스트는 자신의 응용을 수행한다.
    - Windows는 **호스트** 운영체제이고 VMware 응용은 **가상 머신 관리자(VMM)**이다.
    - VMM은 게스트 운영체제를 수행하고 그들의 자원 이용을 관리하며 각 게스트를 서로로부터 보호한다.

<br/>

<br/>

- 현대의 운영체제가 다수의 응용을 신뢰성 있게 수행할 능력이 있다고 해도, 가상화의 이용은 지속해서 성장하고 있다.
    - 다수 운영체제를 위해 소프트웨어를 작성하는 회사는 가상화를 이용하여 하나의 물리 서버를 이용하여 이들 모든 운영체제를 수행하고, 개발, 테스팅, 디버깅을 수행할 수 있다.

<br/>

<br/>

- 데이터 센터에서는 가상화가 계산 환경을 수행하고 관리하는 데 일반적인 방법이 되었다.
    - VMM은 더는 호스트 운영체제에서 실행되는 것이 아니라 가상 머신 프로세스에서 서비스 및 자원 관리를 제공하는 호스트 운영체제 그 자체다.


<br/>

<br/>

## 💡 분산 시스템

> 💡 분산 시스템은 물리적으로 떨어져 있는 이기종 컴퓨터들의 집합이다.
>
> 분산 시스템의 컴퓨터들은 사용자가 시스템 내의 다양한 자원들을 접근할 수 있도록 네트워크로 연결되어 있다.

<br/>

<br/>

- 공유 자원에 대한 접근은 계산 속도와 기능, 데이터 가용성 및 신뢰성을 향상시킨다.
    - 몇몇 운영체제는 네트워킹의 자세한 사항을 네트워크 인터페이스의 장치 드라이버에 포함시킴으로써 네트워크에 대한 접근을 파일 접근 형태로 일반화시킨다.

<br/>

<br/>

- 다른 운영체제들은 사용자가 특정 네트워크 기능을 명시적으로 호출하게 한다.
    - 일반적으로 시스템 상에는 두 모드가 혼재되어 있으며 그 예로 FTP와 NFS를 들 수 있다.
    - 분산 시스템을 만드는 프로토콜은 시스템의 유용성과 대중성에 큰 영향을 줄 수 있다.

<br/>

<br/>

- **네트워크**는 가장 단순하게 보면 두 개 이상 시스템 간의 통신 경로이다.
    - 분산 시스템의 많은 기능은 네트워킹에 의존하고 있다.
    - 네트워크는 사용되는 프로토콜, 노드 간의 거리, 그리고 전송 매체에 따라 다르다.

<br/>

<br/>

- 비록 ATM과 여타 프로토콜들이 널리 사용되고 있지만 **TCP/IP**가 가장 일반적인 네트워크 프로토콜로 인터넷의 기본 구조를 제공한다.
    - 모든 범용 운영체제를 포함하여 운영체제 대부분은 TCP/IP를 지원한다.
    - 일부 시스템은 자신들의 필요를 위해 사유의 프로토콜을 지원한다.

<br/>

<br/>

- 네트워크는 노드 간의 거리에 의해 유형이 결정된다.
    - **근거리 통신망(LAN)**은 한 방, 한 층, 또는 한 건물에 존재한다.
    - **광역 통신망(WAN)**은 통산 건물, 도시 또는 국가 사시를 연결한다.

<br/>

<br/>

- 이들 네트워크는 하나 또는 다수의 프로토콜을 사용할 수 있다.
    - 새로운 기술의 개발에 따라 새로운 형태의 네트워크가 생겨나고 있다.
    - ex) **도시권 통신망(MAN)**은 한 도시 내의 건물들을 연결할 수 있다.
    - ex) 블루투스와 802.11 장치는 무선 통신을 이용해 **단거리 통신망(PAN)**을 만든다.

<br/>

<br/>

- 네트워크에 사용되는 매체도 또한 다양하다.
    - 이들은 구리 전선, 섬유 가닥, 또는 위성 등등을 포함한다.
    - 아주 초보적인 수준에서 컴퓨터는 통신할 때마다 네트워크를 사용하거나 생성한다.
    - 이들 네트워크는 성능과 신뢰도에 차이가 있다.

<br/>

<br/>

- 일부 운영체제는 네트워크 연결 제공 개념을 넘엇서 네트워크 및 분산 시스템 개념을 취했다.
    - 네트워크 운영체제는 다른 컴퓨터의 다른 프로세스가 메시지를 교환할 수 있도록 하는 통신 체계와 함께 네트워크를 통한 파일 공유와 같은 기능을 제공하는 운영체제다.

<br/>

<br/>

- 네트워크 운영체제를 실행하는 컴퓨터는 네트워크를 인식하고 다른 네트워크 컴퓨터와 통신할 수 있지만 네트워크의 다른 모든 컴퓨터와는 자율적으로 작동한다.
    - 분산 운영체제는 그에 비해 덜 자율적인 환경을 제공한다.


<br/>

<br/>

## 💡 커널 자료구조

> 💡 운영체제의 중심이 되는 주제, 즉 시스템에서 데이터가 구조화되는 방법을 다룬다.
>
>운영체제에서 광범위하게 사용되는 다수의 기본 자료구조를 간략히 살펴보자.

<br/>

<br/>

### 리스트, 스택 및 큐

- 배열은 각 원소가 직접 접근될 수 있는 단순한 자료구조이다.
    - ex) 메인 메모리는 하나의 배열로 구축된다.
    - 저장된 데이터가 한 바이트보다 크면 그 데이터에 다수의 바이트가 할당되면 그 데이터는 `데이터 수 x 데이터 크기`로 주소가 지정된다.

<br/>

<br/>

- 그렇지만 크기가 변하는 데이터는 어떻게 저장할까?
    - 또한 한 데이터를 제거하고 나머지 데이터들을 유지해야 할 경우는 어떻게 하는가?
    - → 배열이 아닌 다른 자료구조를 사용해야 한다!

<br/>

<br/>

- 배열에 이어 아마도 리스트가 컴퓨터 과학에서 가장 기본적인 자료구조일 것이다.
    - 배열의 각 항은 직접 접근할 수 있으나 리스트의 항들은 특정 순서로 접근해야 한다.
    - 즉, **리스트**는 데이터 값들의 집단을 하나의 시퀀스로 표시한다.
    - 이 구조를 구현하는 가장 일반적인 방법이 **연결 리스트**이다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/list.png" width = 500/>

- 연결 리스트는 다수의 유형이 있다.
    - ***단일 연결 리스트*** : 각 항은 후속항을 가리킨다.
    - ***이중 연결 리스트*** : 한 항은 자신의 앞 항이나 뒤 항을 가리킨다.
    - ***원형 연결 리스트*** : 마지막이 널(null)이 아니라 첫 항을 가리킨다.

<br/>

<br/>

- 연결 리스트는 가변 수의 항들을 수용하며 항의 삭제와 삽입이 쉽다.
    - 리스트를 사용할 경우 가능한 단점은 길이가 n인 리스트에서 특정 항을 인출할 때의 성능이 선형, 즉 $O(n)$이라는 점이다. → 최악의 경우 전체 n개의 항을 전부 살펴보아야 하므로!
    - 리스트는 커널 알고리즘에 의해 자주 직접 사용된다.
    - 그렇지만 리스트는 스택이나 큐 같은 보다 강력한 자료구조를 구축하는 데에도 사용된다.

<br/>

<br/>

- **스택**은 순차적 순서를 가진 자료구조로 항을 넣거나 꺼내는 데 **후입선출(LIFO)**을 사용한다.
    - 즉, 스택에 마지막에 삽입된 항이 먼저 인출된다.
    - 스택에 항을 삽입하거나 인출하는 일은 각각 ***푸쉬(push) 또는 팝(pop)***이라 부른다.

<br/>

<br/>

- 반면, **큐**는 순차 순서의 자료구조로 **선입선출(FIFO)**을 사용한다.
    - 각 항은 삽입된 순서대로 큐에서 제거된다.

<br/>

<br/>

### 트리

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/tree.png" width = 500/>

<br/>

<br/>

- 트리는 데이터의 서열을 표시하는 데 사용 가능한 자료구조이다.
    - 트리에서 데이터들은 부모-자식 관계로 연결된다.
    - **일반 트리** : 부모는 임의의 수의 자식을 가질 수 있다.
    - **이진 트리** : 부모는 최대 두 개의 자식을 가질 수 있다.
    - **이진 탐색 트리** : 부모의 두 자식 사이에 좌측 자식 ≤ 우측 자식의 순서를 요구한다.
        - 이 외에도 **균형 이진 탐색 트리**도 있다.

<br/>

<br/>

### 해시 함수와 맵

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/hash.png" width = 500/>

<br/>

<br/>

- 해시 함수는 데이터를 입력으로 받아 이 데이터에 산술 연산을 수행하고, 하나의 수를 반환한다.
    - 이 수는 그 데이터를 인출하기 위해 테이블의 인덱스로 사용할 수 있다.
    - 크기 n인 리스트에서 데이터를 찾는 데 최대 $O(n)$의 비교가 필요한 반면
    - 테이블에서 해시 함수를 이용하여 데이터를 인출할 경우엔 $O(1)$만큼 좋을 수 있다.

<br/>

<br/>

- 해시 함수의 어려운 점은 두 개의 서로 다른 입력이 하나의 출력 값을 가질 수 있다는 것이다.
    - 즉 이들이 테이블의 동일 위치로 색인될 수 있다.
    - 이를 ***해시 충돌***이라 하며, 테이블의 각 항에 연결 리스트를 두어 동일한 해시 값을 갖는 모든 항을 수록하게 한다.

<br/>

<br/>

- 해시 함수의 한 용도는 해시 맵을 구현하는 일이다.
    - 해시 맵은 해시 함수를 이용하여 [키:값]을 연관(또는 ***맵***) 시킨다.

<br/>

<br/>

### 비트맵

> 💡 ***비트맵***은 n개의 항의 상태를 나타내는 데 사용 가능한 n개의 이진 비트의 스트링이다.


<br/>

<br/>

- 각 자원의 가용 여부를 이진 비트의 값으로 표시한다.
    - 0은 자원이 사용 가능함을 표시하고, 1은 사용 불가능함을 표시한다.
    - ex) `001011101`

<br/>

<br/>

- 비트맵은 일반적으로 대량의 자원의 가용성을 표시할 때 일반적으로 사용된다.
    - ex) 디스크 드라이브
    - 중간 크기의 디스크 드라이브는 **디스크 블록**이라 불리는 수천 개의 독립된 단위로 나누어진다.
    - 각 디스크 블록의 가용 여부를 나타내기 위해 비트맵을 사용할 수 있다.


<br/>

<br/>

## 💡 계산 환경

> 다양한 계산 환경에서 운영체제의 쓰임새
> 

### 전통적 계산

- 오늘날 웹 기술이 전통적인 계산의 경계를 확장하고 있다.
    - 회사들은 자신의 내부 서버에 웹 접근을 제공하는 포털을 구현하고 있다.
    - 네트워크 컴퓨터(또는 this client)는 실질적으로 웹 기반 컴퓨팅을 이해하는 터미널을 말하고,
    - 이들은 더 높은 보안이나 쉬운 보수가 필요한 경우 전통적 워크스테이션을 대체하여 사용하고 있다.

<br/>

<br/>

- 모바일 컴퓨터는 PC와 동기화하여 회사 정보를 쉽게 휴대할 수 있게 한다.
    - 휴대용 컴퓨터는 또한 **무선 네트워크**나 이동전화 망에 연결되어 사용할 수 있게 한다.

<br/>

<br/>

- 일부 홈은 홈 계산 환경을 보안 침해로부터 보호하기 위해 **방화벽(Firewall)**을 가진다.
    - 방화벽은 네트워크의 장치 간 통신을 제한한다.

<br/>

<br/>

- 20세기 후반에는 계산 자원이 비교적 귀했다.
    - 한동안 시스템은 배치 또는 대화형 방식이였다.
    - 배치 시스템 : 파일이나 다른 데이터 소스로부터 미리 정해진 입력을 가지고 대량으로 작업 처리
    - 대화형 방식 : 사용자로부터 입력을 기다리고, 계산 자원을 최적으로 사용하기 위함
    - 이러한 시분할 시스템 → 각 사용자에게 프로세스를 CPU에 하나씩 순환 → 타이머와 스케줄링 알고리즘 이용

<br/>

<br/>

- 오늘날 전통적 시분할 시스템은 희귀한 시스템이 되었다.
    - 동일한 스케줄링 기법이 워크스테이션과 서버에서 사용되고 있다.
    - 그러나 모든 프로세스는 한 사용자가 전부 소유하거나 또는 단일 사용자와 운영체제가 소유하고 있는 형태를 취한다.

<br/>

<br/>

### 모바일 컴퓨팅

- 모바일 컴퓨팅은 휴대용 스마트폰과 태블릿 컴퓨터의 컴퓨팅 환경을 말한다.
    - 이들 장치들은 이동 가능하고 가볍다는 구별되는 물리적 특징을 공유한다.

<br/>

<br/>

- 많은 개발자들은 이제 전역 위치 시스템(GPS) 칩, 가속도계와 자이로스코프의 독특한 기능을 활용하는 응용들을 설계하고 있다.
    - 내장된 GPS 칩은 휴대장치가 위성을 사용하여 자신의 정확한 위치를 알 수 있게 한다.
        - 이 기능은 운항(navigation)을 제공하는 응용 설계에 유용하다.
    - 가속도계는 휴대장치가 땅에 대한 자신의 위치를 탐지하고 기울이거나 흔드는 힘을 탐지한다.
        - 이런 기능은 ***증강현실***에서 실용적이다!
    

<br/>

<br/>

- 현재 휴대 컴퓨팅에서 두 개의 지배적인 운영체제는 **Apple IOS와 Google Android**이다.

<br/>

<br/>

### 클라이언트 서버  컴퓨팅

> 💡 현대 네트워크 구조는 서버 시스템이 클라이언트 시스템이 생성한 요청을 만조기키는 배치다.

<br/>

<br/>

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/client-server-system.png" width = 500/>

<br/>

<br/>

- 클라이언트-서버 시스템이라 불리는 이 형태의 특수 분산 시스템은 위 그림과 같다.
    - 서버 시스템은 대체적으로 계산 서버와 파일 서버로 분류된다.

<br/>

<br/>

- 계산-서버 시스템
    - 클라이언트가 어떤 작업을 요청할 수 있는 인터페이스를 제공한다.
    - 그 결과로 서버는 그 작업을 수행하고 결과를 클라이언트에게 돌려보낸다.

<br/>

<br/>

- 파일-서버 시스템
    - 클라이언트가 파일에 CRUD 할 수 있는 시스템 인터페이스를 제공한다.
    - 웹 브라우저 클라이언트에게 파일을 전달하는 웹 서버가 해당된다.

<br/>

<br/>

### 피어 간 계산

<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/P2P.png" width = 500/>

<br/>

<br/>

- 분산 시스템의 다른 구조는 피어 간 시스템(peer-to-peer, P2P)이다.
    - 이 모델에서는 클라이언트와 서버가 서로 구별되지 않는다.
    - 대신 시스템 상의 모든 노드가 비어로 간주되고, 각 피어는 서비스를 요청하느냐 제공하느냐에 따라 클라이언트 및 서버로 동작한다.

<br/>

<br/>

- P2P 시스템은 전통적인 클라이언트 서버에 비해 장점을 제공한다.
    - 클라이언트 서버에서는 서버가 병목으로 작용하지만,
    - P2P에서는 서비스가 네트워크에 분산된 여러 노드에 의해 제공될 수 있다.

<br/>

<br/>

- P2P 시스템에 참여하기 위해서는 노드가 먼저 P2P 네트워크에 참가해야 한다.
    - 참가하게 되면 네트워크의 다른 노드에게 서비스를 제공하거나 요청할 수 있다.

<br/>

<br/>

- 어떤 서비스가 가능한지를 결정하는 방법 2가지
    - 노드가 네트워크에 참가할 때 네트워크의 중앙 검색 서비스에 자신이 제공하는 서비스를 등록
    - 클라리언트로 동작하는 피어는 원하는 서비스를 제공하는 노드를 찾아내기 위해 네트워크 상의 모든 노드에게 서비스 요청 메시지를 방송한다.
        - 이 방식을 지원하려면 피어들이 다른 피어들이 제공하는 서비스를 발견하기 위한 ***발견 프로토콜***이 제공되어야 한다.

<br/>

<br/>

### 클라우드 컴퓨팅

> 💡 클라우드 컴퓨팅은 계산, 저장장치는 물론 응용조차도 네트워크를 통한 서비스로 제공하는 계산 유형이다. 어떤 면에서 클라우드 컴퓨팅은 가상화의 논리적 확장이다.


<img src="https://github.com/2dongyeop/TIL/blob/main/OS/image/cloud-computing.png" width = 500/>

<br/>

<br/>

- 아마존 Elastic Compute Cloud : **EC2 설비**
    - 수천의 서버, 수백만의 가상 머신 및 페타 바이트의 저장장치를 인터넷 상의 누구든지 사용하게 한다.
    - 사용자는 자신이 사용하는 자원량에 따라 매월 사용료를 지불한다.

<br/>

<br/>

- 아래를 포함하여 여러 유형의 클라우드 컴퓨팅이 존재한다.
    - **공중 클라우드** : 서비스를 위해 지불 가능한 사람은 누구나 인터넷을 통해 사용 가능한 클라우드
    - **사유 클라우드** : 한 회사가 사용하기 위해 운영하는 클라우드
    - **혼합형 클라우드** : 공공과 사유 부분을 모두 포함하는 클라우드
    - 소프트웨어 서비스(**SaaS**) : 인터넷을 통해 사용 가능한 하나 이상의 응용
    - 플랫폼 서비스(**PaaS**) : 인터넷을 통해 사용하도록 응용에 맞게 준비된 소프트웨어 스택
    - 하부구조 서비스(**IasS**) : 인터넷을 통해 사용 가능한 서버나 저장장치

<br/>

<br/>

### 실시간 내장형 시스템

- 내장형 시스템은 현재 가장 유행하는 컴퓨터의 형태이다.
    - 이 장치들은 아주 특정한 작업만을 수행하는 경향이 있다.
    - 따라서 운영체제도 제한된 기능만을 제공한다.

<br/>

<br/>

- 종류는 매우 다양하다!
    - 어떤 시스템은 UNIX같은 범용 운영체제를 수행시키면서 특수 목적을 가진 응용을 수행시킨다.
    - 다른 시스템은 필요한 기능만을 제공하는 운영체제를 가진다.
        - 따라서 특정 작업 응용 전용 칩**(ASICs)**만을 갖는 장치다.

<br/>

<br/>

- 내장형 시스템은 거의 언제나 **실시간 운영체제**를 수행한다.
    - 실시간 시스템은 처리기의 작동이나 데이터의 흐름에 엄격한 시간 제약이 있을 때 사용된다.
    - 따라서 종종 전용 응용에서 제어 장치로 사용된다.

<br/>

<br/>

- 실시간 시스템은 잘 정의된, 고정된 시간 제약을 가진다.
    - 정의된 제한 시간 내에 처리가 ***반드시*** 이루어져야 하며, 그렇지 않으면 시스템은 실패한다.

<br/>

<br/>

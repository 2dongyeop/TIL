# ORM부터 JPA까지

## 💡 ORM(Object-Relational Mapping)이란?
> 애플리케이션 Class와 RDB의 테이블을 매핑한다는 뜻으로, 
기술적으로는 어플리케이션의 객체를 RDB 테이블에 자동으로 영속화 해주는 것이라고 보면된다.

<br/>

<br/>

### ORM의 장단점
> #### 장점
1. SQL문이 아닌 Method를 통해 DB를 조작할 수 있어, 개발자는 객체 모델을 이용하여 비즈니스 로직을 구성하는데만 집중할 수 있다.
2. 객체지향적인 코드 작성이 가능하다. 오직 객체지향적 접근만 고려하면 되기때문에 생산성 증가한다.

<br/>

> #### 단점
1. 프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨리는 문제점이 발생할 수 있다.
2. 복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 써야할 수도 있음
3. 학습 비용이 비싸다.

<br/>

<br/>

## 💡 JPA(Java Persistence API)란?
> JPA는 자바 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용되는 인터페이스의 모음이다. 
>
>그 말은 즉, 실제적으로 구현된것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크이다. 
>
>JPA를 구현한 대표적인 오픈소스로는 Hibernate가 있다.

<br/>

<br/>

### JPA는 왜 사용할까?

1. ***생산성***
    1. JPA를 사용하면 자바 컬렉션에 객체를 저장하듯, JPA에게 객체를 전달하기만 하면 된다.
        
        `jpa.persist(member);`
        
    2. 이 기능들로 인해 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.

1. ***유지보수***
    1. 필드를 추가하거나, 삭제하는 과정시 추가로 작성(변경)해야 하는 코드를 JPA가 처리한다.
    2. 또한 객체지향의 장점을 살려 유연하고 유지보수하기 좋은 도메인 모델을 설계할 수 있게 한다.

1. ***패러다임 불일치 해결***
    1. JPA는 상속, 연관관계, 객체 그래프 탐색, 비교와 같은 패러다임의 불일치를 해결한다.

1. ***성능***
    1. JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다.

1. ***데이터 접근 추상화와 벤더 독립성***
    
    <img src="https://github.com/2dongyeop/TIL/blob/main/Jpa/image/jpa-basic1.png" width = 500/>
    
    1. 관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많다.
    2. *JPA는 그림처럼 추상화된 데이터 접근 계층을 제공해 특정 데이터베이스 기술에 종속되지 않는다!*
    
2. ***표준***
    1. JPA는 자바 진영의 ORM 표준이다.

<br/>

<br/>

## 💡 엔티티의 생명 주기
> 엔티티의 4가지 상태(`영속`, `비영속`, `준영속`, `삭제`)

<br/>


<img src="https://github.com/2dongyeop/TIL/blob/main/Jpa/image/jpa-basic2.png" width = 500/>


<br/>

> 비영속
> 
- 엔티티 객체를 생성했을 때는 순수한 상태로, 아직 저장하지 않았다!
    - ***따라서 당연히 영속성 컨텍스트나 데이터베이스와 전혀 관련이 없다. → 비영속 상태***
        
        <img src="https://github.com/2dongyeop/TIL/blob/main/Jpa/image/jpa-basic3.png" width = 500/>
        

<br/>

> 영속
> 
- 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 **저장**했다.
    - ***이렇게 영속성 컨텍스트가 관리하는 엔티티 → 영속 상태***
    - ***= 영속성 컨텍스트에 의해 관리됨을 의미***
        
        <img src="https://github.com/2dongyeop/TIL/blob/main/Jpa/image/jpa-basic4.png" width = 500/>
        

<br/>

> 준영속
> 
- 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 관리하지 않으면 준영속 상태가 된다.
    - 특정 엔티티를 준영속 상태로 만들려면? → `em.detach()` 호출
        - 혹은 `em.close()`로 닫거나 `em.clear()`로 초기화해도 준영속 상태가 된다.

<br/>

> 삭제
> 
- 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.
    - `em.remove(member);`

<br/>

<br/>

## 💡 영속성 컨텍스트의 이점 5가지
### 1차 캐시

- 영속성 상태의 엔티티는 모두 이곳에 저장된다.
- 쉽게 말하면 내부에 Map을 가지며, 이때 키는 `@Id`로 매핑한 식별자이고 값은 엔티티 인스턴스이다.

<img src="https://github.com/2dongyeop/TIL/blob/main/Jpa/image/jpa-basic5.png" width = 500/>

<br/>

<br/>

### 동일성 보장

<img src="https://github.com/2dongyeop/TIL/blob/main/Jpa/image/jpa-basic6.png" width = 500/>

<br/>

<br/>

### 트랜잭션을 지원하는 쓰기 지연

<img src="https://github.com/2dongyeop/TIL/blob/main/Jpa/image/jpa-basic7.png" width = 500/>

<br/>

<br/>

### 변경 감지

<img src="https://github.com/2dongyeop/TIL/blob/main/Jpa/image/jpa-basic8.png" width = 500/>

<br/>

<br/>

### 지연 로딩

<img src="https://github.com/2dongyeop/TIL/blob/main/Jpa/image/jpa-basic9.png" width = 500/>

<br/>

<br/>

## 💡 N + 1 문제란?


하위 엔티티들을 첫 쿼리 실행 시 한 번에 가져오지 않고, `지연 로딩으로 프록시가 들어온 상태`에서 후에 이것을 사용하면서 `조회 쿼리가 추가로 나가게 되어 발생하는 문제`이다.

<br/>

예시) **학생(N)과 팀(1)에서 양방향관계를 갖고 DB에서 팀을 10개를 꺼낸다**고 가정해보자.

1. 첫 쿼리는 팀 10개를 꺼내는 쿼리가 하나의 쿼리가 나간다.
→ 이때, **팀 기준 OneToMany이므로 Lazy로 동작하여 학생은 프록시로 들어오게 된다.**
2. 이 때 가져온 각각의 팀에 대해 학**생들에게 접근하는 로직이 있다면?
→** 각 팀마다 학생들을 조회하는 쿼리가 1개씩 더 나가게 된다. 즉, 10개의 쿼리가 더 나가게된다.
3. 그래서 `1개의 쿼리가 나가고 이후에 N개의 쿼리가 더 나간다`고 해서 `N+1 문제`라고 한다.

<br/>

**이에 대한 해결책은 `Fetch Join`과 `Batch Size`가 있다.**

1. Fetch Join을 사용하면? 
→ Lazy로딩으로 프록시로 들어오던 것을 **join으로 한 번에 땡겨올 수 있다**.
2. Batch Size는 N+1문제가 발생하던 것 처럼 프록시로 가져오고 학생들 가져오게 될 때 쿼리가 한번 더 나가게 되는데 **이때 in쿼리로 Batch size 개수만큼 가져온다**.
    
    → 가져온 팀이 10개이고 Batch size가 5라면, 최초에 학생을 가져오는 쿼리에서 where 조건문 in 쿼리로 5개의 team id값을 넣어서 쿼리를 날린다. 이렇게 되면 결과적으로 학생을 가져오는 쿼리는 2번이 나가게 되어 총 쿼리는 3(팀 가져오는 쿼리 + 학생 가져오는 쿼리)개의 쿼리가 나가게 된다.
    
3. 참고로 `@EntityGraph`를 사용해도 Fetch join으로 가져올 수 있다.

<br/>

위에서는 지연로딩으로 설명했지만 팀을 가져올 때, 학생들을 즉시 로딩으로 설정해둬도 팀 땡겨오고 각 팀에 대한 학생도 땡겨오기 때문에 N+1 문제가 발생한다.